(function(define) { define(function(require, ex$, module) {
ex$.$CCMM$={"$mod-version":"1.2.0","$mod-deps":[],"ceylon.language":{increasingKey:{$t:{pk:".",nm:"Comparison"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Key"},{mt:"tp",pk:".",nm:"Anything"}],nm:"Entry"},mt:"prm",nm:"x"},{$t:{pk:".",tp:[{mt:"tp",nm:"Key"},{mt:"tp",pk:".",nm:"Anything"}],nm:"Entry"},mt:"prm",nm:"y"}]],mt:"m",tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Key"}],nm:"Comparable"}],nm:"Key"}],an:{tagged:["Comparisons"],doc:["A comparator function which orders [[entries|Entry]] by \nincreasing [[natural order|Comparable]] of their \n[[keys|Entry.key]].\n       \nThis function is intended for use with [[Iterable.sort]]\nand [[Iterable.max]]."]},nm:"increasingKey"},concatenate:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"}],nm:"Sequential"},mt:"prm",an:{doc:["The streams to concatenate."]},seq:1,nm:"iterables"}]],mt:"m",tp:[{nm:"Element"}],an:{see:["expand","Iterable.chain","Sequential.append"],tagged:["Streams"],doc:["Given zero or more argument [[streams|iterables]], return a \nnew sequence containing all elements of every given stream.\nThe elements of the resulting stream are ordered first \naccording to the stream in which they occur, and then \naccording to where they occur in that stream. If there are \nno arguments, or if none of the argument streams contain \nany elements, return the empty sequence.\n\nFor example, the expression\n\n    concatenate(1..3, [0.0], {\"hello\", \"world\"})\n\nresults in the sequence `[1, 2, 3, 0.0, \"hello\", \"world\"]`\nwhich has the type `[Integer|Float|String*]`."]},nm:"concatenate"},String:{super:{pk:".",nm:"Object"},pa:97,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"Character"}],nm:"SearchableList"},{pk:".",tp:[{mt:"tp",pk:".",nm:"String"}],nm:"Comparable"},{pk:".",tp:[{mt:"tp",pk:".",nm:"String"}],nm:"Summable"},{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",pk:".",nm:"Character"},{mt:"tp",pk:".",nm:"String"}],nm:"Ranged"}],ps:[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Character"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",an:{doc:["The characters that form this string."]},nm:"characters",$hdn:1}],mt:"c",$at:{lowercased:{$t:{pk:".",nm:"String"},pa:65,mt:"a",an:{doc:["This string, with all characters in lowercase.\n\nConversion of uppercase characters to lowercase is\nperformed according to a locale-independent mapping\nthat produces incorrect results in certain locales\n(e.g. `tr-TR`).\n\nThe resulting string may not have the same number of\ncharacters as this string, since the uppercase \nrepresentation of certain characters comprises multiple\ncharacters, for example the lowercase representation of \nİ is two \ncharacters wide."]},nm:"lowercased"},rest:{$t:{pk:".",nm:"String"},pa:67,mt:"a",an:{doc:["The rest of the string, without its first character."]},nm:"rest"},last:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Character"}]},pa:67,mt:"a",an:{doc:["The last character in the string."]},nm:"last"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",an:{doc:["This string."]},nm:"string"},keys:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"}],nm:"Sequential"},pa:67,mt:"g",an:{doc:["A sequence containing all indexes of this string."]},nm:"keys"},normalized:{$t:{pk:".",nm:"String"},pa:65,mt:"a",an:{doc:["A string containing the characters of this string after \ncollapsing strings of [[whitespace|Character.whitespace]] \ninto single space characters and discarding whitespace \nfrom the beginning and end of the string."]},nm:"normalized"},characters$s4g2uj:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Character"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"a",an:{doc:["The characters that form this string."]},nm:"characters"},linesWithBreaks:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"String"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:65,mt:"g",an:{see:["lines"],doc:["Split the string into lines of text with line breaks.\nEach line will be terminated by a line break sequence,\n`\\n` or `\\r\\n`."]},nm:"linesWithBreaks"},empty:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"a",an:{see:["size"],doc:["Determines if this string has no characters, that is, \nif it has zero [[size]]. This is a _much_ more \nefficient operation than `string.size==0`."]},nm:"empty"},uppercased:{$t:{pk:".",nm:"String"},pa:65,mt:"a",an:{doc:["This string, with all characters in uppercase.\n\nConversion of lowercase characters to uppercase is\nperformed according to a locale-independent mapping\nthat produces incorrect results in certain locales\n(e.g. `tr-TR`).\n\nThe resulting string may not have the same number of\ncharacters as this string, since the uppercase \nrepresentation of certain characters comprises multiple\ncharacters, for example the uppercase representation of \nß is SS."]},nm:"uppercased"},size:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",an:{see:["longerThan","shorterThan"],doc:["The length of the string (the number of characters it \ncontains). In the case of the empty string, the string \nhas length zero. Note that this operation is \npotentially costly for long strings, since the\nunderlying representation of the characters uses a\nUTF-16 encoding. Use of [[longerThan]] or \n[[shorterThan]] is highly recommended."]},nm:"size"},lastIndex:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:3,mt:"g",an:{doc:["The index of the last character in the string, or \n`null` if the string has no characters. Note that this \noperation is potentially costly for long strings, since \nthe underlying representation of the characters uses a \nUTF-16 encoding. For any nonempty string:\n\n    string.lastIndex == string.size-1"]},nm:"lastIndex"},coalesced:{$t:{pk:".",nm:"String"},pa:3,mt:"g",an:{doc:["This string."]},nm:"coalesced"},lines:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"String"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:65,mt:"g",an:{see:["linesWithBreaks"],doc:["Split the string into lines of text, discarding line\nbreaks. Recognized line break sequences are `\\n` and \n`\\r\\n`."]},nm:"lines"},trimmed:{$t:{pk:".",nm:"String"},pa:65,mt:"g",an:{doc:["A string containing the characters of this string, \nafter discarding [[whitespace|Character.whitespace]] \nfrom the beginning and end of the string."]},nm:"trimmed"},first:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Character"}]},pa:67,mt:"a",an:{doc:["The first character in the string."]},nm:"first"},reversed:{$t:{pk:".",nm:"String"},pa:67,mt:"a",an:{doc:["A string containing the characters of this string, with\nthe characters in reverse order."]},nm:"reversed"},hash:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"hash"}},$m:{occurrences:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:67,ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",nm:"length"}]],mt:"m",nm:"occurrences"},spanFrom:{$t:{pk:".",nm:"String"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],mt:"m",an:{doc:["A string containing the characters of this string from \nthe given [[start index|from]] inclusive to the end of \nthe string. If the start index is larger than the last \nindex of the string, return the empty string. If the\nstart index is negative, return this string."]},nm:"spanFrom"},trimLeading:{$t:{pk:".",nm:"String"},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The predicate function that determines whether\na character should be trimmed"]},nm:"trimming"}]],mt:"m",an:{doc:["A string containing the characters of this string, \nafter discarding the characters matching the given \n[[predicate function|trimming]] from the \nbeginning of the string.\n\nA character is removed from the string if it matches\nthe given predicate and every character occurring \nearlier in the string also matches the predicate."]},nm:"trimLeading"},sublistFrom:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Character"}],nm:"List"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],mt:"m",nm:"sublistFrom"},replace:{$t:{pk:".",nm:"String"},pa:65,ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"substring"},{$t:{pk:".",nm:"String"},mt:"prm",nm:"replacement"}]],mt:"m",an:{doc:["Returns a string formed by replacing every occurrence \nin this string of the given [[substring]] with the \ngiven [[replacement]] string, working from the start of\nthis string to the end."]},nm:"replace"},firstIndexWhere:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"firstIndexWhere"},occurs:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",nm:"length"}]],mt:"m",nm:"occurs"},defines:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",an:{doc:["Determines if this string contains a character at the\ngiven [[index]], that is, if `0<=index<size`."]},nm:"defines"},copyTo:{$t:{pk:".",nm:"Anything"},pa:65,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Character"}],nm:"Array"},mt:"prm",an:{doc:["The array into which to copy the elements."]},nm:"destination"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The index of the first element in this array to \ncopy."]},nm:"sourcePosition"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The index in the given array into which to copy the \nfirst element."]},nm:"destinationPosition"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The number of elements to copy."]},nm:"length"}]],$ff:1,mt:"m",an:{doc:["Efficiently copy the characters in the segment\n`sourcePosition:length` of this string to the segment \n`destinationPosition:length` of the given \n[[character array|destination]]."]},nm:"copyTo"},iterator:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Character"}],nm:"Iterator"},pa:67,mt:"m",an:{doc:["An iterator for the characters of the string."]},nm:"iterator"},pad:{$t:{pk:".",nm:"String"},pa:65,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"size"},{$t:{pk:".",nm:"Character"},def:1,mt:"prm",an:{doc:["The padding character"]},nm:"character"}]],mt:"m",an:{doc:["Pad this string with the given [[character]], producing \na string of the given minimum [[size]], centering the\nstring."]},nm:"pad"},split:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"String"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Iterable"},pa:65,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"ch"}]],def:1,mt:"prm",$pt:"f",an:{doc:["A predicate that determines if a character is a\nseparator characters at which to split. Default \nto split at any \n[[whitespace|Character.whitespace]] character."]},nm:"splitting"},{$t:{pk:".",nm:"Boolean"},def:1,mt:"prm",an:{doc:["Specifies that the separator characters\noccurring in the string should be discarded. If \n`false`, they will be included in the resulting \niterator."]},nm:"discardSeparators"},{$t:{pk:".",nm:"Boolean"},def:1,mt:"prm",an:{doc:["Specifies that the separator tokens should be \ngrouped eagerly and not be treated as \nsingle-character tokens. If `false` each \nseparator token will be of size `1`."]},nm:"groupSeparators"}]],mt:"m",an:{doc:["Split the string into tokens, using the given \n[[predicate function|splitting]] to determine which \ncharacters are separator characters.\n\n    value pathElements = path.split('\/'.equals);\n\nThe flags [[discardSeparators]] and [[groupSeparators]]\ndetermine how separator characters should occur in the\nresulting stream.\n\nNote that for the case of the empty string, `split()` \nalways produces a stream containing a single empty \ntoken. For example:\n\n    \"\".split('\/'.equals)\n\nevaluates to the nonempty stream `{ \"\" }`."]},nm:"split"},trim:{$t:{pk:".",nm:"String"},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The predicate function that determines whether\na character should be trimmed"]},nm:"trimming"}]],mt:"m",an:{doc:["A string containing the characters of this string, \nafter discarding the characters matching the given \n[[predicate function|trimming]] from the beginning and \nend of the string.\n\n    value trimmed = name.trim('_'.equals);\n\nA character is removed from the string if it matches\nthe given predicate and if either:\n\n- every character occurring earlier in the string also \n  matches the predicate, or\n- every character occurring later in the string also\n  matches the predicate."]},nm:"trim"},slice:{$t:{$t:{pk:".",nm:"String"},count:2,pk:"$",nm:"Tuple"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",an:{doc:["Return two strings, the first containing the characters\nthat occur before the given [[index]], the second with\nthe characters that occur after the given `index`. If \nthe given `index` is outside the range of indices of \nthis string, one of the returned strings will be empty."]},nm:"slice"},lastOccurrence:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:67,ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",nm:"length"}]],mt:"m",nm:"lastOccurrence"},find:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Character"}]},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"find"},locateLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",pk:".",nm:"Character"}],nm:"Entry"}]},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"locateLast"},compareIgnoringCase:{$t:{pk:".",nm:"Comparison"},pa:65,ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"other"}]],mt:"m",an:{see:["Character.lowercased","Character.uppercased"],doc:["Compare this string with the given string \nlexicographically, ignoring the case of the characters.\nThat is, by considering two characters `x` and `y` as\nequal if:\n\n- `x == y`,\n- `x.uppercased == y.uppercased`, or\n- `x.lowercased == y.lowercased`.\n\nThis defines a locale-independent collation that is\nincorrect in some locales."]},nm:"compareIgnoringCase"},join:{$t:{pk:".",nm:"String"},pa:65,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Object"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"objects"}]],mt:"m",an:{doc:["Join the [[string representations|Object.string]] of \nthe given [[objects]], using this string as a separator."]},nm:"join"},reduce:{$t:{comp:"u",l:[{nm:"Result"},{pk:".",nm:"Character"},{pk:".",nm:"Null"}]},pa:67,ps:[[{$t:{nm:"Result"},ps:[[{$t:{comp:"u",l:[{nm:"Result"},{pk:".",nm:"Character"}]},mt:"prm",nm:"partial"},{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"accumulating"}]],mt:"m",tp:[{nm:"Result"}],nm:"reduce"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Character"}]},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",an:{doc:["Returns the character at the given [[index]] in the \nstring, or `null` if the index is before the start of \nthe string or past the end of string. The first \ncharacter in the string occurs at index zero. The last \ncharacter in the string occurs at index \n`string.size-1`."]},nm:"getFromFirst"},count:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"count"},includes:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Character"}],nm:"List"},mt:"prm",nm:"sublist"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",nm:"from"}]],mt:"m",nm:"includes"},indexesWhere:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"indexesWhere"},plus:{$t:{pk:".",nm:"String"},pa:67,ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Returns the concatenation of this string with the\ngiven string."]},nm:"plus"},each:{$t:{pk:".",nm:"Anything"},pa:67,ps:[[{$t:{pk:".",nm:"Anything"},ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"step"}]],$ff:1,mt:"m",nm:"each"},contains:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],mt:"m",an:{doc:["Determines if the given object is a `String` and, if \nso, if it occurs as a substring of this string, or if \nthe object is a `Character` that occurs in this string. \nThat is to say, a string is considered a [[Category]] \nof its substrings and of its characters."]},nm:"contains"},measure:{$t:{pk:".",nm:"String"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",an:{doc:["A string containing the characters of this string \nbeginning at the given [[start index|from]], returning \na string no longer than the given [[length]]. If the \nportion of this string starting at the given index is \nshorter than the given length, return the portion of \nthis string from the given index until the end of this \nstring. Otherwise, return a string of the given length. \nIf the start index is larger than the last index of the \nstring, return the empty string."]},nm:"measure"},firstOccurrence:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:67,ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",nm:"length"}]],mt:"m",nm:"firstOccurrence"},firstInclusion:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:67,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Character"}],nm:"List"},mt:"prm",nm:"sublist"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",nm:"from"}]],mt:"m",nm:"firstInclusion"},endsWith:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Anything"}],nm:"List"},mt:"prm",nm:"substring"}]],mt:"m",nm:"endsWith"},longerThan:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",an:{see:["size"],doc:["Determines if this string is longer than the given\n[[length]]. This is a more efficient operation than\n`string.size>length`."]},nm:"longerThan"},inclusions:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:67,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Character"}],nm:"List"},mt:"prm",nm:"sublist"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",nm:"from"}]],mt:"m",nm:"inclusions"},notSmallerThan:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"other"}]],mt:"m",nm:"notSmallerThan"},largerThan:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"other"}]],mt:"m",nm:"largerThan"},compare:{$t:{pk:".",nm:"Comparison"},pa:67,ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Compare this string with the given string \nlexicographically, according to the Unicode code points\nof the characters.\n\nThis defines a locale-independent collation that is\nincorrect in some locales."]},nm:"compare"},locate:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",pk:".",nm:"Character"}],nm:"Entry"}]},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"locate"},padTrailing:{$t:{pk:".",nm:"String"},pa:65,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"size"},{$t:{pk:".",nm:"Character"},def:1,mt:"prm",an:{doc:["The padding character"]},nm:"character"}]],mt:"m",an:{doc:["Right pad this string with the given [[character]], \nproducing a string of the given minimum [[size]]."]},nm:"padTrailing"},replaceFirst:{$t:{pk:".",nm:"String"},pa:65,ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"substring"},{$t:{pk:".",nm:"String"},mt:"prm",nm:"replacement"}]],mt:"m",an:{doc:["Returns a string formed by replacing the first \noccurrence in this string of the given [[substring]], \nif any, with the given [[replacement]] string."]},nm:"replaceFirst"},replaceLast:{$t:{pk:".",nm:"String"},pa:65,ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"substring"},{$t:{pk:".",nm:"String"},mt:"prm",nm:"replacement"}]],mt:"m",an:{doc:["Returns a string formed by replacing the last \noccurrence in this string of the given [[substring]], \nif any, with the given [[replacement]] string."]},nm:"replaceLast"},includesAt:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"},{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Character"}],nm:"List"},mt:"prm",nm:"sublist"}]],mt:"m",nm:"includesAt"},padLeading:{$t:{pk:".",nm:"String"},pa:65,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"size"},{$t:{pk:".",nm:"Character"},def:1,mt:"prm",an:{doc:["The padding character"]},nm:"character"}]],mt:"m",an:{doc:["Left pad this string with the given [[character]], \nproducing a string of the given minimum [[size]]."]},nm:"padLeading"},notLargerThan:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"other"}]],mt:"m",nm:"notLargerThan"},repeat:{$t:{pk:".",nm:"String"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"times"}]],mt:"m",an:{doc:["Returns a string formed by repeating this string the \ngiven number of [[times]], or the empty string if\n`times<=0`."]},nm:"repeat"},occursAt:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"},{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],mt:"m",nm:"occursAt"},trimTrailing:{$t:{pk:".",nm:"String"},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The predicate function that determines whether\na character should be trimmed"]},nm:"trimming"}]],mt:"m",an:{doc:["A string containing the characters of this string, \nafter discarding the characters matching the given \n[[predicate function|trimming]] from the end of the \nstring.\n\nA character is removed from the string if it matches\nthe given predicate and every character occurring \nlater in the string also matches the predicate."]},nm:"trimTrailing"},every:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"every"},equalsIgnoringCase:{$t:{pk:".",nm:"Boolean"},pa:65,ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"that"}]],mt:"m",an:{see:["Character.lowercased","Character.uppercased"],doc:["Compare this string with the given string, ignoring the \ncase of the characters. That is, by considering two \ncharacters `x` and `y` as equal if:\n\n- `x == y`,\n- `x.uppercased == y.uppercased`, or\n- `x.lowercased == y.lowercased`."]},nm:"equalsIgnoringCase"},lastIndexWhere:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"lastIndexWhere"},smallerThan:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"other"}]],mt:"m",nm:"smallerThan"},initial:{$t:{pk:".",nm:"String"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",an:{doc:["Select the first characters of this string, returning a \nstring no longer than the given [[length]]. If this \nstring is shorter than the given length, return this \nstring. Otherwise, return a string of the given length."]},nm:"initial"},sublistTo:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Character"}],nm:"List"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"sublistTo"},terminal:{$t:{pk:".",nm:"String"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",an:{doc:["Select the last characters of the string, returning a \nstring no longer than the given [[length]]. If this \nstring is shorter than the given length, return this \nstring. Otherwise, return a string of the given length."]},nm:"terminal"},any:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"any"},findLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Character"}]},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"findLast"},getFromLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Character"}]},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",an:{doc:["Get the character at the specified index, where the \nstring is indexed from the _end_ of the string, or \n`null` if the index falls outside the bounds of this \nstring."]},nm:"getFromLast"},spanTo:{$t:{pk:".",nm:"String"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",an:{doc:["A string containing the characters of this string from \nthe start of the string up to and including the given \n[[end index|to]]. If the end index is negative, return \nthe empty string. If the end index is larger than the\nlast index in this string, return this string."]},nm:"spanTo"},shorterThan:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",an:{see:["size"],doc:["Determines if this string is shorter than the given\n[[length]]. This is a more efficient operation than\n`string.size>length`."]},nm:"shorterThan"},equals:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],mt:"m",an:{doc:["Determines if the given object is a `String`, and if \nso, if this string has the same [[length|size]], and \nthe same [[characters]], in the same order, as the \ngiven [[string|that]]."]},nm:"equals"},clone:{$t:{pk:".",nm:"String"},pa:3,mt:"m",an:{doc:["This string."]},nm:"clone"},locations:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",pk:".",nm:"Character"}],nm:"Entry"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"locations"},span:{$t:{pk:".",nm:"String"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",an:{doc:["A string containing the characters of this string \nbetween the given indexes. If the [[start index|from]] \nis the same as the [[end index|to]], return a string \nwith a single character. If the start index is larger \nthan the end index, return the characters in the \nreverse order from the order in which they appear in \nthis string. If both the start index and the end index \nare larger than the last index in the string, or if \nboth the start index and the end index are smaller than\nthe first index in the string, return the empty string. \nOtherwise, if the last index is larger than the last \nindex in the string, return all characters from the \nstart index to last character of the string."]},nm:"span"},startsWith:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Anything"}],nm:"List"},mt:"prm",nm:"substring"}]],mt:"m",nm:"startsWith"},lastInclusion:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:67,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Character"}],nm:"List"},mt:"prm",nm:"sublist"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",nm:"from"}]],mt:"m",nm:"lastInclusion"}},an:{tagged:["Basic types","Strings"],by:["Gavin"],doc:["A string of characters. Each character in the string is a \n[[32-bit Unicode character|Character]]. The internal \nUTF-16 encoding is hidden from clients.\n\nLiteral strings may be written between double quotes:\n\n    \"hello world\"\n    \"\\r\\n\"\n    \"\\{#03C0} \\{#2248} 3.14159\"\n    \"\\{GREEK SMALL LETTER PI} \\{ALMOST EQUAL TO} 3.14159\"\n\nAlternatively, a _verbatim string_ may be written between\ntripled double quotes.\n\nThe _empty string_, `\"\"`, is a string with no characters.\n\nA string is a [[Category]] of its [[characters]], and of \nits substrings:\n\n    'w' in greeting \n    \"hello\" in greeting\n\nStrings are [[summable|Summable]]:\n\n    String greeting = \"hello\" + \" \" + \"world\";\n\nThey are efficiently [[iterable|Iterable]]:\n\n    for (char in \"hello world\") { ... }\n\nThey are [[lists|List]] of [[characters|Character]]:\n\n    value char = \"hello world\"[5];\n\nThey are [[ranged|Ranged]]:\n\n    String who = \"hello world\"[6...];\n\nNote that since `string[index]` evaluates to the optional \ntype `Character?`, it is often more convenient to write \n`string[index..index]`, which evaluates to a `String` \ncontaining a single character, or to the empty string \n`\"\"` if `index` refers to a position outside the string.\n\nIt is easy to use comprehensions to transform strings:\n\n    String { for (s in \"hello world\") if (s.letter) s.uppercased }\n\nSince a `String` has an underlying UTF-16 encoding, \ncertain operations are expensive, requiring iteration of \nthe characters of the string. In particular, [[size]]\nrequires iteration of the whole string, and `get()`,\n`span()`, and `measure()` require iteration from the \nbeginning of the string to the given index."]},nm:"String"},byItem:{$t:{pk:".",nm:"Comparison"},pa:1,ps:[[{$t:{pk:".",nm:"Comparison"},ps:[[{$t:{nm:"Item"},mt:"prm",nm:"x"},{$t:{nm:"Item"},mt:"prm",nm:"y"}]],mt:"prm",$pt:"f",nm:"comparing"}],[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Object"},{mt:"tp",nm:"Item"}],nm:"Entry"},mt:"prm",nm:"x"},{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Object"},{mt:"tp",nm:"Item"}],nm:"Entry"},mt:"prm",nm:"y"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Item"}],an:{see:["byKey"],tagged:["Comparisons"],doc:["A comparator for [[Entry]]s which compares their items \naccording to the given [[comparing]] function.\n\n    value sortedEntries = map.sort(byItem(byIncreasing(String.lowercased)));\n\nThis function is intended for use with [[Iterable.sort]]\nand [[Iterable.max]]."]},nm:"byItem"},Sequential:{pa:1,sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",nm:"Element"},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"}],nm:"Ranged"}],mt:"i",of:[{pk:".",nm:"Empty"},{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"}],$at:{rest:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:7,mt:"a",an:{doc:["The rest of the sequence, without the first element."]},nm:"rest"},size:{$t:{pk:".",nm:"Integer"},pa:7,mt:"a",an:{doc:["The strictly-positive length of this sequence, that is, \nthe number of elements in this sequence."]},nm:"size"},string:{$t:{pk:".",nm:"String"},pa:11,mt:"g",an:{doc:["A string of form `\"[ x, y, z ]\"` where `x`, `y`, and \n`z` are the `string` representations of the elements of \nthis collection, as produced by the iterator of the \ncollection, or the string `\"{}\"` if this collection \nis empty. If the collection iterator produces the value \n`null`, the string representation contains the string \n`\"null\"`."]},nm:"string"},keys:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"}],nm:"Sequential"},pa:11,mt:"g",an:{doc:["A sequence containing all indexes of this sequence,\nthat is, every index in the range `0:sequence.size`."]},nm:"keys"},reversed:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:7,mt:"a",an:{doc:["A sequence containing the elements of this sequence in\nreverse order to the order in which they occur in this\nsequence, or the [[empty sequence|empty]] if this\nsequence is the empty sequence."]},nm:"reversed"}},$m:{trimLeading:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:11,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The predicate function that determines if an \nelement at the start of this sequence should be \ntrimmed"]},nm:"trimming"}]],mt:"m",an:{doc:["Trim the elements satisfying the given predicate\nfunction from the start of this sequence, returning \na sequence no longer than this sequence."]},nm:"trimLeading"},withLeading:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Other"},{comp:"u",l:[{nm:"Element"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"Other"},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"}],nm:"Tuple"},pa:5,ps:[[{$t:{nm:"Other"},mt:"prm",an:{doc:["The first element of the resulting sequence."]},nm:"element"}]],mt:"m",tp:[{nm:"Other"}],an:{see:["prepend","withTrailing","follow"],doc:["Returns a new sequence that starts with the specified\n[[element]], followed by the elements of this sequence,\nin the order they occur in this sequence."]},nm:"withLeading"},initial:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:11,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",an:{doc:["Select the first elements of this sequence, returning \na sequence no longer than the given length. If this \nsequence is shorter than the given length, return this \nsequence. Otherwise return a sequence of the given \nlength."]},nm:"initial"},prepend:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],nm:"Sequential"},pa:5,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Sequential"},mt:"prm",nm:"elements"}]],mt:"m",tp:[{nm:"Other"}],an:{see:["append","withLeading","concatenate"],doc:["Return a sequence containing the given [[elements]], in \nthe order in which they occur in the given sequence,\nfollowed by the elements of this sequence, in the order \nin which they occur in this sequence."]},nm:"prepend"},terminal:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:11,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",an:{doc:["Select the last elements of the sequence, returning a \nsequence no longer than the given length. If this \nsequence is shorter than the given length, return this \nsequence. Otherwise return a sequence of the given \nlength."]},nm:"terminal"},sequence:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:11,mt:"m",an:{doc:["This sequence."]},nm:"sequence"},trim:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:11,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The predicate function that determines if an \nelement at the start or end of this sequence should\nbe trimmed"]},nm:"trimming"}]],mt:"m",an:{doc:["Trim the elements satisfying the given predicate\nfunction from the start and end of this sequence, \nreturning a sequence no longer than this sequence."]},nm:"trim"},slice:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},{comp:"u",l:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},{pk:".",nm:"Nothing"}]},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"}],nm:"Tuple"},pa:11,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",an:{doc:["Return two sequences, the first containing the elements\nthat occur before the given [[index]], the second with\nthe elements that occur after the given `index`. If the\ngiven `index` is outside the range of indices of this\nlist, one of the returned sequences will be empty."]},nm:"slice"},repeat:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:7,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"times"}]],mt:"m",an:{doc:["Produces a sequence formed by repeating the elements of\nthis sequence the given [[number of times|times]], or\nthe [[empty sequence|empty]] if `times<=0` or if this\nsequence is the empty sequence."]},nm:"repeat"},clone:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:11,mt:"m",an:{doc:["This sequence."]},nm:"clone"},trimTrailing:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:11,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The predicate function that determines if an \nelement at the end of this sequence should be \ntrimmed"]},nm:"trimming"}]],mt:"m",an:{doc:["Trim the elements satisfying the given predicate\nfunction from the end of this sequence, returning a \nsequence no longer than this sequence."]},nm:"trimTrailing"},withTrailing:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],nm:"Sequence"},pa:5,ps:[[{$t:{nm:"Other"},mt:"prm",an:{doc:["The last element of the resulting sequence."]},nm:"element"}]],mt:"m",tp:[{nm:"Other"}],an:{see:["append","withLeading"],doc:["Returns a new sequence that starts with the elements of \nthis sequence, in the order they occur in this sequence, \nand ends with the specified [[element]]."]},nm:"withTrailing"},append:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],nm:"Sequential"},pa:5,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Sequential"},mt:"prm",nm:"elements"}]],mt:"m",tp:[{nm:"Other"}],an:{see:["prepend","withTrailing","concatenate","chain"],doc:["Return a sequence containing the elements of this \nsequence, in the order in which they occur in this \nsequence, followed by the given [[elements]], in the \norder in which they occur in the given sequence."]},nm:"append"}},tp:[{dv:"out",def:{pk:".",nm:"Anything"},nm:"Element"}],an:{see:["Tuple"],tagged:["Sequences"],doc:["A possibly-empty, immutable sequence of values. The type \n`Sequential<Element>` may be abbreviated `[Element*]` or \n`Element[]`. \n\n`Sequential` has two enumerated subtypes:\n\n- [[Empty]], abbreviated `[]`, represents an empty \n  sequence, and\n- [[Sequence]]`<Element>`, abbreviated `[Element+]` \n  represents a non-empty sequence, and has the very \n  important subclass [[Tuple]]."]},nm:"Sequential"},FinalAnnotation:{super:{pk:".",nm:"Basic"},pa:561,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"FinalAnnotation"},{mt:"tp",pk:"ceylon.language.meta.declaration",nm:"ClassDeclaration"},{mt:"tp",pk:".",nm:"Anything"}],nm:"OptionalAnnotation"}],mt:"c",an:{doc:["The annotation class for the [[final]] annotation."]},nm:"FinalAnnotation"},tagged:{$t:{pk:".",nm:"TagsAnnotation"},pa:513,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"String"}],nm:"Sequential"},mt:"prm",an:{doc:["The tags, in plain text."]},seq:1,nm:"tags"}]],mt:"m",an:{doc:["Annotation to categorize an API by tag."]},nm:"tagged"},Obtainable:{pa:1,sts:[{pk:".",nm:"Usable"}],mt:"i",$m:{obtain:{$t:{pk:".",nm:"Anything"},pa:5,$ff:1,mt:"m",an:{doc:["Obtain this resource. Called before the body of a `try` \nstatement is executed.\n\nIf an exception is thrown by `obtain()`, then `release()` \nwill not be called."],throws:["AssertionError","if an illegal state is detected"]},nm:"obtain"},release:{$t:{pk:".",nm:"Anything"},pa:5,ps:[[{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Throwable"}]},mt:"prm",an:{doc:["The exception propagating out of the body of the \n`try` statement, or `null` if no exception was\npropagated."]},nm:"error"}]],$ff:1,mt:"m",an:{doc:["Release this resource. Called when execution of the \nbody of a `try` statement ends, even if an exception \npropagates out of the body of the `try`."],throws:["AssertionError","if an illegal state is detected"]},nm:"release"}},an:{see:["Destroyable"],tagged:["Basic types"],doc:["Abstract supertype of resources which may be obtained at\nthe beginning of a `try` statement and then released when \nthe statement completes. Unlike a [[Destroyable]] resource, \na single instance of `Obtainable` may be reused between \nmultiple `try` statements or multiple executions of the \nsame `try` statement.\n\n    Lock lock = ... ;\n    try (lock) {\n        ...\n    }\n\n- [[obtain]] is called before the body of the `try` \n  statement is executed, and\n- [[release]] is called when execution of the body of the \n  `try` statement ends, even if an exception propagates out \n  of the body of the `try`.\n\nA class which satisfies `Obtainable` may impose constraints \non the ordering and nesting of invocations of `obtain()` \nand `release()`. For example, it may be not be possible to\nobtain a resource that has already been obtained. Those \nmethods should produce an [[AssertionError]] when any such \nconstraint is violated."]},nm:"Obtainable"},Measure:{super:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Range"},pa:2080,ps:[{$t:{nm:"Element"},pa:3,mt:"prm",an:{doc:["The start of the range."]},nm:"first",$hdn:1},{$t:{pk:".",nm:"Integer"},pa:3,mt:"prm",an:{doc:["The size of the range."]},nm:"size",$hdn:1}],mt:"c",$at:{rest:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,mt:"g",nm:"rest"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"a",an:{doc:["The size of the range."]},nm:"size"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},last:{$t:{nm:"Element"},pa:3,mt:"g",nm:"last"},increasing:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"g",nm:"increasing"},lastIndex:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"lastIndex"},decreasing:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"g",nm:"decreasing"},first:{$t:{nm:"Element"},pa:3,mt:"a",an:{doc:["The start of the range."]},nm:"first"}},$m:{spanFrom:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],mt:"m",nm:"spanFrom"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"getFromFirst"},includesRange:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Range"},mt:"prm",nm:"range"}]],mt:"m",nm:"includesRange"},each:{$t:{pk:".",nm:"Anything"},pa:3,ps:[[{$t:{pk:".",nm:"Anything"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"step"}]],$ff:1,mt:"m",$m:{step$dxyy5i:{$t:{pk:".",nm:"Anything"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],$ff:1,mt:"m",nm:"step"}},nm:"each"},spanTo:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"spanTo"},iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},measure:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",nm:"measure"},shorterThan:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",nm:"shorterThan"},by:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Iterable"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"step"}]],mt:"m",nm:"by"},equals:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],mt:"m",nm:"equals"},longerThan:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",nm:"longerThan"},containsElement:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"}]],mt:"m",nm:"containsElement"},shifted:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Range"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"shift"}]],mt:"m",nm:"shifted"},span:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"span"}},tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Enumerable"}],nm:"Element"}],an:{see:["Span","Enumerable"],doc:["A [[Range]] of adjacent [[Enumerable]] values generated by \na [[first]] element, and a strictly positive [[size]]. The \nrange includes all values whose offset from `first` is \nnon-negative and less than the `size`."]},nm:"Measure",$c:{By$d85sth:{super:{pk:".",nm:"Basic"},sts:[{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Iterable"}],ps:[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"step"}],mt:"c",$at:{size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},step$ezo16c:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"step"},first:{$t:{nm:"Element"},pa:3,mt:"g",nm:"first"}},$m:{iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"}},nm:"By$d85sth"}}},Enumerable:{st:"Other",pa:1,sts:[{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Ordinal"}],mt:"i",of:[{nm:"Other"}],$at:{successor:{$t:{nm:"Other"},pa:11,mt:"g",nm:"successor"},predecessor:{$t:{nm:"Other"},pa:11,mt:"g",nm:"predecessor"}},$m:{offset:{$t:{pk:".",nm:"Integer"},pa:5,ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Compute the offset from the given value, where:\n\n- `x.offset(x) == 0`, and\n- `x.successor.offset(x) == 1` if `x!=x.successor`."],throws:["OverflowException","if the offset cannot be represented as an \ninteger"]},nm:"offset"},offsetSign:{$t:{pk:".",nm:"Integer"},pa:9,ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["The sign of the offset from the given value."]},nm:"offsetSign"},neighbour:{$t:{nm:"Other"},pa:5,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"offset"}]],mt:"m",an:{doc:["The indirect successor or predecessor at the given\n[[offset]], where:\n\n- `x.neighbour(0) == x`,\n- `x.neighbour(i+1) == x.neighbour(i).successor`, and\n- `x.neighbour(i-1) == x.neighbour(i).predecessor`."],throws:["OverflowException","if the neighbour cannot be represented as an \ninstance of the type"]},nm:"neighbour"}},tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Enumerable"}],nm:"Other"}],an:{see:["Range","span","measure"],doc:["Abstraction of [[ordinal types|Ordinal]] whose values may \nbe used as endpoints of a [[span]] or [[measure]].\n\nAn `Enumerable` type is characterized by each element \nhaving well-defined [[offset]] and [[neighbour]] functions.\nGiven an instance `x` of an enumerable type `X`:\n\n- for any integer-valued offset, there is a unique \n  _neighbour_ `y` of `X` with that offset, and\n- if `y` is an instance of `X`, then there is a\n  well-defined integer-valued _offset_ of `x` from `y`.\n\nThe offset function must satisfy:\n\n- `x.offset(x) == 0`, and\n- `x.successor.offset(x) == 1` if `x!=x.successor`.\n\nThe neighbour function must satisfy:\n\n- `x.neighbour(0) == x`,\n- `x.neighbour(n-1) == x.neighbour(n).predecessor`, and\n- `x.neighbour(n+1) == x.neighbour(n).successor`.\n\nOf course, it follows that:\n\n- `x.neighbour(-1) == x.predecessor`, and\n- `x.neighbour(1) == x.successor`.\n\nAn enumerable type may be _linear_ or _recursive_. If `X` \nis a linear enumerable type, then the offset function \nsatisfies:\n\n- `x.predecessor.offset(x) == -1` if `x!=x.predecessor`,\n- `x.offset(y) == -y.offset(x)` for any instance `y` of `X`, \n  and\n- `x.offset(y) == x.offset(z) + z.offset(y)`.\n\nOtherwise, `X` is a recursive enumerable type with a finite\nlist of enumerated instances of size `count`, and its \noffset and neighbour functions must satisfy:\n\n- `x.neighbour(count)==x`,\n- `x.offset(y) >= 0` for any instance `y` of `X`, and \n- `x.predecessor.offset(x) == count - 1`.\n\nA range of values of an enumerable type may be specified \nusing:\n\n- the _span operator_, written `first..last`, or \n- the _segment operator_, written `first:length`."]},nm:"Enumerable"},Integral:{st:"Other",pa:1,sts:[{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Number"},{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Enumerable"}],mt:"i",of:[{nm:"Other"}],$at:{zero:{$t:{pk:".",nm:"Boolean"},pa:5,mt:"a",an:{doc:["Determine if the number is the additive identity."]},nm:"zero"},unit:{$t:{pk:".",nm:"Boolean"},pa:5,mt:"a",an:{doc:["Determine if the number is the multiplicative identity."]},nm:"unit"}},$m:{divides:{$t:{pk:".",nm:"Boolean"},pa:9,ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Determine if this number is a factor of the given \nnumber."]},nm:"divides"},remainder:{$t:{nm:"Other"},pa:5,ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],mt:"m",an:{see:["Numeric.divided","modulo"],doc:["The remainder, after dividing this number by the given \nnumber."]},nm:"remainder"},modulo:{$t:{nm:"Other"},pa:9,ps:[[{$t:{nm:"Other"},mt:"prm",nm:"modulus"}]],mt:"m",an:{see:["Numeric.divided","remainder"],doc:["The modulo, after dividing this number by the given \nnumber. This differs from [[remainder]] in that the\nresult is always positive."],throws:["AssertionError","If the modulus is not strictly positive"]},nm:"modulo"}},tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Integral"}],nm:"Other"}],an:{see:["Integer"],tagged:["Numbers"],by:["Gavin"],doc:["Abstraction of integral numeric types. That is, types \nwith no fractional part, including [[Integer]].\n\nThe division operation for integral numeric types results \nin a remainder. Therefore, integral numeric types have \n[[an operation|remainder]], denoted by the _remainder_\noperator `%`, to determine the remainder of any division \noperation.\n\n    if (n%2==0) {\n        print(\"Even!\");\n    }\n\nDivision and the remainder operation should satisfy: \n\n- `x == (x\/y)*y + x%y`\n\nfor any instance `y` other than `0`.\n\nAll `Integral` numeric types are also [[Enumerable]], so \nranges of integral values may be produced using the \n[[measure]] and [[span]] operators.\n    \n    \/\/ Iterate from 0 to 100 inclusive\n    for (i in 0..100) {\n        print(\"The square of ``i`` is ``i^2``\");\n    }\n    \n    \/\/ Iterate all indices of the array, \n    \/\/ from 0 to array.size-1\n    for (i in 0:array.size) {\n        print(array[i]);\n    }"]},nm:"Integral"},OptionalAnnotation:{st:"Value",pa:1,sts:[{pk:".",tp:[{mt:"tp",nm:"Value"},{comp:"u",mt:"tp",l:[{pk:".",nm:"Null"},{nm:"Value"}]},{mt:"tp",nm:"ProgramElement"},{mt:"tp",nm:"Type"}],nm:"ConstrainedAnnotation"}],mt:"i",of:[{nm:"Value"}],tp:[{dv:"out",sts:[{pk:".",tp:[{mt:"tp",nm:"Value"},{mt:"tp",nm:"ProgramElement"},{mt:"tp",nm:"Type"}],nm:"OptionalAnnotation"}],nm:"Value"},{dv:"in",sts:[{pk:".",nm:"Annotated"}],def:{pk:".",nm:"Annotated"},nm:"ProgramElement"},{dv:"out",def:{pk:".",nm:"Anything"},nm:"Type"}],an:{see:["Annotation"],doc:["An annotation that may occur at most once at a given \nprogram element and only on certain program elements.\n\nAn optional annotation is declared simply by having the \nannotation class satisfy `OptionalAnnotation` instead of \n[[Annotation]]. For example the following would only be \nallowed on `class` declarations:\n\n    final annotation class ExampleClass() \n            satisfies OptionalAnnotation<Example, ClassDeclaration> {}\n\nAt runtime a [[ceylon.language.meta.declaration::Declaration]] \ninstance can be queried for its `OptionalAnnotation`s of a \ncertain type using [[ceylon.language.meta::annotations]] or \n[[ceylon.language.meta::optionalAnnotation]]."]},nm:"OptionalAnnotation"},identityHash:{$t:{pk:".",nm:"Integer"},pa:65,ps:[[{$t:{pk:".",nm:"Identifiable"},mt:"prm",nm:"identifiable"}]],mt:"m",an:{see:["identical"],doc:["Return the system-defined identity hash value of the given \n[[value|identifiable]]. This hash value is consistent with \n[[identity equality|Identifiable.equals]]."]},nm:"identityHash"},printStackTrace:{$t:{pk:".",nm:"Anything"},pa:65,ps:[[{$t:{pk:".",nm:"Throwable"},mt:"prm",nm:"exception"},{$t:{pk:".",nm:"Anything"},ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"string"}]],def:1,mt:"prm",$pt:"f",an:{doc:["A function that prints the given string.\nDefaults to [[process.writeError]]."]},nm:"write"}]],$ff:1,mt:"m",an:{tagged:["Environment"],doc:["Print the stack trace of the given [[Exception]] using the \ngiven [[function|write]], or to \n[[standard error|process.writeError]] if no function is \nspecified."]},nm:"printStackTrace"},digitOrSign:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Boolean"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{pk:".",nm:"Character"},{pk:".",nm:"Nothing"}]},{mt:"tp",pk:".",nm:"Character"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"}],nm:"Callable"},mt:"a",nm:"digitOrSign"},emptyOrSingleton:{$t:{comp:"u",l:[{pk:".",nm:"Empty"},{pk:".",tp:[{comp:"u",mt:"tp",l:[{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},{pk:".",nm:"Nothing"}]},{comp:"i",mt:"tp",l:[{nm:"Element"},{pk:".",nm:"Object"}]},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"}]},pa:1,ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"m",tp:[{nm:"Element"}],an:{see:["Tuple","Empty"],tagged:["Sequences"],doc:["A singleton [[Tuple]] with the given [[element]] if the \ngiven element is non-null, or the [[empty sequence|Empty]] \notherwise. This operation transforms an optional type `T?`\nto a sequence type `[]|[T]` allowing optional values to be\nthe subject of operations defined for [[streams|Iterable]].\n\nFor example, [[flat mapping|Iterable.flatMap]] \n`emptyOrSingleton()` reproduces the behavior of \n[[Iterable.coalesced]]. The expression\n\n    { \"1.23\", \"foo\", \"5.67\", \"-1\", \"\" }\n            .map(parseFloat)\n            .flatMap(emptyOrSingleton<Float?>)\n\nproduces the stream:\n \n    { 1.23, 5.67, -1.0 }"]},nm:"emptyOrSingleton"},optional:{$t:{pk:".",nm:"OptionalImportAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to specify that a module can be executed even if \nthe annotated dependency is not available."]},nm:"optional"},SeeAnnotation:{super:{pk:".",nm:"Basic"},pa:561,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"SeeAnnotation"},{mt:"tp",pk:".",nm:"Annotated"},{mt:"tp",pk:".",nm:"Anything"}],nm:"SequencedAnnotation"}],ps:[{$t:{pk:".",tp:[{mt:"tp",pk:"ceylon.language.meta.declaration",nm:"Declaration"}],nm:"Sequential"},pa:1,mt:"prm",an:{doc:["The program elements being referred to."]},seq:1,nm:"programElements"}],mt:"c",$at:{programElements:{$t:{pk:".",tp:[{mt:"tp",pk:"ceylon.language.meta.declaration",nm:"Declaration"}],nm:"Sequential"},pa:1,mt:"a",an:{doc:["The program elements being referred to."]},nm:"programElements"}},an:{doc:["The annotation class for the [[see]] annotation."]},nm:"SeeAnnotation"},ThrownExceptionAnnotation:{super:{pk:".",nm:"Basic"},pa:561,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"ThrownExceptionAnnotation"},{comp:"u",mt:"tp",l:[{pk:"ceylon.language.meta.declaration",nm:"FunctionDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ValueDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ClassDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ConstructorDeclaration"}]},{mt:"tp",pk:".",nm:"Anything"}],nm:"SequencedAnnotation"}],ps:[{$t:{pk:"ceylon.language.meta.declaration",nm:"Declaration"},pa:1,mt:"prm",an:{doc:["The [[Exception]] type that is thrown."]},nm:"type"},{$t:{pk:".",nm:"String"},pa:1,mt:"prm",an:{doc:["A description, in Markdown syntax, of the circumstances \nthat cause this exception to be thrown."]},nm:"when"}],mt:"c",$at:{type:{$t:{pk:"ceylon.language.meta.declaration",nm:"Declaration"},pa:1,mt:"a",an:{doc:["The [[Exception]] type that is thrown."]},nm:"type"},when:{$t:{pk:".",nm:"String"},pa:1,mt:"a",an:{doc:["A description, in Markdown syntax, of the circumstances \nthat cause this exception to be thrown."]},nm:"when"}},an:{doc:["The annotation class for the [[throws]] annotation."]},nm:"ThrownExceptionAnnotation"},Float:{super:{pk:".",nm:"Object"},pa:97,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"Float"}],nm:"Number"},{pk:".",tp:[{mt:"tp",pk:".",nm:"Float"},{mt:"tp",pk:".",nm:"Float"}],nm:"Exponentiable"}],ps:[{$t:{pk:".",nm:"Float"},mt:"prm",nm:"float"}],mt:"c",$at:{negated:{$t:{pk:".",nm:"Float"},pa:67,mt:"a",nm:"negated"},string:{$t:{pk:".",nm:"String"},pa:67,mt:"a",an:{see:["formatFloat"],doc:["A string representing this floating point number.\n\n- `\"NaN\"`, for any [[undefined value|undefined]]\n- `\"Infinity\"`, for [[infinity]], \n- `\"-Infinity\"`, for [[-infinity]], or,\n- a Ceylon floating point literal that evaluates to \n  this floating point number, for example, `\"1.0\"`, \n  `\"-0.0\"`, or `\"1.5E10\"`."]},nm:"string"},infinite:{$t:{pk:".",nm:"Boolean"},pa:1,mt:"g",an:{see:["infinity","finite"],doc:["Determines whether this value is infinite in magnitude. \nProduces `true` for `infinity` and `-infinity`. \nProduces `false` for a finite number, `+0.0`, `-0.0`, \nor undefined."]},nm:"infinite"},finite:{$t:{pk:".",nm:"Boolean"},pa:1,mt:"g",an:{see:["infinite","infinity"],doc:["Determines whether this value is finite. Produces\n`false` for `infinity`, `-infinity`, and undefined."]},nm:"finite"},strictlyPositive:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Determines if this value is a positive number, `+0.0`, \nor `infinity`. Produces `false` for a negative number, \n`-0.0`, or undefined."]},nm:"strictlyPositive"},sign:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",an:{doc:["The sign of this value. Produces `1` for a positive \nnumber or `infinity`. Produces `-1` for a negative\nnumber or `-infinity`. Produces `0.0` for `+0.0`, \n`-0.0`, or undefined."]},nm:"sign"},positive:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"a",an:{doc:["Determines if this value is a positive number or\n`infinity`. Produces `false` for a negative number, \n`+0.0`, `-0.0`, or undefined."]},nm:"positive"},integer:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{doc:["This value, represented as an [[Integer]], after \ntruncation of its fractional part, if such a \nrepresentation is possible."],throws:["OverflowException","if the the [[wholePart]] of this value is too large \nor too small to be represented as an `Integer`"]},nm:"integer"},undefined:{$t:{pk:".",nm:"Boolean"},pa:1,mt:"g",an:{aliased:["notANumber"],doc:["Determines whether this value is undefined. The IEEE\nstandard denotes undefined values [NaN][] (an \nabbreviation of Not a Number). Undefined values include:\n\n- _indeterminate forms_ including `0.0\/0.0`, \n  `infinity\/infinity`, `0.0*infinity`, and\n  `infinity-infinity`, along with\n- _complex numbers_ like `sqrt(-1.0)` and `log(-1.0)`.\n\nAn undefined value has the property that it is not \n[[equal|Object.equals]] (`==`) to itself, and as a \nconsequence the undefined value cannot sensibly be used \nin most collections.\n\n[NaN]: http:\/\/en.wikipedia.org\/wiki\/NaN"]},nm:"undefined"},negative:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"a",an:{doc:["Determines if this value is a negative number or\n`-infinity`. Produces `false` for a positive number, \n`+0.0`, `-0.0`, or undefined."]},nm:"negative"},wholePart:{$t:{pk:".",nm:"Float"},pa:67,mt:"a",nm:"wholePart"},strictlyNegative:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Determines if this value is a negative number, `-0.0`, \nor `-infinity`. Produces `false` for a positive number, \n`+0.0`, or undefined."]},nm:"strictlyNegative"},magnitude:{$t:{pk:".",nm:"Float"},pa:67,mt:"a",an:{aliased:["absolute"]},nm:"magnitude"},float$oirx2o:{$t:{pk:".",nm:"Float"},mt:"a",nm:"float"},hash:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"hash"},fractionalPart:{$t:{pk:".",nm:"Float"},pa:67,mt:"a",nm:"fractionalPart"}},$m:{minus:{$t:{pk:".",nm:"Float"},pa:67,ps:[[{$t:{pk:".",nm:"Float"},mt:"prm",nm:"other"}]],mt:"m",nm:"minus"},plusInteger:{$t:{pk:".",nm:"Float"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"integer"}]],mt:"m",nm:"plusInteger"},largerThan:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Float"},mt:"prm",nm:"other"}]],mt:"m",nm:"largerThan"},compare:{$t:{pk:".",nm:"Comparison"},pa:67,ps:[[{$t:{pk:".",nm:"Float"},mt:"prm",nm:"other"}]],mt:"m",nm:"compare"},smallerThan:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Float"},mt:"prm",nm:"other"}]],mt:"m",nm:"smallerThan"},divided:{$t:{pk:".",nm:"Float"},pa:67,ps:[[{$t:{pk:".",nm:"Float"},mt:"prm",nm:"other"}]],mt:"m",nm:"divided"},plus:{$t:{pk:".",nm:"Float"},pa:67,ps:[[{$t:{pk:".",nm:"Float"},mt:"prm",nm:"other"}]],mt:"m",nm:"plus"},times:{$t:{pk:".",nm:"Float"},pa:67,ps:[[{$t:{pk:".",nm:"Float"},mt:"prm",nm:"other"}]],mt:"m",nm:"times"},notLargerThan:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Float"},mt:"prm",nm:"other"}]],mt:"m",nm:"notLargerThan"},equals:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],mt:"m",an:{doc:["Determines if the given object is equal to this `Float`,\nthat is, if:\n\n- the given object is also a `Float`,\n- neither this value nor the given value is \n  [[undefined]], and either\n- both values are [[infinite]] and have the same \n  [[sign]], or both represent the same finite floating \n  point value as defined by the IEEE specification.\n\nOr if:\n\n- the given object is an [[Integer]],\n- this value is neither [[undefined]], nor [[infinite]],\n- the [[fractionalPart]] of this value equals `0.0`, \n- the [[integer]] part of this value equals the given \n  integer, and\n- the given integer is between -2<sup>53<\/sup> and \n  2<sup>53<\/sup> (exclusive)."]},nm:"equals"},power:{$t:{pk:".",nm:"Float"},pa:67,ps:[[{$t:{pk:".",nm:"Float"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["The result of raising this number to the given floating\npoint power, where, following the definition of the\nIEEE `pow()` function, the following indeterminate \nforms all evaluate to `1.0`:\n\n- `0.0^0.0`,\n- `infinity^0.0` and `(-infinity)^0.0`, \n- `1.0^infinity` and `(-1.0)^infinity`.\n\nFurthermore:\n\n - `0.0^infinity` evaluates to `0.0`, and\n - `0.0^(-infinity)` evaluates to `infinity`.\n\nIf this is a [[negative]] number, and the given \n[[power|other]] has a nonzero [[fractionalPart]], the \nresult is [[undefined]].\n\nFor any negative power `y<0.0`:\n\n- `0.0^y` evaluates to `infinity`,\n- `(-0.0)^y` evaluates to `-infinity`, and\n- for any nonzero floating point number `x`, `x^y` \n  evaluates to `1.0\/x^(-y)`."]},nm:"power"},powerOfInteger:{$t:{pk:".",nm:"Float"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"integer"}]],mt:"m",an:{doc:["The result of raising this number to the given integer\npower, where the following indeterminate forms evaluate \nto `1.0`:\n\n- `0.0^0`,\n- `infinity^0` and `(-infinity)^0`.\n\nFor any negative integer power `n<0`:\n\n- `0.0^n` evaluates to `infinity`,\n- `(-0.0)^n` evaluates to `-infinity`, and\n- for any nonzero floating point number `x`, `x^n` \n  evaluates to `1.0\/x^(-n)`."]},nm:"powerOfInteger"},timesInteger:{$t:{pk:".",nm:"Float"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"integer"}]],mt:"m",nm:"timesInteger"},notSmallerThan:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Float"},mt:"prm",nm:"other"}]],mt:"m",nm:"notSmallerThan"}},an:{see:["parseFloat"],tagged:["Basic types","Numbers"],doc:["An IEEE 754 64-bit [floating point number][]. A `Float` is \ncapable of approximately representing numeric values \nbetween:\n\n- 2<sup>-1022<\/sup>, approximately \n  1.79769×10<sup>308<\/sup>, and \n- (2-2<sup>-52<\/sup>)×2<sup>1023<\/sup>, \n  approximately 5×10<sup>-324<\/sup>.\n\nZero is represented by distinct instances `+0.0`, `-0.0`, \nbut these instances are equal. `-0.0` can be distinguished\nfrom `+0.0` using `f == 0.0 && f.strictlyNegative`.\n\nIn addition, the following special values exist:\n\n- [[infinity]] and `-infinity`, and\n- [[undefined values|undefined]], denoted [NaN][] by the\n  IEEE standard.\n\nAs required by the IEEE standard no undefined value is \nequal to any other value, nor even to itself. Thus, the \ndefinition of [[equals]] for `Float` violates the general \ncontract defined by [[Object.equals]].\n\nA floating point value with a zero [[fractionalPart]] is\nconsidered equal to its [[integer]] part.\n\nLiteral floating point values are written with a decimal\npoint and, optionally, a magnitude or exponent:\n\n    1.0\n    1.0E6\n    1.0M\n    1.0E-6\n    1.0u\n\nIn the case of a fractional magnitude, the decimal point is\noptional. Underscores may be used to group digits into \ngroups of three.\n\n[floating point number]: http:\/\/www.validlab.com\/goldberg\/paper.pdf\n[NaN]: http:\/\/en.wikipedia.org\/wiki\/NaN"]},nm:"Float"},parseDigit:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"digit"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"radix"}]],mt:"m",nm:"parseDigit"},parseFloatExponent:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"string"}]],mt:"m",nm:"parseFloatExponent"},shared:{$t:{pk:".",nm:"SharedAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to mark a declaration as shared. A `shared` \ndeclaration is visible outside the block of code in which \nit is declared."]},nm:"shared"},emptySet:{super:{pk:".",nm:"Object"},pa:1,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"}],nm:"Set"}],mt:"o",$at:{size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"},empty:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"g",nm:"empty"}},$m:{superset:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Object"}],nm:"Set"},mt:"prm",nm:"set"}]],mt:"m",nm:"superset"},containsAny:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Object"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"elements"}]],mt:"m",nm:"containsAny"},count:{$t:{pk:".",nm:"Integer"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"count"},containsEvery:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Object"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"elements"}]],mt:"m",nm:"containsEvery"},skip:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"skipping"}]],mt:"m",nm:"skip"},union:{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Set"},pa:3,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Set"},mt:"prm",nm:"set"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Other"}],nm:"union"},any:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"any"},each:{$t:{pk:".",nm:"Anything"},pa:3,ps:[[{$t:{pk:".",nm:"Anything"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"step"}]],$ff:1,mt:"m",$m:{step$b54ftw:{$t:{pk:".",nm:"Anything"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],$ff:1,mt:"m",nm:"step"}},nm:"each"},exclusiveUnion:{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Set"},pa:3,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Set"},mt:"prm",nm:"set"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Other"}],nm:"exclusiveUnion"},findLast:{$t:{pk:".",nm:"Null"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"findLast"},take:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"taking"}]],mt:"m",nm:"take"},iterator:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},contains:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],mt:"m",nm:"contains"},find:{$t:{pk:".",nm:"Null"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"find"},intersection:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"}],nm:"Set"},pa:3,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Set"},mt:"prm",nm:"set"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Other"}],nm:"intersection"},by:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"step"}]],mt:"m",nm:"by"},clone:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"}],nm:"Set"},pa:3,mt:"m",nm:"clone"},complement:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"}],nm:"Set"},pa:3,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Set"},mt:"prm",nm:"set"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Other"}],nm:"complement"},every:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"every"},subset:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Object"}],nm:"Set"},mt:"prm",nm:"set"}]],mt:"m",nm:"subset"}},an:{tagged:["Collections"],doc:["An immutable [[Set]] with no elements."]},nm:"emptySet"},Set:{pa:1,sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Collection"}],mt:"i",$at:{distinct:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:3,mt:"g",nm:"distinct"},hash:{$t:{pk:".",nm:"Integer"},pa:11,mt:"g",nm:"hash"}},$m:{contains:{$t:{pk:".",nm:"Boolean"},pa:11,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],mt:"m",an:{doc:["The fundamental operation for `Set`s. Determines if the\ngiven value belongs to this set."]},nm:"contains"},superset:{$t:{pk:".",nm:"Boolean"},pa:9,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Object"}],nm:"Set"},mt:"prm",nm:"set"}]],mt:"m",an:{doc:["Determines if this set is a superset of the given \n`Set`, that is, if this set contains all of the \nelements in the given set."]},nm:"superset"},intersection:{$t:{pk:".",tp:[{comp:"i",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],nm:"Set"},pa:9,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Set"},mt:"prm",nm:"set"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Other"}],an:{doc:["Returns a new `Set` containing only the elements that \nare present in both this set and the given `Set` and \nthat are instances of the intersection `Element&Other` \nof the element types of the two sets.\n\nNote that, according to this definition, and even \nthough `1==1.0` [[evaluates to true|Integer.equals]], \nthe expression\n\n    set { 1 } & set { 1.0 }\n\nproduces the empty set `{}`."]},nm:"intersection"},equals:{$t:{pk:".",nm:"Boolean"},pa:11,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],mt:"m",an:{doc:["Two `Set`s are considered equal if they have the same \nsize and if every element of the first set is also an \nelement of the second set, as determined by \n[[contains]]. Equivalently, a set is equal to a second \nset if it is both a subset and a superset of the second\nset."]},nm:"equals"},clone:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Set"},pa:7,mt:"m",an:{doc:["A shallow copy of this set, that is, a set with the\nsame elements as this set, which do not change if the\nelements of this set change."]},nm:"clone"},union:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],nm:"Set"},pa:9,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Set"},mt:"prm",nm:"set"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Other"}],an:{doc:["Returns a new `Set` containing all the elements of this \nset and all the elements of the given `Set`.\n\nNote that it is possible for two sets of disjoint \nelement type to be considered to have elements in \ncommon. For example, since `1==1.0` \n[[evaluates to true|Integer.equals]], \nthe expression \n\n    set { 1 } | set { 1.0 }\n\nproduces the set `{ 1 }`."]},nm:"union"},defaultNullElements:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:3,ps:[[{$t:{nm:"Default"},mt:"prm",nm:"defaultValue"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Default"}],nm:"defaultNullElements"},complement:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Set"},pa:9,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Set"},mt:"prm",nm:"set"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Other"}],an:{doc:["Returns a new `Set` containing all the elements in this \nset that are not contained in the given `Set`."]},nm:"complement"},subset:{$t:{pk:".",nm:"Boolean"},pa:9,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Object"}],nm:"Set"},mt:"prm",nm:"set"}]],mt:"m",an:{doc:["Determines if this set is a subset of the given `Set`, \nthat is, if the given set contains all of the elements \nin this set."]},nm:"subset"},exclusiveUnion:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],nm:"Set"},pa:9,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Set"},mt:"prm",nm:"set"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Other"}],an:{doc:["Returns a new `Set` containing only the elements \ncontained in either this set or the given `Set`, but no \nelement contained in both sets."]},nm:"exclusiveUnion"}},tp:[{dv:"out",sts:[{pk:".",nm:"Object"}],def:{pk:".",nm:"Object"},nm:"Element"}],an:{see:["set"],tagged:["Collections"],doc:["A collection in which each distinct element occurs at most \nonce. Two non-[[identical|Identifiable]] values are \nconsidered distinct only if they are unequal, according to\ntheir own definition of [[value equality|Object.equals]].\n\nA `Set` is a [[Collection]] of its elements. Sets may not\nhave [[null|Null]] elements.\n\nA new `Set` may be obtained by calling the function [[set]].\n    \n    value words = set { \"hello\", \"world\" };\n    value greetings = set { \"hello\", \"goodbye\", \"hola\", \"adios\" };\n    \nSets may be the subject of the binary union, intersection, \nand complement operators `|`, `&`, and `~`.\n\n    value greetingsInWords = words & greetings;\n    value allWords = words | greetings;\n\nAn implementation of `Set` may compare elements for \nequality using [[Object.equals]] or [[Comparable.compare]]."]},nm:"Set"},sum:{$t:{nm:"Value"},pa:65,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Value"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Iterable"},mt:"prm",nm:"values"}]],mt:"m",tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Value"}],nm:"Summable"}],nm:"Value"}],an:{see:["product"],tagged:["Streams","Numbers"],doc:["Given a nonempty stream of [[Summable]] values, return the \nsum of the values.\n\n    {Float+} values = ... ;\n    Float total = sum(values);\n\nFor the case of a possibly-empty stream, form a nonempty \nstream starting with the zero element (the [[additive \nidentity|Summable]]).\n\n    {Float*} values = ... ;\n    Float total = sum { 0.0, *values };"]},nm:"sum"},ActualAnnotation:{super:{pk:".",nm:"Basic"},pa:561,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"ActualAnnotation"},{comp:"u",mt:"tp",l:[{pk:"ceylon.language.meta.declaration",nm:"FunctionDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ValueDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ClassOrInterfaceDeclaration"}]},{mt:"tp",pk:".",nm:"Anything"}],nm:"OptionalAnnotation"}],mt:"c",an:{doc:["The annotation class for the [[actual]] annotation."]},nm:"ActualAnnotation"},default:{$t:{pk:".",nm:"DefaultAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to mark a member whose implementation may be \nrefined by subtypes. Non-`default` declarations may not be \nrefined."]},nm:"default"},see:{$t:{pk:".",nm:"SeeAnnotation"},pa:513,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:"ceylon.language.meta.declaration",nm:"Declaration"}],nm:"Sequential"},mt:"prm",an:{doc:["The program elements being referred to."]},seq:1,nm:"programElements"}]],mt:"m",an:{doc:["Annotation to specify references to other program elements\nrelated to the annotated API."]},nm:"see"},Contextual:{super:{pk:".",nm:"Basic"},pa:65,mt:"c",$m:{get:{$t:{nm:"Element"},pa:65,mt:"m",an:{doc:["Retrieves the value previously set. Will throw an assertion\nexception if called when not within a try-resource block"]},nm:"get"}},tp:[{nm:"Element"}],an:{by:["Tako Schotanus"],doc:["Stores values local to the current thread of execution\nmeaning that each thread or process that accesses these\nvalues get to see their own copy. If the underlying\nplatform does not support threading the practical effect\nof this class is no different than using a local value.\n\nSetting a value is done by creating an instance of\n`Contextual.Using`, passing it the required value, or a\nfunction that will return the needed value when necessary,\nand passing it to a try-resource statement.\n\nIf a function is used to set the value then that value will\nbe retrieved the moment the try-resource block is entered.\nIf the same `Using` is re-used then the value will be\nrefreshed by calling the function again.\n\nWhen entering a try-resource block any previous value is\nstored and then restored at the end of the block so nested\ntry-resource blocks are possible.\n\nRetrieving the value is done using `get()`. Doing so when\nno try-resource statement is active will result in an\nassertion exception.\n\nAn example:\n\n    Contextual<String> stringValue = Contextual<String>();\n    Contextual<Integer> intValue = Contextual<Integer>();\n    try (stringValue.Using(\"foo\"),\n            intValue.Using(system.milliseconds)) {\n        print(stringValue.get()); \/\/ prints \"foo\"\n        print(intValue.get());    \/\/ prints the current time in ms\n        try (stringValue.Using(\"bar\")) {\n            print(stringValue.get()); \/\/ prints \"bar\"\n            print(intValue.get());    \/\/ prints same number as before\n        }\n    }\n    \nNB: This example only shows how to *use* `Contextual` and\ndoes not show anything thread-related.\n"]},nm:"Contextual",$c:{Using:{super:{pk:".",nm:"Basic"},pa:65,sts:[{pk:".",nm:"Obtainable"}],ps:[{$t:{comp:"u",l:[{nm:"Element"},{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Callable"}]},mt:"prm",nm:"newValue"}],mt:"c",$at:{newValue$n3vsh3:{$t:{comp:"u",l:[{nm:"Element"},{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Callable"}]},mt:"a",nm:"newValue"}},$m:{obtain:{$t:{pk:".",nm:"Anything"},pa:67,$ff:1,mt:"m",nm:"obtain"},release:{$t:{pk:".",nm:"Anything"},pa:67,ps:[[{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Throwable"}]},mt:"prm",nm:"error"}]],$ff:1,mt:"m",nm:"release"}},an:{doc:["Used to set a value for this `Contextual`"]},nm:"Using"}}},Entry:{super:{pk:".",nm:"Object"},pa:2081,ps:[{$t:{nm:"Key"},pa:1,mt:"prm",an:{doc:["The key used to access the entry."]},nm:"key",$hdn:1},{$t:{nm:"Item"},pa:1,mt:"prm",an:{doc:["The item associated with the key."]},nm:"item",$hdn:1}],mt:"c",$at:{item:{$t:{nm:"Item"},pa:1,mt:"a",an:{doc:["The item associated with the key."]},nm:"item"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",an:{doc:["A description of the entry in the form `key->item`. If \n[[item]] is `null`, its string representation is the \nstring `\"<null>\"`."]},nm:"string"},coalesced:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Key"},{comp:"i",mt:"tp",l:[{nm:"Item"},{pk:".",nm:"Object"}]}],nm:"Entry"}]},pa:1,mt:"g",an:{doc:["An `Entry` with the key and item of this entry if this \nentry's item is non-null, or `null` otherwise."]},nm:"coalesced"},key:{$t:{nm:"Key"},pa:1,mt:"a",an:{doc:["The key used to access the entry."]},nm:"key"},pair:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Key"},{comp:"u",l:[{nm:"Item"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"Key"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Item"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Item"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"}],nm:"Tuple"},pa:1,mt:"g",an:{doc:["A pair (2 element tuple) with the key and item of this \nentry. For any `entry`:\n\n    entry.pair == [entry.key,entry.item]"]},nm:"pair"},hash:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"hash"}},$m:{equals:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],mt:"m",an:{doc:["Determines if this entry is equal to the given entry. \nTwo entries are equal if they have the same key and \nthe same item. \n\n- The keys are considered the same if they are equal,\n  in the sense of [[value equality|Object.equals]].\n- Two items are considered the same if they are both \n  null or if neither is null and they are equal."]},nm:"equals"}},tp:[{dv:"out",sts:[{pk:".",nm:"Object"}],nm:"Key"},{dv:"out",nm:"Item"}],an:{tagged:["Collections"],by:["Gavin"],doc:["A pair containing a _key_ and an associated value called \nthe _item_. Used primarily to represent the elements of a \n[[Map]]. The type `Entry<Key,Item>` may be abbreviated \n`Key->Item`. An instance of `Entry` may be constructed \nusing the `->` operator:\n\n    String->Person entry = person.name->person;"]},nm:"Entry"},min:{$t:{comp:"u",l:[{nm:"Absent"},{nm:"Value"}]},pa:65,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Value"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},mt:"prm",nm:"values"}]],mt:"m",tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Value"}],nm:"Comparable"}],nm:"Value"},{sts:[{pk:".",nm:"Null"}],nm:"Absent"}],an:{see:["Comparable","max","smallest"],tagged:["Comparisons","Streams"],doc:["Given a stream of [[Comparable]] values, return the \nsmallest value in the stream, or `null` if the stream is\nempty.\n\nFor any nonempty stream `it`, `min(it)` evaluates to the \nfirst element of `it` such that for every element `e` of \n`it`, `min(it) <= e`."]},nm:"min"},Comparison:{super:{pk:".",nm:"Basic"},pa:257,ps:[{$t:{pk:".",nm:"String"},pa:3,mt:"prm",nm:"string"}],mt:"c",of:[{pk:".",nm:"larger"},{pk:".",nm:"smaller"},{pk:".",nm:"equal"}],$at:{string:{$t:{pk:".",nm:"String"},pa:3,mt:"a",nm:"string"},reversed:{$t:{pk:".",nm:"Comparison"},pa:5,mt:"a",an:{doc:["The reversed value of this comparison."]},nm:"reversed"}},an:{see:["Comparable"],tagged:["Comparisons"],by:["Gavin"],doc:["The result of a comparison between two [[Comparable]] \nobjects: [[larger]], [[smaller]], or [[equal]]."]},nm:"Comparison"},interleave:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"Absent"}],nm:"Iterable"}],nm:"Sequence"},mt:"prm",$min1:1,seq:1,nm:"iterables"}]],mt:"m",tp:[{nm:"Element"},{sts:[{pk:".",nm:"Null"}],nm:"Absent"}],an:{see:["Iterable.interpose"],tagged:["Streams"],doc:["Given one or more argument [[streams|iterables]], return a\nstream containing elements of the given streams. The \nelements are ordered first according to their position in \nthe argument stream, and then according to the stream in \nwhich they occur. The resulting stream contains exactly the \nsame number of elements from each stream.\n\nFor example, the expression\n\n    interleave(1..5, \"-+\".cycled)\n\nresults in the stream \n`{ 1, '-', 2, '+', 3, '-', 4, '+', 5, '-' }`."]},nm:"interleave"},by:{$t:{pk:".",nm:"AuthorsAnnotation"},pa:513,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"String"}],nm:"Sequential"},mt:"prm",an:{doc:["The authors, in Markdown syntax, of the annotated \nprogram element"]},seq:1,nm:"authors"}]],mt:"m",an:{doc:["Annotation to document the authors of an API."]},nm:"by"},annotation:{$t:{pk:".",nm:"AnnotationAnnotation"},pa:513,mt:"m",an:{see:["Annotation"],doc:["Annotation to mark a class as an *annotation class*, or a \ntop-level function as an *annotation constructor*."]},nm:"annotation"},everyPair:{$t:{pk:".",nm:"Boolean"},pa:1,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"First"},mt:"prm",nm:"first"},{$t:{nm:"Second"},mt:"prm",nm:"second"}]],mt:"prm",$pt:"f",an:{doc:["The binary predicate function to apply to each pair of \nelements."]},nm:"selecting"},{$t:{pk:".",tp:[{mt:"tp",nm:"First"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"firstIterable"},{$t:{pk:".",tp:[{mt:"tp",nm:"Second"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"secondIterable"}]],mt:"m",$m:{selecting$dw9v1x:{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"First"},mt:"prm",nm:"first"},{$t:{nm:"Second"},mt:"prm",nm:"second"}]],mt:"m",an:{doc:["The binary predicate function to apply to each pair of \nelements."]},nm:"selecting"}},tp:[{nm:"First"},{nm:"Second"}],an:{see:["corresponding","anyPair"],tagged:["Streams"],doc:["Given two streams, return `true` if every pair of elements \nin the given streams satisfies the given binary [[predicate\nfunction|selecting]], or `false` otherwise. If one of the\nstreams is longer than the other, simply ignore additional \nelements of the longer stream with no pair in the other \nstream. If either stream is empty, return `true`.\n\nFor any given streams `xs` and `ys`, and predicate function \n`p`, `everyPair()` may be defined in terms of \n[[Iterable.every]], [[zipPairs]], and [[unflatten]]:\n\n    everyPair(p, xs, ys) == zipPairs(xs, ys).every(unflatten(p))"]},nm:"everyPair"},set:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Set"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",an:{doc:["The stream of elements."]},nm:"stream"},{$t:{nm:"Element"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"earlier"},{$t:{nm:"Element"},mt:"prm",nm:"later"}]],def:1,mt:"prm",$pt:"f",an:{doc:["A function that chooses between duplicate elements. \nBy default, the element that occurs _earlier_ in \nthe stream is chosen."]},nm:"choosing"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Element"}],an:{see:["Iterable.distinct"],doc:["Create a new immutable [[Set]] containing every element \nproduced by the given [[stream]], resolving items with\nduplicate keys according to the given [[function|choosing]].\n\nFor example:\n\n    set { 0, 1, 1, 2, 3, 3, 3 }\n\nproduces the set `{ 0, 1, 2, 3 }`.\n\nThis is an eager operation and the resulting set does\nnot reflect changes to the given [[stream]]."]},nm:"set"},AuthorsAnnotation:{super:{pk:".",nm:"Basic"},pa:561,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"AuthorsAnnotation"},{mt:"tp",pk:".",nm:"Annotated"},{mt:"tp",pk:".",nm:"Anything"}],nm:"OptionalAnnotation"}],ps:[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"String"}],nm:"Sequential"},pa:1,mt:"prm",an:{doc:["The authors, in Markdown syntax, of the annotated \nprogram element"]},seq:1,nm:"authors"}],mt:"c",$at:{authors:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"String"}],nm:"Sequential"},pa:1,mt:"a",an:{doc:["The authors, in Markdown syntax, of the annotated \nprogram element"]},nm:"authors"}},an:{doc:["The annotation class for the [[by]] annotation."]},nm:"AuthorsAnnotation"},increasing:{$t:{pk:".",nm:"Comparison"},pa:1,ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],mt:"m",tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Comparable"}],nm:"Element"}],an:{see:["decreasing","byIncreasing","Iterable.max","Iterable.sort"],tagged:["Comparisons"],doc:["A comparator function which orders elements in increasing \n[[natural order|Comparable]].\n\n       \"Hello World!\".sort(increasing)\n\nThis function is intended for use with [[Iterable.sort]]\nand [[Iterable.max]]."]},nm:"increasing"},infinity:{$t:{pk:".",nm:"Float"},pa:65,mt:"a",an:{tagged:["Numbers"],doc:["An instance of [[Float]] representing positive infinity, \n∞, the result of dividing a positive number by zero. \nNegative infinity, -∞, the result of dividing a\nnegative number by zero, is the additive inverse `-infinity`.\n\nNote that any floating-point computation that results in a\npositive value too large to be represented as a `Float` is \n\"rounded up\" to `infinity`. Likewise, any floating-point \ncomputation that yields a negative value whose magnitude is\ntoo large to be represented as a `Float` is \"rounded down\" \nto `-infinity`."]},nm:"infinity"},formatInteger:{$t:{pk:".",nm:"String"},pa:1,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",an:{doc:["The integer value to format."]},nm:"integer"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The base, between [[minRadix]] and [[maxRadix]] \ninclusive."]},nm:"radix"}]],mt:"m",an:{see:["formatFloat","parseInteger"],tagged:["Numbers"],doc:["The string representation of the given [[integer]] in the \nbase given by [[radix]]. If the given integer is \n[[negative|Integer.negative]], the string representation \nwill begin with `-`. Digits consist of decimal digits `0` \nto `9`, together with and lowercase letters `a` to `z` for \nbases greater than 10.\n\nFor example:\n\n- `formatInteger(-46)` is `\"-46\"`\n- `formatInteger(9,2)` is `\"1001\"`\n- `formatInteger(10,8)` is `\"12\"`\n- `formatInteger(511,16)` is `\"1ff\"`\n- `formatInteger(512,32)` is `\"g0\"`"],throws:["AssertionError","if [[radix]] is not between [[minRadix]] and \n[[maxRadix]]"]},nm:"formatInteger"},OverflowException:{super:{pk:".",nm:"Exception"},pa:1,ps:[{$t:{pk:".",nm:"String"},def:1,mt:"prm",nm:"message"}],mt:"c",$at:{message$zh6xok:{$t:{pk:".",nm:"String"},mt:"a",nm:"message"}},an:{doc:["Thrown when a mathematical operation caused a number to \noverflow from its bounds, or when a numeric narrowing\nconversion fails because the number cannot be represented\nwithin the bounds of the narrower type.\n\nNote that:\n\n- arithmetic operations on [[Integer]]s result in _silent_ \n  overflow (JVM) or loss of precision (JavaScript), and \n  thus never result in an `OverflowException`, and, \n- likewise, arithmetic operations on [[Float]] produce the \n  value [[infinity]] instead of overflowing."]},nm:"OverflowException"},GroupEntry:{super:{pk:".",nm:"Basic"},ps:[{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Group"},{mt:"tp",nm:"Result"}],nm:"GroupEntry"}]},pa:1,mt:"prm",nm:"next",$hdn:1},{$t:{nm:"Group"},pa:1,mt:"prm",nm:"group",$hdn:1},{$t:{nm:"Result"},pa:1025,mt:"prm",nm:"elements",$hdn:1}],mt:"c",$at:{next:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Group"},{mt:"tp",nm:"Result"}],nm:"GroupEntry"}]},pa:1,mt:"a",nm:"next"},elements:{$t:{nm:"Result"},pa:1025,mt:"a",nm:"elements"},group:{$t:{nm:"Group"},pa:1,mt:"a",nm:"group"}},$m:{get:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Group"},{mt:"tp",nm:"Result"}],nm:"GroupEntry"}]},pa:1,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"group"}]],mt:"m",nm:"get"}},tp:[{sts:[{pk:".",nm:"Object"}],nm:"Group"},{nm:"Result"}],nm:"GroupEntry"},Comparable:{st:"Other",pa:1,mt:"i",of:[{nm:"Other"}],$m:{largerThan:{$t:{pk:".",nm:"Boolean"},pa:9,ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Determines if this value is strictly larger than the \ngiven value."]},nm:"largerThan"},compare:{$t:{pk:".",nm:"Comparison"},pa:5,ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],mt:"m",an:{see:["equals"],doc:["Compares this value with the given value. \nImplementations must respect the constraints that: \n\n- `x==y` if and only if `x<=>y == equal` \n   (consistency with `equals()`), \n- if `x>y` then `y<x` (symmetry), and \n- if `x>y` and `y>z` then `x>z` (transitivity)."]},nm:"compare"},smallerThan:{$t:{pk:".",nm:"Boolean"},pa:9,ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Determines if this value is strictly smaller than the \ngiven value."]},nm:"smallerThan"},notLargerThan:{$t:{pk:".",nm:"Boolean"},pa:9,ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Determines if this value is smaller than or equal to \nthe given value."]},nm:"notLargerThan"},notSmallerThan:{$t:{pk:".",nm:"Boolean"},pa:9,ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Determines if this value is larger than or equal to the \ngiven value."]},nm:"notSmallerThan"}},tp:[{dv:"in",sts:[{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Comparable"}],nm:"Other"}],an:{see:["Comparison","sort","max","min","largest","smallest"],tagged:["Comparisons"],by:["Gavin"],doc:["The general contract for values whose magnitude can be \ncompared. `Comparable` imposes a total ordering upon\ninstances of any type that satisfies the interface.\n\nIf a type `T` satisfies `Comparable<T>`, then instances \nof `T` may be compared using the comparison operators\n`<`, `>`, `<=`, `>=`.\n\n    assert (x>=0.0);\n\nA _ternary comparison_ is useful for asserting lower and \nupper bounds.\n\n    assert (0.0<=x<1.0);\n\nFinally, the _compare_ operator `<=>` may be used to \nproduce an instance of [[Comparison]].\n\n    switch (x<=>y)\n    case (equal) {\n        print(\"same same\");\n    }\n    case (smaller) {\n        print(\"x smaller\");\n    }\n    case (larger) {\n        print(\"y smaller\");\n    }\n\nThe total order of a type must be consistent with the \ndefinition of equality for the type. That is, there are \nthree mutually exclusive possibilities:\n\n- `x<y`,\n- `x>y`, or\n- `x==y`\n\n(These possibilities are expressed by the enumerated\ninstances [[smaller]], [[larger]], and [[equal]] of\n`Comparison`.)\n\nThe order imposed by `Comparable` is sometimes called the\n_natural order_ of a type, to reflect the fact that any\nfunction of type `Comparison(T,T)` might determine a \ndifferent order. Thus, some order-related operations come \nin two flavors: a flavor that depends upon the natural \norder, and a flavor which accepts an arbitrary comparator \nfunction. Examples are:\n\n- [[sort]] vs [[Iterable.sort]] and\n- [[max]] vs [[Iterable.max]]."]},nm:"Comparable"},emptyIterator:{super:{pk:".",nm:"Basic"},pa:1,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"}],nm:"Iterator"}],mt:"o",$at:{string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"}},$m:{next:{$t:{pk:".",nm:"Finished"},pa:3,mt:"m",nm:"next"}},an:{tagged:["Streams"],doc:["An iterator that returns no elements."]},nm:"emptyIterator"},Anything:{pa:257,mt:"c",of:[{pk:".",nm:"Object"},{pk:".",nm:"Null"}],an:{tagged:["Basic types"],by:["Gavin"],doc:["The abstract supertype of all types. A value of type \n`Anything` may be a definite value of type [[Object]], or \nit may be the [[null]] value. A method declared `void` is \nconsidered to have the return type `Anything`.\n\nNote that the bottom type `Nothing`, representing the \nintersection of all types, is a subtype of all types."]},nm:"Anything"},DefaultAnnotation:{super:{pk:".",nm:"Basic"},pa:561,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"DefaultAnnotation"},{comp:"u",mt:"tp",l:[{pk:"ceylon.language.meta.declaration",nm:"FunctionDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ValueDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ClassOrInterfaceDeclaration"}]},{mt:"tp",pk:".",nm:"Anything"}],nm:"OptionalAnnotation"}],mt:"c",an:{doc:["The annotation class for the [[default]] annotation."]},nm:"DefaultAnnotation"},forKey:{$t:{nm:"Result"},pa:1,ps:[[{$t:{nm:"Result"},ps:[[{$t:{nm:"Key"},mt:"prm",nm:"key"}]],mt:"prm",$pt:"f",nm:"resulting"}],[{$t:{pk:".",tp:[{mt:"tp",nm:"Key"},{mt:"tp",pk:".",nm:"Anything"}],nm:"Entry"},mt:"prm",nm:"entry"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Key"},{nm:"Result"}],an:{see:["forItem"],tagged:["Functions"],doc:["A function that returns the result of applying the given \n[[function|resulting]] to the [[key|Entry.key]] of\na given [[Entry]], discarding its `item`.\n    \n    Map<String,List<Item>> map = ... ;\n    {String*} uppercaseKeys = map.map(forKey(String.uppercased));"]},nm:"forKey"},language:{super:{pk:".",nm:"Basic"},pa:65,mt:"o",$at:{majorVersionBinary:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{doc:["The major version of the code generated for the \nunderlying runtime."]},nm:"majorVersionBinary"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},releaseVersion:{$t:{pk:".",nm:"Integer"},pa:1,mt:"g",an:{doc:["The Ceylon language release version."]},nm:"releaseVersion"},majorVersion:{$t:{pk:".",nm:"Integer"},pa:1,mt:"g",an:{doc:["The Ceylon language major version."]},nm:"majorVersion"},minorVersion:{$t:{pk:".",nm:"Integer"},pa:1,mt:"g",an:{doc:["The Ceylon language minor version."]},nm:"minorVersion"},versionName:{$t:{pk:".",nm:"String"},pa:1,mt:"g",an:{doc:["The Ceylon language release name."]},nm:"versionName"},version:{$t:{pk:".",nm:"String"},pa:1,mt:"g",an:{doc:["The Ceylon language version."]},nm:"version"},minorVersionBinary:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{doc:["The minor version of the code generated for the \nunderlying runtime."]},nm:"minorVersionBinary"}},an:{see:["process","runtime","system","operatingSystem"],tagged:["Environment"],doc:["Contains information about the Ceylon language version."]},nm:"language"},byDecreasing:{$t:{pk:".",nm:"Comparison"},pa:1,ps:[[{$t:{nm:"Value"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"e"}]],mt:"prm",$pt:"f",nm:"comparable"}],[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],mt:"m",tp:[{nm:"Element"},{sts:[{pk:".",tp:[{mt:"tp",nm:"Value"}],nm:"Comparable"}],nm:"Value"}],an:{see:["byIncreasing","decreasing","Iterable.max","Iterable.sort"],tagged:["Functions","Comparisons"],doc:["Produces a comparator function which orders elements in \ndecreasing order according to the [[Comparable]] value \nreturned by the given [[comparable]] function.\n\n     \"Hello World!\".sort(byDecreasing(Character.lowercased))\n\nThis function is intended for use with [[Iterable.sort]]\nand [[Iterable.max]]."]},nm:"byDecreasing"},empty:{super:{pk:".",nm:"Object"},pa:1,sts:[{pk:".",nm:"Empty"}],mt:"o",an:{tagged:["Sequences"],by:["Tako Schotanus"],doc:["A sequence with no elements, abbreviated `[]`. The unique \ninstance of the type `[]`."]},nm:"empty"},maxRadix:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"maxRadix"},late:{$t:{pk:".",nm:"LateAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to disable definite initialization analysis for \na reference."]},nm:"late"},Summable:{st:"Other",pa:1,mt:"i",of:[{nm:"Other"}],$m:{plus:{$t:{nm:"Other"},pa:5,ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["The result of adding the given value to this value. \nThis operation should never perform any kind of \nmutation upon either the receiving value or the \nargument value."]},nm:"plus"}},tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Summable"}],nm:"Other"}],an:{see:["String","Numeric"],tagged:["Numbers","Strings"],by:["Gavin"],doc:["Abstraction of types which support a binary addition\noperator `x + y`. For [[numeric types|Numeric]], this is\njust familiar numeric addition. For [[String]], it is\nstring concatenation.\n\n    Integer next = current + 1;\n    String helloWorld = \"hello\" + \" \" + \"world\";\n\nA concrete class that implements this interface should be \na mathematical _semigroup_. That is, the addition \noperation should be associative, satisfying:\n\n- `(x+y)+z == x+(y+z)`\n\nA `Summable` type might be a _monoid_, that is, a \nsemigroup with an additive identity element, usually \ndenoted `0`, but this is not required. For example:\n\n- `String` is a monoid with identity element `\"\"`, \n- `Float` is a monoid with identity element `0.0`, and \n- `Integer` is a monoid with identity element `0`.\n\nFor any monoid, the addition operation must satisfy:\n\n- `x + 0 == x`"]},nm:"Summable"},loop:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Iterable"},pa:1,ps:[[{$t:{nm:"Element"},mt:"prm",an:{doc:["The first element of the resulting stream."]},nm:"first"}],[{$t:{comp:"u",l:[{nm:"Element"},{pk:".",nm:"Finished"}]},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The function that produces the next element of the\nstream, given the current element. The function may\nreturn [[finished]] to indicate the end of the \nstream."]},nm:"next"}]],mt:"m",tp:[{nm:"Element"}],an:{tagged:["Streams"],doc:["Produces the [[stream|Iterable]] that results from repeated\napplication of the given [[function|next]] to the given\n[[first]] element of the stream, until the function first\nreturns [[finished]]. If the given function never returns \n`finished`, the resulting stream is infinite.\n\nFor example:\n\n    loop(0)(2.plus).takeWhile(10.largerThan)\n\nproduces the stream `{ 0, 2, 4, 6, 8 }`."]},nm:"loop"},Usable:{pa:1,mt:"i",of:[{pk:".",nm:"Destroyable"},{pk:".",nm:"Obtainable"}],an:{tagged:["Basic types"],doc:["Abstract supertype of resources whose lifecyle may be\nmanaged by the `try` statement."]},nm:"Usable"},List:{pa:1,sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Collection"},{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",nm:"Element"}],nm:"Correspondence"},{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",nm:"Element"},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"}],nm:"Ranged"}],mt:"i",$at:{rest:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:11,mt:"g",an:{doc:["The rest of the list, without the first element.\n\nThis is a lazy operation returning a view of this list."]},nm:"rest"},last:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:11,mt:"g",an:{doc:["The last element of this `List`, if any."]},nm:"last"},size:{$t:{pk:".",nm:"Integer"},pa:11,mt:"g",an:{see:["List.lastIndex"],doc:["The number of elements in this list, always\n`1 + (lastIndex else -1)`."]},nm:"size"},keys:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"}],nm:"List"},pa:11,mt:"g",an:{see:["indexes"],doc:["A list containing all indexes of this list.\n\nThis is a lazy operation returning a view of this list."]},nm:"keys"},lastIndex:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:5,mt:"a",an:{see:["List.size"],doc:["The index of the last element of the list, or `null` if \nthe list is empty. Always `size>0 then size-1`."]},nm:"lastIndex"},first:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:11,mt:"g",an:{doc:["The first element of this `List`, if any."]},nm:"first"},reversed:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:9,mt:"g",an:{doc:["A list containing the elements of this list in reverse \norder to the order in which they occur in this list. \nFor every `index` of a reversed `list`:\n\n    list.reversed[index]==list[size-1-index]\n\nThis is a lazy operation returning a view of this list."]},nm:"reversed"},hash:{$t:{pk:".",nm:"Integer"},pa:11,mt:"g",nm:"hash"}},$m:{spanFrom:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:11,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],mt:"m",nm:"spanFrom"},trimLeading:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:9,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"elem"}]],mt:"prm",$pt:"f",an:{doc:["The predicate function that the trimmed \nelements satisfy."]},nm:"trimming"}]],mt:"m",$m:{trimming$yvqbbg:{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"elem"}]],mt:"m",an:{doc:["The predicate function that the trimmed \nelements satisfy."]},nm:"trimming"}},an:{doc:["Trim the elements satisfying the given [[predicate \nfunction|trimming]], along with any null elements, from\nthe start of this list, returning a list no longer than \nthis list.\n\nThis is an eager operation."]},nm:"trimLeading"},sublistFrom:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:9,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],mt:"m",an:{see:["skip"],doc:["A sublist of this list, starting at the element with\nthe given [[index|from]].\n\nThis is a lazy operation, returning a view of this list."]},nm:"sublistFrom"},firstIndexWhere:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:9,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The predicate function the indexed elements \nmust satisfy"]},nm:"selecting"}]],mt:"m",$m:{selecting$xlulik:{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"m",an:{doc:["The predicate function the indexed elements \nmust satisfy"]},nm:"selecting"}},an:{see:["locate"],doc:["The first index in this list for which the element is\nnot null and satisfies the given \n[[predicate function|selecting]]."]},nm:"firstIndexWhere"},defines:{$t:{pk:".",nm:"Boolean"},pa:11,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",an:{doc:["Determines if the given index refers to an element of \nthis list, that is, if `0<=index<=list.lastIndex`."]},nm:"defines"},patch:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],nm:"List"},pa:9,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"List"},mt:"prm",an:{doc:["The list of new elements."]},nm:"list"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The index at which the elements will occur, and\nthe start index of the segment to replace."]},nm:"from"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The length of the segment to replace."]},nm:"length"}]],mt:"m",tp:[{nm:"Other"}],an:{doc:["Return a list formed by patching the given [[list]] \nin place of a segment of this list identified by the\ngiven [[starting index|from]] and [[length]].\n\nThis is a lazy operations, returning a view over this \nlist and the given list.\n\nFour special cases are interesting:\n\n- If `length==0`, the patched list has the given values \n  \"inserted\" into this list at the given index `from`.\n- If the given `list` is empty, the patched list has \n  the measure of this list identified by `from:length` \n  \"deleted\".\n- If `from==size`, the patched list is formed by\n  appending the given list.\n- If `from==0`, the patched list is formed by \n  prepending the given list.\n\nFor example:\n\n- `(-2..2).patch([],1,3)` produces the list `{-2,2}`, \n  and\n- `[-2, 2].patch(-1..1,1)` produces the list \n  `{-2,-1,0,1,2}`.'\n- `0:3`.patch(2..0) produces the list `{0,1,2,2,1,0}`.\n\nIf `length<0`, or if `from` is outside the range \n`0..size`, return this list."]},nm:"patch"},iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:11,mt:"m",$at:{string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},size$nv92nu:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"size"},index$dvr23n:{$t:{pk:".",nm:"Integer"},pa:1024,mt:"a",nm:"index"}},$m:{next:{$t:{comp:"u",l:[{nm:"Element"},{pk:".",nm:"Finished"}]},pa:3,mt:"m",nm:"next"}},nm:"iterator",$c:{anon$0$cdpswa:{super:{pk:".",nm:"Basic"},sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"}],mt:"c",$anon:1,nm:"anon$0$cdpswa"}}},trim:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:9,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"elem"}]],mt:"prm",$pt:"f",an:{doc:["The predicate function that the trimmed \nelements satisfy."]},nm:"trimming"}]],mt:"m",$m:{trimming$68e1qa:{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"elem"}]],mt:"m",an:{doc:["The predicate function that the trimmed \nelements satisfy."]},nm:"trimming"}},an:{doc:["Trim the elements satisfying the given [[predicate \nfunction|trimming]], along with any null elements, from \nthe start and end of this list, returning a list no \nlonger than this list.\n\nThis is an eager operation."]},nm:"trim"},slice:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},{comp:"u",l:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},{pk:".",nm:"Nothing"}]},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"}],nm:"Tuple"},pa:9,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",an:{doc:["Return two lists, the first containing the elements\nthat occur before the given [[index]], the second with\nthe elements that occur after the given `index`. If the\ngiven `index` is outside the range of indices of this\nlist, one of the returned lists will be empty.\n\nFor any `list`, and for any integer `index`:\n\n    list.slice(index) == [list[...index-1], list[index...]]\n\nThis is an eager operation."]},nm:"slice"},find:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:11,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"elem"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",$m:{selecting$98r208:{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"elem"}]],mt:"m",nm:"selecting"}},nm:"find"},get:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",an:{doc:["Returns the element of this list with the given \n[[index]] if the index refers to an element of this\nlist, that is, if `0<=index<=list.lastIndex`, or `null` \notherwise. The first element of the list has index `0`,\nand the last element has index [[lastIndex]]."]},nm:"get"},repeat:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:11,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"times"}]],mt:"m",an:{doc:["A list containing the elements of this list repeated \nthe [[given number of times|times]], or an empty list\nif `times<=0`. For every `index` of a repeated `list`:\n\n    list.repeat(n)[index]==list[index%n]\n\nThis is a lazy operation returning a view of this list."]},nm:"repeat"},getElement$v2oaho:{$t:{nm:"Element"},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"getElement"},trimTrailing:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:9,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"elem"}]],mt:"prm",$pt:"f",an:{doc:["The predicate function that the trimmed \nelements satisfy."]},nm:"trimming"}]],mt:"m",$m:{trimming$uacsrm:{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"elem"}]],mt:"m",an:{doc:["The predicate function that the trimmed \nelements satisfy."]},nm:"trimming"}},an:{doc:["Trim the elements satisfying the given [[predicate \nfunction|trimming]], along with any null elements, from \nthe end of this list, returning a list no longer than \nthis list.\n\nThis is an eager operation."]},nm:"trimTrailing"},lastIndexWhere:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:9,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The predicate function the indexed elements \nmust satisfy."]},nm:"selecting"}]],mt:"m",$m:{selecting$j3xxzq:{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"m",an:{doc:["The predicate function the indexed elements \nmust satisfy."]},nm:"selecting"}},an:{see:["locateLast"],doc:["The last index in this list for which the element is\nnot null and satisfies the given \n[[predicate function|selecting]]."]},nm:"lastIndexWhere"},initial:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:9,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",an:{see:["terminal","sublistTo","take"],doc:["Select the first elements of this list, returning a \nlist no longer than the given length. If this list is \nshorter than the given length, return this list. \nOtherwise return a list of the given length.\n\nFor any `list`, and for any integer `length`:\n\n    list.initial(length) == list[...length-1] == list[0:length]\n\nThis is an eager operation."]},nm:"initial"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:7,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",an:{see:["getFromLast"],doc:["Returns the element of this list with the given \n[[index]] if the index refers to an element of this\nlist, that is, if `0<=index<=list.lastIndex`, or `null` \notherwise. The first element of the list has index `0`, \nand the last element has index [[lastIndex]]."]},nm:"getFromFirst"},sublistTo:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:9,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",an:{see:["take","initial"],doc:["A sublist of this list, ending at the element with the \ngiven [[index|to]].\n\nThis is a lazy operation, returning a view of this list."]},nm:"sublistTo"},indexesWhere:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:9,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The predicate function the indexed elements \nmust satisfy"]},nm:"selecting"}]],mt:"m",an:{see:["locations"],doc:["The indexes in this list for which the element is not\nnull and satisfies the given \n[[predicate function|selecting]]."]},nm:"indexesWhere"},terminal:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:9,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",an:{see:["initial"],doc:["Select the last elements of the list, returning a list \nno longer than the given length. If this list is \nshorter than the given length, return this list. \nOtherwise return a list of the given length.\n\nFor any `list`, and for any integer `length`:\n\n    list.terminal(length) == list[size-length...]\n\nThis is an eager operation."]},nm:"terminal"},findLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:11,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"elem"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",$m:{selecting$h1tj66:{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"elem"}]],mt:"m",nm:"selecting"}},nm:"findLast"},getFromLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:9,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",an:{doc:["Returns the element of this list with the given \n[[index]], where the list is indexed from the _end_ of \nthe list instead of from the start, if the index refers\nto an element of this list, or `null` otherwise. The\nlast element of the list has index `0`, and the first\nelement has index [[lastIndex]]."]},nm:"getFromLast"},spanTo:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:11,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"spanTo"},contains:{$t:{pk:".",nm:"Boolean"},pa:11,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],mt:"m",an:{doc:["Determines if this list contains the given value.\nReturns `true` for every element of this list."]},nm:"contains"},measure:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:11,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",nm:"measure"},shorterThan:{$t:{pk:".",nm:"Boolean"},pa:11,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",nm:"shorterThan"},sublist:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:9,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",an:{doc:["A sublist of this list, starting at the element with\nindex [[from]], ending at the element with the index \n[[to]].\n\nThis is a lazy operation, returning a view of this list."]},nm:"sublist"},equals:{$t:{pk:".",nm:"Boolean"},pa:11,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],mt:"m",an:{doc:["Two `List`s are considered equal iff they have the \nsame `size` and _entry sets_. The entry set of a list \n`list` is the set of elements of `list.indexed`. This \ndefinition is equivalent to the more intuitive notion \nthat two lists are equal iff they have the same `size` \nand for every index either:\n\n- the lists both have the element `null`, or\n- the lists both have a non-null element, and the\n  two elements are equal.\n\nAs a special exception, a [[String]] is not equal to \nany list which is not also a [[String]]."]},nm:"equals"},clone:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:11,mt:"m",an:{doc:["A shallow copy of this list, that is, a list with the\nsame elements as this list, which do not change if the\nelements of this list change."]},nm:"clone"},longerThan:{$t:{pk:".",nm:"Boolean"},pa:11,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",nm:"longerThan"},endsWith:{$t:{pk:".",nm:"Boolean"},pa:9,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Anything"}],nm:"List"},mt:"prm",nm:"sublist"}]],mt:"m",an:{see:["startsWith"],doc:["Determine if the given [[list|sublist]] occurs at the \nend of this list."]},nm:"endsWith"},collect:{$t:{pk:".",tp:[{mt:"tp",nm:"Result"}],nm:"Sequential"},pa:11,ps:[[{$t:{nm:"Result"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The transformation applied to the elements."]},nm:"collecting"}]],mt:"m",$m:{collecting$rpkv6r:{$t:{nm:"Result"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"m",an:{doc:["The transformation applied to the elements."]},nm:"collecting"}},$o:{list$98kifc:{super:{pk:".",nm:"Object"},sts:[{pk:".",tp:[{mt:"tp",nm:"Result"}],nm:"List"}],mt:"o",$at:{size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"a",nm:"size"},lastIndex:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:3,mt:"g",nm:"lastIndex"}},$m:{getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Result"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"getFromFirst"}},nm:"list"}},tp:[{nm:"Result"}],an:{doc:["A sequence containing the results of applying the given \nmapping to the elements of this list."]},nm:"collect"},startsWith:{$t:{pk:".",nm:"Boolean"},pa:9,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Anything"}],nm:"List"},mt:"prm",nm:"sublist"}]],mt:"m",an:{see:["endsWith"],doc:["Determine if the given [[list|sublist]] occurs at the \nstart of this list."]},nm:"startsWith"},span:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:11,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"span"}},tp:[{dv:"out",def:{pk:".",nm:"Anything"},nm:"Element"}],an:{see:["Sequence","Empty","Array"],tagged:["Collections"],doc:["A collection in which every element has a unique \nnon-negative integer index. The elements of a nonempty \nlist are indexed starting with `0` at the [[first]] \nelement of the list, and ending with the index \n[[lastIndex]] at the [[last]] element of the list.\n\n- For any nonempty list, `lastIndex==size-1`. \n- For an empty list, `size==0` and the `lastIndex` is \n  `null`.\n\nThus, the range of indexes of the list is formed by the \nexpression `0:list.size`.\n\nA `List` is a [[Collection]] of its elements, and a \n[[Correspondence]] from indices to elements.\n\nEvery list has a well-defined and stable iteration order.\nAn [[iterator]] of a nonempty list is required to return \nthe elements of the list in order of increasing index, \nbeginning with the element at index `0`, and ending with\nthe element at index `lastIndex`. Thus, every iterator of \nan immutable list produces exactly the same elements in \nexactly the same order.\n\nDirect access to a list element by index produces a value \nof optional type. The following idiom may be used instead \nof upfront bounds-checking, as long as the list element \ntype is a non-`null` type:\n\n    if (exists char = \"hello world\"[index]) { \n        \/\/do something with char\n    }\n    else {\n        \/\/out of bounds\n    }\n\nWhen an algorithm guarantees that a list contains a given \nindex, the following idiom may be used:\n\n    assert (exists char = \"hello world\"[index]);\n    \/\/do something with char\n\nTo iterate the indices of a `List`, use the following\nidiom:\n\n    for (i->char in \"hello world\".indexed) { ... }\n\n[[Strings|String]], [[sequences|Sequential]], \n[[tuples|Tuple]], and [[arrays|Array]] are all `List`s,\nand are all of fixed length. Variable-length mutable\n`List`s are also possible."]},nm:"List",$c:{Sublist$elvxw4:{super:{pk:".",nm:"Object"},sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"}],ps:[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}],mt:"c",$at:{to$1d4wke:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"to"},lastIndex:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:3,mt:"g",nm:"lastIndex"}},$m:{spanTo:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"spanTo"},spanFrom:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],mt:"m",nm:"spanFrom"},iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},measure:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",nm:"measure"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"getFromFirst"},clone:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:3,mt:"m",nm:"clone"},sublistTo:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"sublistTo"},span:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"span"}},nm:"Sublist$elvxw4"},Rest$fyp886:{super:{pk:".",nm:"Object"},sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"}],ps:[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}],mt:"c",$at:{from$8r4afz:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"from"},lastIndex:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:3,mt:"g",nm:"lastIndex"}},$m:{spanTo:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"spanTo"},spanFrom:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],mt:"m",nm:"spanFrom"},iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},measure:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",nm:"measure"},sublistFrom:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],mt:"m",nm:"sublistFrom"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"getFromFirst"},clone:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:3,mt:"m",nm:"clone"},span:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"span"}},nm:"Rest$fyp886"},Indexes$1g59zu:{super:{pk:".",nm:"Object"},sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"}],nm:"List"}],mt:"c",$at:{string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},lastIndex:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:3,mt:"g",nm:"lastIndex"}},$m:{spanTo:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"}],nm:"List"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"spanTo"},spanFrom:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"}],nm:"List"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],mt:"m",nm:"spanFrom"},iterator:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},measure:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"}],nm:"List"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",nm:"measure"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"getFromFirst"},clone:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"}],nm:"List"},pa:3,mt:"m",nm:"clone"},span:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"}],nm:"List"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"span"}},nm:"Indexes$1g59zu"},Patch$xht1ke:{super:{pk:".",nm:"Object"},sts:[{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],nm:"List"}],ps:[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"List"},mt:"prm",nm:"list"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}],mt:"c",$at:{length$x539u7:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"length"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"},list$cbomfb:{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"List"},mt:"a",nm:"list"},from$8gxpyr:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"from"},lastIndex:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:3,mt:"g",nm:"lastIndex"}},$m:{iterator:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"},{nm:"Other"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"getFromFirst"},clone:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],nm:"List"},pa:3,mt:"m",nm:"clone"}},tp:[{nm:"Other"}],nm:"Patch$xht1ke"},Repeat$59m2x5:{super:{pk:".",nm:"Object"},sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"}],ps:[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"times"}],mt:"c",$at:{times$219c9m:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"times"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},lastIndex:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:3,mt:"g",nm:"lastIndex"}},$m:{iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"getFromFirst"},clone:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:3,mt:"m",nm:"clone"}},nm:"Repeat$59m2x5"},Reversed$ijs9g8:{super:{pk:".",nm:"Object"},sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"}],mt:"c",$at:{size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"},last:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,mt:"g",nm:"last"},lastIndex:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:3,mt:"g",nm:"lastIndex"},first:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,mt:"g",nm:"first"},reversed:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:3,mt:"g",nm:"reversed"}},$m:{spanTo:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"spanTo"},spanFrom:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],mt:"m",nm:"spanFrom"},iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},measure:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",nm:"measure"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"getFromFirst"},clone:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:3,mt:"m",nm:"clone"},span:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"span"}},nm:"Reversed$ijs9g8"}}},parseInteger:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:1,ps:[[{$t:{pk:".",nm:"String"},mt:"prm",an:{doc:["The string representation to parse."]},nm:"string"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The base, between [[minRadix]] and [[maxRadix]] \ninclusive."]},nm:"radix"}]],mt:"m",an:{see:["formatInteger","parseFloat"],tagged:["Numbers","Basic types"],doc:["The [[Integer]] value of the given \n[[string representation|string]] of an integer value in the \nbase given by [[radix]], or `null` if the string does not \nrepresent an integer in that base, or if the mathematical \ninteger it represents is too large in magnitude to be \nrepresented by an instance of the class `Integer`.\n\nThe syntax accepted by this function is the same as the \nsyntax for an `Integer` literal in the Ceylon language \nexcept that it may optionally begin with a sign character \n(`+` or `-`) and may not contain grouping underscore \ncharacters.\n\nThe given `radix` specifies the base of the string \nrepresentation. The list of available digits starts from \n`0` to `9`, followed by `a` to `z`. When parsing in a \nspecific base, the first `radix` digits from the available \ndigits list is used. This function is not case sensitive; \n`a` and `A` both correspond to the digit `a` whose decimal \nvalue is `10`."],throws:["AssertionError","if [[radix]] is not between [[minRadix]] and \n[[maxRadix]]"]},nm:"parseInteger"},actual:{$t:{pk:".",nm:"ActualAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to mark a member of a type as refining a member \nof a supertype."]},nm:"actual"},sealed:{$t:{pk:".",nm:"SealedAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to mark an interface, class, or constructor as \nsealed. A `sealed` interface may not be satisfied outside \nof the module in which it is defined. A `sealed` class may \nnot be extended or instantiated outside of the module in \nwhich it is defined. A `sealed` constructor may not be\ninvoked outside of the module in which it is defined."]},nm:"sealed"},count:{$t:{pk:".",nm:"Integer"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Boolean"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"values"}]],mt:"m",an:{see:["Iterable.count"],tagged:["Streams"],doc:["A count of the number of `true` items in the given values.\n\n    Integer negatives = count { for (x in xs) x<0.0 };"]},nm:"count"},zeroInt:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"zeroInt"},measure:{$t:{comp:"u",l:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Range"},{pk:".",nm:"Empty"}]},pa:1,ps:[[{$t:{nm:"Element"},mt:"prm",nm:"first"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"size"}]],mt:"m",tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Enumerable"}],nm:"Element"}],an:{doc:["Produces a [[Range]] of adjacent [[Enumerable]] values \ngenerated by a [[first]] element, and a strictly positive \n[[size]], or returns the [[empty sequence|empty]] if \n`size <= 0`. The range includes all values whose offset \nfrom `first` is non-negative and less than the `size`.\n\nMore precisely, if `x` and `first` are of `Enumerable` \ntype `X`, and `size` is an integer, then `x in first:size` \nif and only if `0 <= x.offset(first) < size`.\n\nThe _measure operator_ `:` is an abbreviation for\n`measure()`:\n\n    for (i in start:size) { ... }\n    for (char in '0':10) { ... }\n\nThe measure operator accepts the first index and size of \nthe range:\n\n    0:5     \/\/ [0, 1, 2, 3, 4]\n\nIf the size is nonpositive, the range is empty:\n\n    0:0     \/\/ []\n    5:0     \/\/ []\n    0:-5    \/\/ []"]},nm:"measure"},final:{$t:{pk:".",nm:"FinalAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to mark a class as final. A `final` class may \nnot be extended. Marking a class as `final` affects disjoint\ntype analysis."]},nm:"final"},SequencedAnnotation:{st:"Value",pa:1,sts:[{pk:".",tp:[{mt:"tp",nm:"Value"},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Value"}],nm:"Sequential"},{mt:"tp",nm:"ProgramElement"},{mt:"tp",nm:"Type"}],nm:"ConstrainedAnnotation"}],mt:"i",of:[{nm:"Value"}],tp:[{dv:"out",sts:[{pk:".",tp:[{mt:"tp",nm:"Value"},{mt:"tp",nm:"ProgramElement"},{mt:"tp",nm:"Type"}],nm:"SequencedAnnotation"}],nm:"Value"},{dv:"in",sts:[{pk:".",nm:"Annotated"}],def:{pk:".",nm:"Annotated"},nm:"ProgramElement"},{dv:"out",def:{pk:".",nm:"Anything"},nm:"Type"}],an:{see:["Annotation"],doc:["An annotation that may occur multiple times at a given \nprogram element, and only on certain program elemenets.\n\nA sequenced annotation is declared simply by having the \nannotation class satisfy `SequencedAnnotation` instead of \n[[Annotation]]. For example the following would only be \nallowed on `class` declarations, functions or methods:\n\n    alias ExecutableDeclaration \n           => ClassOrInterfaceDeclaration|FunctionDeclaration;\n    \"Documents a pattern in which the annotated element \n     particpates.\"\n    shared final annotation class Pattern(String name) \n            satisfies SequencedAnnotation<Pattern, ExecutableDeclaration> {}\n\nAt runtime a [[ceylon.language.meta.declaration::Declaration]] \ninstance can be queried for its `SequencedAnnotation`s of \na certain type using [[ceylon.language.meta::annotations]] \nor [[ceylon.language.meta::sequencedAnnotations]]."]},nm:"SequencedAnnotation"},Binary:{st:"Other",pa:1,mt:"i",of:[{nm:"Other"}],$at:{not:{$t:{nm:"Other"},pa:5,mt:"a",an:{doc:["The binary complement of this sequence of bits."]},nm:"not"}},$m:{rightArithmeticShift:{$t:{nm:"Other"},pa:5,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"shift"}]],mt:"m",an:{doc:["Shift the sequence of bits to the right, by the \ngiven [[number of places|shift]], preserving the values\nof the most significant bits.\n\nIf the sequence of bits represents a signed integer, \nthe sign is preserved."]},nm:"rightArithmeticShift"},or:{$t:{nm:"Other"},pa:5,ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Performs a logical inclusive OR operation."]},nm:"or"},set:{$t:{nm:"Other"},pa:5,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"},{$t:{pk:".",nm:"Boolean"},def:1,mt:"prm",nm:"bit"}]],mt:"m",an:{doc:["Returns an instance with the given bit set to the given \nvalue if `0 <= index < size`, otherwise returns a value \nwith the same bits as this value."]},nm:"set"},and:{$t:{nm:"Other"},pa:5,ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Performs a logical AND operation."]},nm:"and"},get:{$t:{pk:".",nm:"Boolean"},pa:5,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",an:{doc:["Retrieves a given bit from this bit sequence if \n`0 <= index < size`, otherwise returns false."]},nm:"get"},clear:{$t:{nm:"Other"},pa:9,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",an:{doc:["Returns an instance with the given bit set to 0 if \n`0 <= index < size`, otherwise returns a value with the \nsame bits as this value."]},nm:"clear"},rightLogicalShift:{$t:{nm:"Other"},pa:5,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"shift"}]],mt:"m",an:{doc:["Shift the sequence of bits to the right, by the \ngiven [[number of places|shift]], filling the most\nsignificant bits with zeroes.\n\nIf the sequence of bits represents a signed integer, \nthe sign is not preserved."]},nm:"rightLogicalShift"},xor:{$t:{nm:"Other"},pa:5,ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Performs a logical exclusive OR operation."]},nm:"xor"},leftLogicalShift:{$t:{nm:"Other"},pa:5,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"shift"}]],mt:"m",an:{doc:["Shift the sequence of bits to the left, by the \ngiven [[number of places|shift]], filling the least\nsignificant bits with zeroes."]},nm:"leftLogicalShift"},flip:{$t:{nm:"Other"},pa:5,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",an:{doc:["Returns an instance with the given bit flipped to its \nopposite value if `0 <= index < size`, otherwise \nreturns a value with the same bits as this value."]},nm:"flip"}},tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Binary"}],nm:"Other"}],an:{see:["Integer"],by:["Stef"],doc:["Abstraction of types that are conceptually a sequence of \nbits, and may be the subject of bitwise operations. A bit \nis a [[Boolean]] value. Bits are indexed from right to \nleft, where `0` is the index of the least significant bit."]},nm:"Binary"},nullElement:{super:{pk:".",nm:"Basic"},mt:"o",an:{doc:["Used by [[Collection.permutations]] to group nulls together."]},nm:"nullElement"},OptionalImportAnnotation:{super:{pk:".",nm:"Basic"},pa:561,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"OptionalImportAnnotation"},{mt:"tp",pk:"ceylon.language.meta.declaration",nm:"Import"},{mt:"tp",pk:".",nm:"Anything"}],nm:"OptionalAnnotation"}],mt:"c",an:{doc:["The annotation class for the [[optional]] annotation."]},nm:"OptionalImportAnnotation"},Iterable:{pa:1,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"Object"}],nm:"Category"}],mt:"i",$at:{rest:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:9,mt:"g",an:{see:["first"],doc:["A stream containing all but the first element of this \nstream. For a stream with an unstable iteration order, \na different stream might be produced each time `rest` \nis evaluated.\n\nTherefore, if the stream `i` has an unstable iteration\norder, the stream `{ i.first, *i.rest }` might not have\nthe same elements as `i`."]},nm:"rest"},exceptLast:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:9,mt:"g",$m:{iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"}},an:{doc:["A stream containing all but the last element of this \nstream. For a stream with an unstable iteration order, \na different stream might be produced each time \n`exceptLast` is evaluated."]},nm:"exceptLast",$c:{anon$2$2swqvg:{super:{pk:".",nm:"Basic"},sts:[{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"}],mt:"c",$anon:1,nm:"anon$2$2swqvg"}}},size:{$t:{pk:".",nm:"Integer"},pa:9,mt:"g",an:{doc:["The number of elements returned by the [[iterator]] of \nthis stream, if the iterator terminates. In the case of \nan infinite stream, this operation never terminates."]},nm:"size"},last:{$t:{comp:"u",l:[{nm:"Absent"},{nm:"Element"}]},pa:9,mt:"g",an:{doc:["The last element returned by the iterator, if any, or \n`null` if this stream is empty. In the case of an \ninfinite stream, this operation never terminates;\nfurthermore, this default implementation iterates all \nelements, which might be very expensive."]},nm:"last"},string:{$t:{pk:".",nm:"String"},pa:11,mt:"g",an:{doc:["A string of form `\"{ x, y, z }\"` where `x`, `y`, and \n`z` are the `string` representations of the elements of \nthis collection, as produced by the iterator of the \nstream, or the string `\"{}\"` if this stream is empty. \nIf the stream is very long, the list of elements might \nbe truncated, as indicated by an ellipse."]},nm:"string"},indexed:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",nm:"Element"}],nm:"Entry"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},pa:9,mt:"g",$m:{iterator:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",nm:"Element"}],nm:"Entry"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"}},an:{see:["locations"],doc:["A stream containing all [[entries|Entry]] of form\n`index->element` where `element` is an element of this\nstream, and `index` is the position at which `element`\noccurs in this stream, ordered by increasing `index`.\n\nFor example, the expression\n\n    { \"hello\", null, \"world\" }.indexed\n\nresults in the stream `{ 0->\"hello\", 1->null, 2->\"world\" }`."]},nm:"indexed",$c:{anon$20$e30fmq:{super:{pk:".",nm:"Basic"},sts:[{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",nm:"Element"}],nm:"Entry"},{mt:"tp",nm:"Absent"}],nm:"Iterable"}],mt:"c",$anon:1,nm:"anon$20$e30fmq"}}},cycled:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},pa:9,mt:"g",$at:{orig$u6r96:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},mt:"g",nm:"orig"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"}},$m:{iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"}},an:{see:["repeat"],doc:["An infinite stream that produces the elements of this \nstream, repeatedly.\n\nFor example, the expression\n\n    {6, 9}.cycled.take(5)\n\nevaluates to the stream `{ 6, 9, 6, 9, 6 }`."]},nm:"cycled",$c:{anon$27$mkzgle:{super:{pk:".",nm:"Basic"},sts:[{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"Absent"}],nm:"Iterable"}],mt:"c",$anon:1,nm:"anon$27$mkzgle"}}},distinct:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},pa:9,mt:"g",$m:{iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"}},an:{see:["set"],doc:["A stream that produces every element produced by this\nstream exactly once. Duplicate elements of this stream\nare eliminated. Two elements are considered distinct\nunless they are both [[null|Null]], or unless they are \nboth non-null and [[equal|Object.equals]].\n\nFor example:\n\n    String(\"hello world\".distinct)\n\nis the string `\"helo wrd\"`.\n\nThis is a lazy operation and the resulting stream \nreflects changes to this stream."]},nm:"distinct",$c:{anon$31$oh1nxb:{super:{pk:".",nm:"Basic"},sts:[{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"Absent"}],nm:"Iterable"}],mt:"c",$anon:1,nm:"anon$31$oh1nxb"}}},coalesced:{$t:{pk:".",tp:[{comp:"i",mt:"tp",l:[{nm:"Element"},{pk:".",nm:"Object"}]},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:9,mt:"g",an:{see:["defaultNullElements"],doc:["The non-null elements of this stream, in the order in\nwhich they occur in this stream. For null elements of \nthe original stream, there is no entry in the resulting \nstream.\n\nFor example, the expression\n\n    { \"123\", \"abc\", \"456\"}.map(parseInteger).coalesced\n\nresults in the stream `{ 123, 456 }`."]},nm:"coalesced"},first:{$t:{comp:"u",l:[{nm:"Absent"},{nm:"Element"}]},pa:9,mt:"g",an:{doc:["The first element returned by the iterator, if any, or \n`null` if this stream is empty. For a stream with an\nunstable iteration order, a different value might be\nproduced each time `first` is evaluated."]},nm:"first"},paired:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{comp:"u",l:[{nm:"Element"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"Element"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"}],nm:"Tuple"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:9,mt:"g",$at:{size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"},empty:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"g",nm:"empty"}},$m:{iterator:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{comp:"u",l:[{nm:"Element"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"Element"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"}],nm:"Tuple"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"}},an:{doc:["A stream containing whose elements are pairs (2-tuples)\ncomprising an element of this stream paired with the \nnext element in the stream. The resulting stream has\none fewer elements than this stream.\n\nFor example, the expression\n\n    (1..5).paired\n\nresults in the stream \n`{ [1, 2], [2, 3], [3, 4], [4, 5] }`.\n\nThis expression determines if a stream is monotonically\nincreasing:\n\n    every { for ([x, y] in nums.paired) x < y }\n\nFor any stable `stream`, this operation is equivalent \nto `zipPairs(stream,stream.rest)`."]},nm:"paired",$c:{anon$22$zarsgo:{super:{pk:".",nm:"Basic"},sts:[{pk:".",tp:[{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{comp:"u",l:[{nm:"Element"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"Element"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"}],nm:"Tuple"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"}],mt:"c",$anon:1,nm:"anon$22$zarsgo"}}},empty:{$t:{pk:".",nm:"Boolean"},pa:9,mt:"g",an:{doc:["Determines if the stream is empty, that is to say, if \nthe iterator returns no elements."]},nm:"empty"}},$m:{select:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:9,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The predicate the elements must satisfy."]},nm:"selecting"}]],mt:"m",an:{see:["filter"],doc:["Produce a new [[sequence|Sequential]] containing all \nelements of this stream that satisfy the given \n[[predicate function|selecting]], in the order in \nwhich they occur in this stream.\n\nThis operation is an eager counterpart to [[filter]]. \nFor any stream `it`, and predicate `p`:\n\n    it.select(p) == [*it.filter(p)]"]},nm:"select"},locate:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{comp:"i",mt:"tp",l:[{nm:"Element"},{pk:".",nm:"Object"}]}],nm:"Entry"}]},pa:9,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The predicate the element must satisfy."]},nm:"selecting"}]],mt:"m",$m:{selecting$xxnpkt:{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"m",an:{doc:["The predicate the element must satisfy."]},nm:"selecting"}},an:{see:["locateLast","locations","find","List.firstIndexWhere"],doc:["The first element of this stream which satisfies the \n[[given predicate function|selecting]], if any, \ntogether with its position in the stream, or `null` \nif there is no such element. For an infinite stream, \nthis method might not terminate.\n\nFor example, the expression\n\n    (-10..10).locate(Integer.positive)\n\nevaluates to `11->1`."]},nm:"locate"},tabulate:{$t:{pk:".",tp:[{comp:"i",mt:"tp",l:[{nm:"Element"},{pk:".",nm:"Object"}]},{mt:"tp",nm:"Result"}],nm:"Map"},pa:1,ps:[[{$t:{nm:"Result"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"key"}]],mt:"prm",$pt:"f",an:{doc:["A function that produces an item for the given\n[[key]], an element of this stream."]},nm:"collecting"}]],mt:"m",tp:[{nm:"Result"}],an:{doc:["Produces a [[Map]] mapping elements to items where each \n[[entry|Entry]] maps a distinct non-null element of \nthis stream to the item produced by the given \n[[function|collecting]]. Elements are considered \ndistinct if they are not [[equal|Object.equals]]. Null \nelements of this stream are simply discarded.\n\nThis is an eager operation, and the resulting map does\nnot reflect changes to the given stream."]},nm:"tabulate"},scan:{$t:{pk:".",tp:[{mt:"tp",nm:"Result"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Iterable"},pa:9,ps:[[{$t:{nm:"Result"},mt:"prm",nm:"initial"}],[{$t:{nm:"Result"},ps:[[{$t:{nm:"Result"},mt:"prm",nm:"partial"},{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The accumulating function that accepts\nthe running total and the next element."]},nm:"accumulating"}]],mt:"m",tp:[{nm:"Result"}],an:{see:["fold"],doc:["The stream of intermediate results obtained by \nbeginning with a given [[initial value|initial]] and\niteratively applying the given \n[[combining function|accumulating]] to each element of \nthis stream in turn.\n\nFor an empty stream, `scan()` returns a stream \ncontaining just the given initial value `z`:\n\n    {}.scan(z)(f) == { z }\n\nFor a given nonempty stream `it`, initial value `z`, \nand combining function `f`, the result of `scan()` is \nobtained according to the following recursive \ndefinition:\n\n    it.scan(z)(f).last == f(it.exceptLast.scan(z)(f).last, it.last)\n    it.scan(z)(f).exceptLast == it.exceptLast.scan(z)(f)\n\nThe following identities explain the relationship \nbetween `scan` and [[fold]]:\n\n    it.scan(z)(f).getFromFirst(n) == it.take(n).fold(z)(f)\n    it.scan(z)(f).last == it.fold(z)(f)\n    it.scan(z)(f).first == {}.fold(z)(f) == z\n\nFor example, the expression\n\n    (1..4).scan(0)(plus<Integer>)\n\nresults in the stream `{ 0, 1, 3, 6, 10 }`."]},nm:"scan"},takeWhile:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:9,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The function that returns `false` when the \nresulting stream should stop taking elements\nfrom this stream."]},nm:"taking"}]],mt:"m",an:{see:["take","skipWhile"],doc:["Produces a stream containing the leading elements of \nthis stream until the given [[predicate function|taking]]\nreturns `false`."]},nm:"takeWhile"},skip:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:9,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"skipping"}]],mt:"m",$at:{string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"}},$m:{iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"}},an:{see:["List.sublistFrom","skipWhile","take"],doc:["Produces a stream containing the elements of this \nstream, after skipping the first [[skipping]] elements\nproduced by its iterator.\n\nIf this stream does not contain more elements than the \nspecified number of elements to skip, the resulting \nstream has no elements. If the specified number of \nelements to skip is zero or fewer, the resulting stream \ncontains the same elements as this stream."]},nm:"skip",$c:{anon$9$v2s6a4:{super:{pk:".",nm:"Basic"},sts:[{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"}],mt:"c",$anon:1,nm:"anon$9$v2s6a4"}}},skipWhile:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:9,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The function that returns `false` when the \nresulting stream should stop skipping\nelements from the stream."]},nm:"skipping"}]],mt:"m",an:{see:["skip","takeWhile"],doc:["Produces a stream containing the elements of this \nstream, after skipping the leading elements until the \ngiven [[predicate function|skipping]] returns `false`."]},nm:"skipWhile"},iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:5,mt:"m",an:{doc:["An iterator for the elements belonging to this stream."]},nm:"iterator"},partition:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},pa:9,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",$at:{size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"},empty:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"g",nm:"empty"}},$m:{iterator:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"}},an:{doc:["Produces a stream of sequences of the given [[length]],\ncontaining elements of this stream. Each sequence in \nthe stream contains the next [[length]] elements of \nthis sequence that have not yet been assigned to a \nprevious sequence, in the same order that they occur\nin this stream. The very last sequence in the stream\nmay be shorter than the given `length`.\n\nFor example, the expression\n\n    \"hello\".partition(2)\n\nresults in the stream `{ ['h','e'], ['l','l'], ['o'] }.`\n\nFor any `stream` and for any strictly positive integer \n[[length]]:\n\n    expand { stream.partition(length) } == stream"],throws:["AssertionError","if `length<=0`"]},nm:"partition",$c:{anon$24$79r7vo:{super:{pk:".",nm:"Basic"},sts:[{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"},{mt:"tp",nm:"Absent"}],nm:"Iterable"}],mt:"c",$anon:1,nm:"anon$24$79r7vo"}}},indexes:{$t:{comp:"u",l:[{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"}],nm:"Range"},{pk:".",nm:"Empty"}]},pa:9,mt:"m",an:{doc:["A [[Range]] containing all indexes of this stream, or \n`[]` if this list is empty. The resulting range is\nequal to `0:size`."]},nm:"indexes"},find:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:9,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The predicate the element must satisfy."]},nm:"selecting"}]],mt:"m",$m:{selecting$7invh8:{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"m",an:{doc:["The predicate the element must satisfy."]},nm:"selecting"}},an:{see:["findLast","locate"],doc:["The first element of this stream which satisfies the \n[[given predicate function|selecting]], if any, or \n`null` if there is no such element. For an infinite \nstream, this method might not terminate.\n\nFor example, the expression\n\n    (-10..10).find(Integer.positive)\n\nevaluates to `1`."]},nm:"find"},locateLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{comp:"i",mt:"tp",l:[{nm:"Element"},{pk:".",nm:"Object"}]}],nm:"Entry"}]},pa:9,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The predicate the element must satisfy."]},nm:"selecting"}]],mt:"m",$m:{selecting$u7lwbh:{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"m",an:{doc:["The predicate the element must satisfy."]},nm:"selecting"}},an:{see:["locate","locations","findLast","List.lastIndexWhere"],doc:["The last element of this stream which satisfies the \n[[given predicate function|selecting]], if any, \ntogether with its position in the stream, or `null` \nif there is no such element. For an infinite stream, \nthis method might not terminate.\n\nFor example, the expression\n\n    (-10..10).locateLast(3.divides)\n\nevaluates to `19->9`."]},nm:"locateLast"},repeat:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:9,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"times"}]],mt:"m",an:{see:["cycled"],doc:["Produces a stream formed by repeating the elements of \nthis stream the given [[number of times|times]], or an \nempty stream if `times<=0`.\n\nFor example, the expression\n\n    { 1, 2 }.repeat(3)\n\nevaluates to the stream `{ 1, 2, 1, 2, 1, 2 }`."]},nm:"repeat"},by:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},pa:9,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"step"}]],mt:"m",$at:{string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"}},$m:{iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"}},an:{doc:["Produces a stream containing every [[step]]th element \nof this stream. If the step size is `1`, the resulting\nstream contains the same elements as this stream.\n\nFor example, the expression\n\n    (0..10).by(3)\n\nresults in the stream `{ 0, 3, 6, 9 }`.\n\nThe step size must be greater than zero."],throws:["AssertionError","if the given step size is nonpositive, \ni.e. `step<1`"]},nm:"by",$c:{anon$17$yx2c35:{super:{pk:".",nm:"Basic"},sts:[{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"Absent"}],nm:"Iterable"}],mt:"c",$anon:1,nm:"anon$17$yx2c35"}}},interpose:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]},{mt:"tp",nm:"Absent"}],nm:"Iterable"},pa:9,ps:[[{$t:{nm:"Other"},mt:"prm",an:{doc:["The value to interpose between blocks of \nelements of this stream."]},nm:"element"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The step size that determines how often the \ngiven [[element]] occurs in the resulting \nstream. The `element` occurs after each block \nof size `step` of elements of this stream. If \n`step==1`, the `element` occurs at every second \nposition."]},nm:"step"}]],mt:"m",$at:{size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"},last:{$t:{comp:"u",l:[{nm:"Absent"},{nm:"Element"},{nm:"Other"}]},pa:3,mt:"g",nm:"last"},first:{$t:{comp:"u",l:[{nm:"Absent"},{nm:"Element"},{nm:"Other"}]},pa:3,mt:"g",nm:"first"},empty:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"g",nm:"empty"}},$m:{iterator:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"}},tp:[{nm:"Other"}],an:{see:["interleave"],doc:["A stream that contains the given [[element]] interposed\nbetween blocks of [[step]] elements of this stream. The\nresulting stream starts with the [[first]] element of \nthis stream and ends with the [[last]] element of this\nstream. Elements of this stream occur in the resulting\nstream in the same order they occur in this stream.\n\nFor example, the expression\n\n    String(\"hello\".interpose(' '))\n\nevaluates to the string `\"h e l l o\"`."],throws:["AssertionError","if `step<1`"]},nm:"interpose",$c:{anon$29$jkxyn2:{super:{pk:".",nm:"Basic"},sts:[{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]},{mt:"tp",nm:"Absent"}],nm:"Iterable"}],mt:"c",$anon:1,nm:"anon$29$jkxyn2"}}},narrow:{$t:{pk:".",tp:[{comp:"i",mt:"tp",l:[{nm:"Element"},{nm:"Type"}]},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:9,mt:"m",tp:[{nm:"Type"}],an:{doc:["Produces a stream containing the elements of this \nstream that are instances of the given [[type|Type]].\n\nFor example, the expression\n\n    { 1, 2, null, 3 }.narrow<Object>()\n\nresults in the stream `{ 1, 2, 3 }` of type `{Integer*}`.\n\nIf the type argument `Type` is not explicitly specified,\n[[Nothing]] is inferred, and the resulting stream is \nempty."]},nm:"narrow"},defaultNullElements:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},{nm:"Default"}]},{mt:"tp",nm:"Absent"}],nm:"Iterable"},pa:9,ps:[[{$t:{nm:"Default"},mt:"prm",an:{doc:["A default value that replaces `null` elements."]},nm:"defaultValue"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Default"}],an:{see:["coalesced"],doc:["Produces a stream containing the elements of this \nstream, in the order in which they occur in this stream, \nafter replacing every `null` element in the stream with \nthe [[given default value|defaultValue]]. The value \n`null` does not ocur in the resulting stream.\n\nFor example, the expression\n\n    { \"123\", \"abc\", \"456\" }.map(parseInteger).defaultNullElements(0)\n\nresults in the stream `{ 123, 0, 456 }`."]},nm:"defaultNullElements"},map:{$t:{pk:".",tp:[{mt:"tp",nm:"Result"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},pa:9,ps:[[{$t:{nm:"Result"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The mapping to apply to the elements."]},nm:"collecting"}]],mt:"m",tp:[{nm:"Result"}],an:{see:["collect"],doc:["Produces a stream containing the results of applying \nthe given [[mapping|collecting]] to the elements of \nthis stream.\n\nFor any empty stream, `map()` returns an empty stream:\n\n    {}.map(f) == {}\n\nFor any nonempty stream `it`, and mapping function `f`,\nthe result of `map()` may be obtained according to this\nrecursive definition:\n\n    it.map(f).first == f(it.first)\n    it.map(f).rest == it.rest.map(f)\n\nAlternatively, and in practice, `map()` may be defined \nby this comprehension:\n\n    it.map(f) == { for (e in it) f(e) }\n\nFor example, the expression\n\n    (0..4).map(10.power)\n\nresults in the stream `{ 1, 10, 100, 1000, 10000 }`."]},nm:"map"},every:{$t:{pk:".",nm:"Boolean"},pa:9,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The predicate that all elements must satisfy."]},nm:"selecting"}]],mt:"m",$m:{selecting$uznjta:{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"m",an:{doc:["The predicate that all elements must satisfy."]},nm:"selecting"}},an:{see:["any"],doc:["Determines if all elements of this stream satisfy the \ngiven [[predicate function|selecting]]. If the stream\nis empty, return `true`. For an infinite stream, this \noperation might not terminate."]},nm:"every"},group:{$t:{pk:".",tp:[{mt:"tp",nm:"Group"},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"}],nm:"Map"},pa:1,ps:[[{$t:{nm:"Group"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The grouping function that assigns a key to the\ngiven [[element]]. Multiple elements may be \nassigned to the same key, indicating that they\nbelong to the same [[Group]] in the resulting\nmap."]},nm:"grouping"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Group"}],an:{see:["summarize"],doc:["Classifies the elements of this stream into a new\nimmutable [[Map]] where each key is a value produced by \nthe given [[grouping function|grouping]] and each \ncorresponding item is [[sequence|Sequence]] of all \nelements that produced the key when passed as arguments \nto the grouping function.\n\nWithin each group, the sequence elements occur in the\nsame order they occurred in this stream.\n\nFor example:\n\n(0..10).group((i) => i.even then \"even\" else \"odd\")\n\nproduces the map \n`{ even->[0, 2, 4, 6, 8, 10], odd->[1, 3, 5, 7, 9] }`.\n\nThis is an eager operation, and the resulting map does\nnot reflect changes to this stream."]},nm:"group"},reduce:{$t:{comp:"u",l:[{nm:"Result"},{nm:"Element"},{nm:"Absent"}]},pa:9,ps:[[{$t:{nm:"Result"},ps:[[{$t:{comp:"u",l:[{nm:"Result"},{nm:"Element"}]},mt:"prm",nm:"partial"},{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The accumulating function that accepts an\nintermediate result, and the next element."]},nm:"accumulating"}]],mt:"m",$m:{accumulating$tag08u:{$t:{nm:"Result"},ps:[[{$t:{comp:"u",l:[{nm:"Result"},{nm:"Element"}]},mt:"prm",nm:"partial"},{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"m",an:{doc:["The accumulating function that accepts an\nintermediate result, and the next element."]},nm:"accumulating"}},tp:[{nm:"Result"}],an:{see:["fold"],doc:["Beginning with the [[first]] element of this stream,\napply the given [[combining function|accumulating]] to \neach element of this stream in turn, progressively\naccumulating a single result.\n\nFor an empty stream, `reduce()` always returns `null`.\n\nFor a stream with one element, `reduce()` returns that\nelement:\n\n    { first }.reduce(f) == first\n\nFor a given stream `it` with more than one element, \nand combining function `f`, the result of `reduce()` is \nobtained according to the following recursive \ndefinition:\n\n    it.reduce(f) == f(it.exceptLast.reduce(f), it.last)\n\nFor example, the expression\n\n    (1..100).reduce(plus<Integer>)\n\nresults in the integer `5050`."]},nm:"reduce"},chain:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]},{comp:"i",mt:"tp",l:[{nm:"Absent"},{nm:"OtherAbsent"}]}],nm:"Iterable"},pa:9,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"},{mt:"tp",nm:"OtherAbsent"}],nm:"Iterable"},mt:"prm",nm:"other"}]],mt:"m",tp:[{nm:"Other"},{sts:[{pk:".",nm:"Null"}],nm:"OtherAbsent"}],an:{see:["expand"],doc:["The elements of this stream, in the order in which they \noccur in this stream, followed by the elements of the \n[[given stream|other]] in the order in which they occur \nin the given stream.\n\nFor example, the expression\n\n    (1..3).chain(\"abc\")\n\nevaluates to the stream `{ 1, 2, 3, 'a', 'b', 'c' }`."]},nm:"chain"},product:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{comp:"u",l:[{nm:"Other"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"Element"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Other"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Other"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"}],nm:"Tuple"},{comp:"u",mt:"tp",l:[{nm:"Absent"},{nm:"OtherAbsent"}]}],nm:"Iterable"},pa:9,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"},{mt:"tp",nm:"OtherAbsent"}],nm:"Iterable"},mt:"prm",nm:"other"}]],mt:"m",tp:[{nm:"Other"},{sts:[{pk:".",nm:"Null"}],nm:"OtherAbsent"}],an:{doc:["A stream of pairs of elements of this stream and the \nthe given stream, where for each element `x` of this\nstream, and element `y` of the given stream, the\npair `[x,y]` belongs to the resulting stream. The pairs\nare sorted first by the position of `x` in this stream,\nand then by the position of `y` in the given stream.\n\nFor example, this expression\n\n    (1..3).product(\"ab\")\n\nevaluates to the stream \n`{ [1,'a'], [1,'b'], [2,'a'], [2,'b'], [3,'a'], [3,'b'] }`."]},nm:"product"},max:{$t:{comp:"u",l:[{nm:"Element"},{nm:"Absent"}]},pa:9,ps:[[{$t:{pk:".",nm:"Comparison"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],mt:"prm",$pt:"f",an:{doc:["The function comparing pairs of elements."]},nm:"comparing"}]],mt:"m",$m:{comparing$iit3az:{$t:{pk:".",nm:"Comparison"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],mt:"m",an:{doc:["The function comparing pairs of elements."]},nm:"comparing"}},an:{see:["max","min"],doc:["Return the largest value in the stream, as measured by\nthe given [[comparator function|comparing]] imposing a \npartial order upon the elements of the stream, or `null`\nif this stream is empty.\n\nFor example, the expression\n\n    {-10.0, -1.0, 5.0}.max(byIncreasing(Float.magnitude))\n\nevaluates to `-10`.\n\nFor any nonempty stream `it`, and comparator function \n`c`, `it.max(c)` evaluates to the first element of `it` \nsuch that for every element `e` of `it`, \n`c(e, it.max(c)) != larger`.\n\nNote that the toplevel functions [[ceylon.language::max]]\nand [[ceylon.language::min]] may be used to find the  \nlargest and smallest values in a stream of [[Comparable]] \nvalues, according to the natural order of its elements."]},nm:"max"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:9,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",an:{doc:["The [[index]]th element returned by an iterator of this \nstream, or `null` if there are fewer than `index+1`\nelements in the stream. For a stream with an unstable \niteration order, a different value might be produced \neach time `getFromFirst(index)` is called for a given\ninteger `index`."]},nm:"getFromFirst"},count:{$t:{pk:".",nm:"Integer"},pa:9,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The predicate satisfied by the elements to be \ncounted."]},nm:"selecting"}]],mt:"m",$m:{selecting$wa5l0i:{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"m",an:{doc:["The predicate satisfied by the elements to be \ncounted."]},nm:"selecting"}},an:{doc:["Produces the number of elements in this stream that \nsatisfy the [[given predicate function|selecting]].\nFor an infinite stream, this method never terminates."]},nm:"count"},sort:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:9,ps:[[{$t:{pk:".",nm:"Comparison"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],mt:"prm",$pt:"f",an:{doc:["The function comparing pairs of elements."]},nm:"comparing"}]],mt:"m",$m:{comparing$6qhk6z:{$t:{pk:".",nm:"Comparison"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],mt:"m",an:{doc:["The function comparing pairs of elements."]},nm:"comparing"}},an:{see:["increasing","decreasing","byIncreasing","byDecreasing"],doc:["Produce a new [[sequence|Sequential]] containing the \nelements of this stream, sorted according to the given \n[[comparator function|comparing]] imposing a partial \norder upon the elements of the stream.\n\nFor convenience, the functions [[byIncreasing]] and \n[[byDecreasing]] produce suitable comparator functions.\n\nFor example, this expression\n\n    \"Hello World!\".sort(byIncreasing(Character.lowercased))\n\nevaluates to the sequence \n`[ , !, d, e, H, l, l, l, o, o, r, W].`\n\nThis operation is eager by nature.\n\nNote that the toplevel function [[ceylon.language::sort]] \nmay be used to sort a stream of [[Comparable]] values \naccording to the natural order of its elements."]},nm:"sort"},follow:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Iterable"},pa:9,ps:[[{$t:{nm:"Other"},mt:"prm",nm:"head"}]],mt:"m",tp:[{nm:"Other"}],an:{see:["chain"],doc:["Produces a stream with a given [[initial element|head]], \nfollowed by the elements of this stream, in the order \nin which they occur in this stream.\n\nFor example, the expression\n\n    (1..3).follow(0)\n\nevaluates to the stream `{ 0, 1, 2, 3 }`.\n\nNote that the expression `stream.follow(head)` eagerly \nevaluates `head`, and therefore is not precisely the \nsame as this enumeration expression, where `head` is\nevaluated lazily:\n\n    { head, *stream }"]},nm:"follow"},any:{$t:{pk:".",nm:"Boolean"},pa:9,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The predicate that at least one element must \nsatisfy."]},nm:"selecting"}]],mt:"m",$m:{selecting$2wzmxl:{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"m",an:{doc:["The predicate that at least one element must \nsatisfy."]},nm:"selecting"}},an:{see:["every"],doc:["Determines if there is at least one element of this \nstream that satisfies the given [[predicate \nfunction|selecting]]. If the stream is empty, returns \n`false`. For an infinite stream, this operation might \nnot terminate."]},nm:"any"},each:{$t:{pk:".",nm:"Anything"},pa:9,ps:[[{$t:{pk:".",nm:"Anything"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The function to be called for each element in the\nstream."]},nm:"step"}]],$ff:1,mt:"m",$m:{step$mutwiu:{$t:{pk:".",nm:"Anything"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],$ff:1,mt:"m",an:{doc:["The function to be called for each element in the\nstream."]},nm:"step"}},an:{doc:["Call the given [[function|step]] for each element of \nthis stream, passing the elements in the order they \noccur in this stream.\n\nFor example:\n\n    words.each((word) {\n        print(word.lowercased);\n        print(word.uppercased);\n    });\n\nHas the same effect as the following `for` loop:\n\n    for (word in words) {\n        print(word.lowercased);\n        print(word.uppercased);\n    }\n\n_For certain streams this method is highly efficient,\nsurpassing the performance of `for` loops on the JVM.\nThus, `each()` is sometimes preferred in highly \nperformance-critical low-level code._"]},nm:"each"},findLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:9,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The predicate the element must satisfy."]},nm:"selecting"}]],mt:"m",$m:{selecting$fbqcn6:{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"m",an:{doc:["The predicate the element must satisfy."]},nm:"selecting"}},an:{see:["find","locateLast"],doc:["The last element of this stream which satisfies the \n[[given predicate function|selecting]], if any, or \n`null` if there is no such element. For an infinite \nstream, this method will not terminate.\n\nFor example, the expression\n\n    (-10..10).findLast(3.divides)\n\nevaluates to `9`."]},nm:"findLast"},spread:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Result"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},{mt:"tp",nm:"Args"}],nm:"Callable"},pa:9,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Result"},{mt:"tp",nm:"Args"}],nm:"Callable"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"method"}]],mt:"m",tp:[{nm:"Result"},{sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"Anything"}],nm:"Sequential"}],nm:"Args"}],an:{doc:["Given a [[method]] of the element type [[Element]], \nreturn a function that, when supplied with a list of \nmethod arguments, produces a new iterable object that \napplies the `method` to each element of this iterable \nobject in turn.\n\n    {Boolean+}(Object) fun = (-1..1).spread(Object.equals);\n    print(fun(0)); \/\/prints { false, true, false }"]},nm:"spread"},flatMap:{$t:{pk:".",tp:[{mt:"tp",nm:"Result"},{comp:"u",mt:"tp",l:[{nm:"Absent"},{nm:"OtherAbsent"}]}],nm:"Iterable"},pa:9,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Result"},{mt:"tp",nm:"OtherAbsent"}],nm:"Iterable"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The mapping function to apply to the elements \nof this stream, that produces a new stream of \n[[Result]]s."]},nm:"collecting"}]],mt:"m",tp:[{nm:"Result"},{sts:[{pk:".",nm:"Null"}],nm:"OtherAbsent"}],an:{see:["expand"],doc:["Given a [[mapping function|collecting]] that accepts an \n[[Element]] and returns a stream of [[Result]]s, \nproduces a new stream containing all elements of every \n`Result` stream that results from applying the function \nto the elements of this stream.\n\nFor example, the expression\n\n    { \"Hello\", \"World\" }.flatMap(String.lowercased)\n\nresults in this stream:\n\n    { 'h', 'e', 'l', 'l', 'o', 'w', 'o', 'r,' 'l', 'd' }\n\nThe expression\n    \n    { \"hello\"->\"hola\", \"world\"->\"mundo\" }\n            .flatMap(Entry<String,String>.pair)\n\nproduces this stream:\n\n    { \"hello\", \"hola\", \"world\", \"mundo\" }"]},nm:"flatMap"},filter:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:9,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The predicate the elements must satisfy."]},nm:"selecting"}]],mt:"m",an:{see:["select"],doc:["Produces a stream containing the elements of this \nstream that satisfy the given [[predicate \nfunction|selecting]].\n\nFor any empty stream, `filter()` returns an empty \nstream:\n\n    {}.filter(p) == {}\n\nFor any nonempty stream `it`, and predicate `p`, the \nresult of `filter()` may be obtained according to this\nrecursive definition:\n\n    it.filter(p) == { if (p(it.first)) it.first }.chain(it.rest.filter(f))\n\nAlternatively, and in practice, `filter()` may be \ndefined by this comprehension:\n\n    it.filter(p) == { for (e in it) if (p(e)) e };\n\nFor example, the expression\n\n    (1..100).filter(13.divides)\n\nresults in the stream `{ 13, 26, 39, 52, 65, 78, 91 }`."]},nm:"filter"},sequence:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:9,mt:"m",an:{doc:["A [[sequence|Sequential]] containing all the elements \nof this stream, in the same order they occur in this\nstream. This operation eagerly evaluates and collects \nevery element of the stream."]},nm:"sequence"},fold:{$t:{nm:"Result"},pa:9,ps:[[{$t:{nm:"Result"},mt:"prm",nm:"initial"}],[{$t:{nm:"Result"},ps:[[{$t:{nm:"Result"},mt:"prm",nm:"partial"},{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The accumulating function that accepts an\nintermediate result, and the next element."]},nm:"accumulating"}]],mt:"m",$m:{accumulating$s830c5:{$t:{nm:"Result"},ps:[[{$t:{nm:"Result"},mt:"prm",nm:"partial"},{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"m",an:{doc:["The accumulating function that accepts an\nintermediate result, and the next element."]},nm:"accumulating"}},tp:[{nm:"Result"}],an:{see:["reduce","scan"],doc:["Beginning with a given [[initial value|initial]], apply \nthe given [[combining function|accumulating]] to each \nelement of this stream in turn, progressively \naccumulating a single result.\n\nFor an empty stream, `fold()` returns the given initial \nvalue `z`:\n\n    {}.fold(z)(f) == z\n\nFor a given nonempty stream `it`, initial value `z`, \nand combining function `f`, the result of `fold()` is \nobtained according to the following recursive \ndefinition:\n\n    it.fold(z)(f) == f(it.exceptLast.fold(z)(f), it.last)\n\nFor example, the expression\n\n    (1..100).fold(0)(plus<Integer>)\n\nresults in the integer `5050`."]},nm:"fold"},take:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:9,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"taking"}]],mt:"m",$at:{first:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,mt:"g",nm:"first"}},$m:{iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:3,mt:"m",$at:{string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},i$28cecw:{$t:{pk:".",nm:"Integer"},pa:1024,mt:"a",nm:"i"}},$m:{next:{$t:{comp:"u",l:[{nm:"Element"},{pk:".",nm:"Finished"}]},pa:3,mt:"m",nm:"next"}},nm:"iterator",$c:{anon$11$rsht18:{super:{pk:".",nm:"Basic"},sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"}],mt:"c",$anon:1,nm:"anon$11$rsht18"}}}},an:{see:["List.sublistTo","List.initial","takeWhile","skip"],doc:["Produces a stream containing the first [[taking]]\nelements of this stream.\n\nIf the specified number of elements to take is larger \nthan the number of elements of this stream, the \nresulting stream contains the same elements as this \nstream. If the specified number of elements to take is\nfewer than one, the resulting stream has no elements."]},nm:"take",$c:{anon$10$e34tqq:{super:{pk:".",nm:"Basic"},sts:[{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"}],mt:"c",$anon:1,nm:"anon$10$e34tqq"}}},contains:{$t:{pk:".",nm:"Boolean"},pa:11,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],mt:"m",an:{doc:["Returns `true` if the iterator for this stream produces\nthe given element, or `false` otherwise. In the case of \nan infinite stream, this operation might never terminate;\nfurthermore, this default implementation iterates all\nthe elements until found (or not), which might be very\nexpensive."]},nm:"contains"},shorterThan:{$t:{pk:".",nm:"Boolean"},pa:9,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",an:{see:["size"],doc:["Determines if this stream has fewer elements than the \ngiven [[length]]. This is an efficient operation for \nstreams with many elements."]},nm:"shorterThan"},longerThan:{$t:{pk:".",nm:"Boolean"},pa:9,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",an:{see:["size"],doc:["Determines if this stream has more elements than the \ngiven [[length]]. This is an efficient operation for\nstreams with many elements."]},nm:"longerThan"},locations:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{comp:"i",mt:"tp",l:[{nm:"Element"},{pk:".",nm:"Object"}]}],nm:"Entry"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:9,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The predicate the element must satisfy."]},nm:"selecting"}]],mt:"m",an:{see:["locate","locateLast","List.indexesWhere"],doc:["A stream producing all elements of this stream which\nsatisfy the [[given predicate function|selecting]],\ntogether with their positions in the stream.\n\nFor example, the expression\n\n    (-5..5).locations(3.divides)\n\nevaluates to the stream `{ 2->-3, 5->0, 8->3 }`.\n\nNote that this method is more efficient than the\nalternative of applying [[filter]] to an [[indexed]]\nstream."]},nm:"locations"},summarize:{$t:{pk:".",tp:[{mt:"tp",nm:"Group"},{mt:"tp",nm:"Result"}],nm:"Map"},pa:1,ps:[[{$t:{nm:"Group"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The grouping function that assigns a key to the\ngiven [[element]]. Multiple elements may be \nassigned to the same key, indicating that they\nshould be aggregated by calling [[accumulating]]."]},nm:"grouping"},{$t:{nm:"Result"},ps:[[{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Result"}]},mt:"prm",nm:"partial"},{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The accumulating function that accepts an\nintermediate result for a key, and the next \nelement with that key."]},nm:"accumulating"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Group"},{nm:"Result"}],an:{see:["group","fold"],doc:["Efficiently [[group]] and [[fold]] the elements of this\nstream in a single step.\n\nFor example, the expression:\n\n    (1..10)\n       .summarize((i) => i%3, \n           (Integer[2]? pair, i) \n               => if (exists [sum, product] = pair) \n                  then [sum+i, product*i] else [i,i])\n\nproduces the map \n`{ 0->[18, 162], 1->[22, 280], 2->[15, 80] }`, being \nequivalent to, but much more efficient than, the \nfollowing expression written using `group()`, \n`mapItems()` and `fold()`:\n\n    (1..10)\n        .group((i) => i%3)\n        .mapItems((_, item) \n           => item.fold([0,1])\n               ((pair, i) \n                   => let ([sum, product] = pair) \n                       [sum+i, product*i]))\n\nThis is an eager operation, and the resulting map does\nnot reflect changes to this stream."]},nm:"summarize"},collect:{$t:{pk:".",tp:[{mt:"tp",nm:"Result"}],nm:"Sequential"},pa:9,ps:[[{$t:{nm:"Result"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The transformation applied to the elements."]},nm:"collecting"}]],mt:"m",tp:[{nm:"Result"}],an:{see:["map"],doc:["Produce a new [[sequence|Sequential]] containing the \nresults of applying the given [[mapping|collecting]] to\nthe elements of this stream.\n\nThis operation is an eager counterpart to [[map]]. For\nany stream `it`, and mapping `f`:\n\n    it.collect(f) == [*it.map(f)]"]},nm:"collect"},frequencies:{$t:{pk:".",tp:[{comp:"i",mt:"tp",l:[{nm:"Element"},{pk:".",nm:"Object"}]},{mt:"tp",pk:".",nm:"Integer"}],nm:"Map"},pa:1,mt:"m",an:{doc:["Produce a [[Map]] mapping elements to frequencies where\neach [[entry|Entry]] maps a distinct non-null element \nof this stream to the number of times the element was \nproduced by the stream. Elements are considered \ndistinct if they are not [[equal|Object.equals]]. Null \nelements of this stream are simply discarded.\n\nThis is an eager operation, and the resulting map does\nnot reflect changes to this stream."]},nm:"frequencies"}},tp:[{dv:"out",def:{pk:".",nm:"Anything"},nm:"Element"},{dv:"out",sts:[{pk:".",nm:"Null"}],def:{pk:".",nm:"Null"},nm:"Absent"}],an:{see:["Collection","corresponding"],tagged:["Streams"],by:["Gavin"],doc:["Abstract supertype of [[categories|Category]] whose\nelements may be iterated. Iterable categories are often\ncalled _streams_. A stream need not be finite, but its\nelements must be countable. That is, for any given\nelement of the stream, every iterator of the stream must\neventually return the element, even if the iterator\nitself is not exhaustible.\n\nA stream may have null elements. That is, an iterator for\nthe stream may produce the value [[null]] one or more\ntimes. For every non-null `element` of a given stream\n`it`, the expression `element in it` must evaluate to\n`true`. Thus, a stream is a category of its non-null\nelements.\n\nA given stream might not have a well-defined order, and\nso the order in which elements are produced by the\nstream's iterator may not be _stable_. That is, the order\nmay be different for two different iterators of the\nstream. However, a stream has a well-defined set of\nelements, and any two iterators for an immutable finite\nstream should eventually return the same elements.\nFurthermore, any two iterators for an immutable finite\nstream should eventually return exactly the same number\nof elements, which must be the [[size]] of the stream.\n\nA given stream may not be _finite_, in which case an\niterator for the stream is never exhaustible, and certain\noperations of this interface either never terminate or\nresult in an [[AssertionError]]. It may not, in general,\nbe possible to even determine if an `Iterable` is finite.\n\nThe type `Iterable<Element,Null>`, usually abbreviated\n`{Element*}`, represents a possibly-empty iterable\ncontainer. The type `Iterable<Element,Nothing>`, usually\nabbreviated `{Element+}`, represents a nonempty iterable\ncontainer.\n\nA value list in braces produces a new instance of \n`Iterable`:\n\n    {String+} words = { \"hello\", \"world\" };\n\nAn instance of `Iterable` may be iterated using a `for`\nloop:\n\n    for (c in \"hello world\") { ... }\n\nComprehensions provide a convenient syntax for \ntransforming streams:\n\n    {Integer+} lengths = { for (w in words) w.size };\n\nThe `*.` operator may be used to evaluate an attribute\nor invoke a method of the elements of the stream,\nproducing a new stream:\n\n    {Integer+} lengths = words*.size;\n\n`Iterable` and its subtypes define various operations\nthat return other iterable objects. Such operations come \nin two flavors:\n\n- _Lazy_ operations return a *view* of the receiving\n  iterable object. If the underlying iterable object is\n  mutable, then changes to the underlying object will be \n  reflected in the resulting view. Lazy operations are \n  usually efficient, avoiding memory allocation or\n  iteration of the receiving iterable object.\n- _Eager_ operations return an immutable object. If the\n  receiving iterable object is mutable, changes to this\n  object will not be reflected in the resulting immutable\n  object. Eager operations are often expensive, involving\n  memory allocation and iteration of the receiving \n  iterable object.\n\nLazy operations are generally preferred, because they can \nbe efficiently chained. For example:\n\n    string.filter((c) => c.letter||c.digit)\n          .map(Character.uppercased)\n\nis much less expensive than:\n\n    string.select((c) => c.letter||c.digit)\n          .collect(Character.uppercased)\n\nFurthermore, it is always easy to produce a new \nimmutable iterable object given the view produced by a\nlazy operation. For example:\n\n    [ *string.filter((c) => c.letter||c.digit)\n             .map(Character.uppercased) ]\n\nHowever, there are certain scenarios where an eager \noperation is more useful, more convenient, or no more \nexpensive than a lazy operation, including:\n\n- sorting operations, for example [[sort]], which are \n  eager by nature,\n- operations which result in a subset or subrange of the \n  receiving stream, where structural sharing would or\n  could result in unnecessary memory retention.\n\nCertain operations come in both lazy and eager flavors,\nfor example:\n\n- [[map]] vs [[collect]],\n- [[filter]] vs [[select]],\n- [[List.sublist]] vs [[List.measure]].\n\nLazy operations normally return an instance of `Iterable`, \nor even a [[List]], [[Map]], or [[Set]]. Eager operations \nusually return a [[sequence|Sequential]]. The method\n[[sequence]] materializes the current elements of a\nstream into a sequence.\n\nThere is no meaningful generic definition of equality for \nstreams. For some streams&mdash;for example, \n`List`s&mdash;order is significant; for others&mdash;for \nexample, `Set`s&mdash;order is not significant. Therefore, \nunlike [[Collection]], `Iterable` does not define or \nrequire any form of [[value equality|Object.equals]], and \nsome streams do not support value equality. It follows \nthat the `==` operator should not be used to compare \ngeneric streams, unless the streams are known to share\nsome additional structure.\n\nTo compare two streams, taking order into account, use\nthe function [[corresponding]].\n\n    {Float*} xs = ... ;\n    {Float*} ys = ... ;\n    Boolean same = corresponding(xs, ys);"]},nm:"Iterable"},StringBuilder:{super:{pk:".",nm:"Basic"},pa:97,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"Character"}],nm:"List"}],mt:"c",$at:{size:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",an:{doc:["The number characters in the current content, that is, \nthe [[size|String.size]] of the produced [[string]]."]},nm:"size"},string:{$t:{pk:".",nm:"String"},pa:67,mt:"a",an:{doc:["The resulting string. If no characters have been\nappended, the empty string."]},nm:"string"},lastIndex:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:67,mt:"a",nm:"lastIndex"},hash:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"hash"}},$m:{appendSpace:{$t:{pk:".",nm:"StringBuilder"},pa:65,mt:"m",an:{doc:["Append a space character."]},nm:"appendSpace"},appendAll:{$t:{pk:".",nm:"StringBuilder"},pa:65,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"String"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"strings"}]],mt:"m",an:{doc:["Append the characters in the given [[strings]]."]},nm:"appendAll"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Character"}]},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"getFromFirst"},prepend:{$t:{pk:".",nm:"StringBuilder"},pa:65,ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"string"}]],mt:"m",an:{doc:["Prepend the characters in the given [[string]]."]},nm:"prepend"},clear:{$t:{pk:".",nm:"StringBuilder"},pa:65,mt:"m",an:{doc:["Remove all content and return to initial state."]},nm:"clear"},replace:{$t:{pk:".",nm:"StringBuilder"},pa:65,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"},{$t:{pk:".",nm:"String"},mt:"prm",nm:"string"}]],mt:"m",an:{doc:["Replaces the specified [[number of characters|length]] \nfrom the current content, starting at the specified \n[[index]], with the given [[string]]. If `length` is \nnonpositive, nothing is replaced."]},nm:"replace"},prependCharacter:{$t:{pk:".",nm:"StringBuilder"},pa:65,ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"character"}]],mt:"m",an:{doc:["Prepend the given [[character]]."]},nm:"prependCharacter"},insert:{$t:{pk:".",nm:"StringBuilder"},pa:65,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"},{$t:{pk:".",nm:"String"},mt:"prm",nm:"string"}]],mt:"m",an:{doc:["Insert a [[string]] at the specified [[index]]."]},nm:"insert"},delete:{$t:{pk:".",nm:"StringBuilder"},pa:65,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",an:{doc:["Deletes the specified [[number of characters|length]] \nfrom the current content, starting at the specified \n[[index]]. If `length` is nonpositive, nothing is \ndeleted."]},nm:"delete"},substring:{$t:{pk:".",nm:"String"},pa:65,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",an:{doc:["Returns a string of the given [[length]] containing\nthe characters beginning at the given [[index]]."]},nm:"substring"},reverseInPlace:{$t:{pk:".",nm:"StringBuilder"},pa:65,mt:"m",an:{doc:["Reverses the order of the current characters."]},nm:"reverseInPlace"},iterator:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Character"}],nm:"Iterator"},pa:67,mt:"m",nm:"iterator"},prependAll:{$t:{pk:".",nm:"StringBuilder"},pa:65,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"String"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"strings"}]],mt:"m",an:{doc:["Prepend the characters in the given [[strings]]."]},nm:"prependAll"},deleteInitial:{$t:{pk:".",nm:"StringBuilder"},pa:65,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",an:{doc:["Deletes the specified [[number of characters|length]] \nfrom the start of the string. If `length` is \nnonpositive, nothing is deleted."]},nm:"deleteInitial"},equals:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],mt:"m",nm:"equals"},appendCharacter:{$t:{pk:".",nm:"StringBuilder"},pa:65,ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"character"}]],mt:"m",an:{doc:["Append the given [[character]]."]},nm:"appendCharacter"},appendNewline:{$t:{pk:".",nm:"StringBuilder"},pa:65,mt:"m",an:{doc:["Append a newline character."]},nm:"appendNewline"},insertCharacter:{$t:{pk:".",nm:"StringBuilder"},pa:65,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"},{$t:{pk:".",nm:"Character"},mt:"prm",nm:"character"}]],mt:"m",an:{doc:["Insert a [[character]] at the specified [[index]]."]},nm:"insertCharacter"},append:{$t:{pk:".",nm:"StringBuilder"},pa:65,ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"string"}]],mt:"m",an:{doc:["Append the characters in the given [[string]]."]},nm:"append"},deleteTerminal:{$t:{pk:".",nm:"StringBuilder"},pa:65,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",an:{doc:["Deletes the specified [[number of characters|length]] \nfrom the end of the string. If `length` is nonpositive, \nnothing is deleted."]},nm:"deleteTerminal"}},an:{tagged:["Strings"],doc:["Builder utility for constructing [[strings|String]] by \nincrementally appending strings or characters.\n\n    value builder = StringBuilder();\n    builder.append(\"hello\");\n    builder.appendCharacter(' ');\n    builder.append(\"world\");\n    String hello = builder.string; \/\/hello world"]},nm:"StringBuilder"},byIncreasing:{$t:{pk:".",nm:"Comparison"},pa:1,ps:[[{$t:{nm:"Value"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"e"}]],mt:"prm",$pt:"f",nm:"comparable"}],[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],mt:"m",tp:[{nm:"Element"},{sts:[{pk:".",tp:[{mt:"tp",nm:"Value"}],nm:"Comparable"}],nm:"Value"}],an:{see:["byDecreasing","increasing","Iterable.max","Iterable.sort"],tagged:["Functions","Comparisons"],doc:["Produces a comparator function which orders elements in \nincreasing order according to the [[Comparable]] value \nreturned by the given [[comparable]] function.\n\n     \"Hello World!\".sort(byIncreasing(Character.lowercased))\n\nThis function is intended for use with [[Iterable.sort]]\nand [[Iterable.max]]."]},nm:"byIncreasing"},Scalable:{st:"Value",pa:1,mt:"i",of:[{nm:"Value"}],$m:{scale:{$t:{nm:"Value"},pa:5,ps:[[{$t:{nm:"Scale"},mt:"prm",nm:"scalar"}]],mt:"m",an:{doc:["Scale this value by the given scale factor."]},nm:"scale"}},tp:[{dv:"in",sts:[{pk:".",tp:[{mt:"tp",nm:"Scale"}],nm:"Numeric"}],nm:"Scale"},{dv:"out",sts:[{pk:".",tp:[{mt:"tp",nm:"Scale"},{mt:"tp",nm:"Value"}],nm:"Scalable"}],nm:"Value"}],an:{tagged:["Numbers"],by:["Gavin"],doc:["Abstract supertype of types that support scaling by a \nnumeric factor. Examples of such types include vectors and \nmatrices. The _scale_ operator `a ** x` accepts a scale \nfactor as its first operand, and an instance of `Scalable` \nas its second operand.\n\n    Vector scaled = 2.0 ** Vector(x,y,z);\n\nConcrete classes which implement this interface should\nsatisfy:\n\n- `x == 1**x`\n- `a ** (b ** x) == a*b ** x`\n\nwhere `1` denotes the multiplicative identity of the \nnumeric scaling type.\n\nConcrete classes which implement this interface are\nencouraged to also satisfy [[Invertible]], in which case, \nthe following identity should be satisfied:\n\n- `-x == -1**x`\n\nConcrete classes which implement this interface and which\nalso satisfy [[Summable]] should satisfy:\n\n- `x+x == 2**x`\n- `a ** (x+y) == a**x + a**y`\n\nThe [[scaling type|Scale]] must be a [[numeric|Numeric]]\ntype, but is not required to be [[Number]], since a complex\nnumber scaling type should be allowed."]},nm:"Scalable"},InitializationError:{super:{pk:".",nm:"AssertionError"},pa:1,ps:[{$t:{pk:".",nm:"String"},mt:"prm",nm:"description"}],mt:"c",$at:{description$lsghss:{$t:{pk:".",nm:"String"},mt:"a",nm:"description"}},an:{see:["late"],doc:["[[Assertion failure|AssertionError]] that occurs when a \nvalue reference could not be initialized, including when:\n\n- a toplevel value could not be initialized due to \n  recursive dependencies upon other toplevel values, \n- an uninitialized [[late]] value is evaluated, \n- an initialized `late` but non-`variable` value is\n  reassigned."]},nm:"InitializationError"},ElementEntry:{super:{pk:".",nm:"Object"},sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"}],ps:[{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"ElementEntry"}]},pa:1,mt:"prm",nm:"next",$hdn:1},{$t:{nm:"Element"},pa:1,mt:"prm",nm:"element",$hdn:1}],mt:"c",$at:{next:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"ElementEntry"}]},pa:1,mt:"a",nm:"next"},rest:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,mt:"g",nm:"rest"},last:{$t:{nm:"Element"},pa:3,mt:"g",nm:"last"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"},first:{$t:{nm:"Element"},pa:3,mt:"g",nm:"first"},element:{$t:{nm:"Element"},pa:1,mt:"a",nm:"element"}},$m:{iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"getFromFirst"},has:{$t:{pk:".",nm:"Boolean"},pa:1,ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",nm:"element"}]],mt:"m",nm:"has"}},tp:[{nm:"Element"}],nm:"ElementEntry"},smallest:{$t:{nm:"Element"},pa:1,ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],mt:"m",tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Comparable"}],nm:"Element"}],an:{see:["Comparable","largest","min"],tagged:["Comparisons"],doc:["Given two [[Comparable]] values, return smallest of the two."]},nm:"smallest"},SharedAnnotation:{super:{pk:".",nm:"Basic"},pa:561,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"SharedAnnotation"},{comp:"u",mt:"tp",l:[{pk:"ceylon.language.meta.declaration",nm:"FunctionDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ValueDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ClassOrInterfaceDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ConstructorDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"Package"},{pk:"ceylon.language.meta.declaration",nm:"Import"}]},{mt:"tp",pk:".",nm:"Anything"}],nm:"OptionalAnnotation"}],mt:"c",an:{doc:["The annotation class for the [[shared]] annotation."]},nm:"SharedAnnotation"},LateAnnotation:{super:{pk:".",nm:"Basic"},pa:561,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"LateAnnotation"},{mt:"tp",pk:"ceylon.language.meta.declaration",nm:"ValueDeclaration"},{mt:"tp",pk:".",nm:"Anything"}],nm:"OptionalAnnotation"}],mt:"c",an:{doc:["The annotation class for the [[late]] annotation."]},nm:"LateAnnotation"},ConstrainedAnnotation:{st:"Value",pa:1,sts:[{pk:".",nm:"Annotation"}],mt:"i",of:[{nm:"Value"}],tp:[{dv:"out",sts:[{pk:".",nm:"Annotation"}],def:{pk:".",nm:"Annotation"},nm:"Value"},{dv:"out",def:{pk:".",nm:"Anything"},nm:"Values"},{dv:"in",sts:[{pk:".",nm:"Annotated"}],def:{pk:".",nm:"Nothing"},nm:"ProgramElement"},{dv:"out",def:{pk:".",nm:"Anything"},nm:"Type"}],an:{see:["Annotation","OptionalAnnotation","SequencedAnnotation"],doc:["An annotation constrained to appear only on certain program \nelements, and only with certain values. \n\nThis interface should never be satisfied directly by any\nannotation type. Instead, either [[OptionalAnnotation]] or \n[[SequencedAnnotation]] should be satisfied by the \nannotation type.\n\nThe type parameters encode information about the annotation\ntype and its constraints:\n\n - [[Value]] represents the type of the annotation itself, \n - [[ProgramElement]] represents a constraint on the  \n   _reference expression type_ of the annotated program \n   element, for example, \n   [[ceylon.language.meta.declaration::ClassDeclaration]] \n   or [[ceylon.language.meta.declaration::Module]], where\n   [[Annotated]] means there is no constraint, and\n - [[Type]] is a constraint on the _metamodel type_ of the \n   annotated program element, for example, \n   [[`Function<Float,[Float,Float]>`\n    |ceylon.language.meta.model::Function]], \n   where `Anything` means there is no constraint, and that \n   the program element need not have a metamodel type."]},nm:"ConstrainedAnnotation"},SerializableAnnotation:{super:{pk:".",nm:"Basic"},pa:545,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"SerializableAnnotation"},{mt:"tp",pk:"ceylon.language.meta.declaration",nm:"ClassDeclaration"},{mt:"tp",pk:".",nm:"Anything"}],nm:"OptionalAnnotation"}],mt:"c",an:{doc:["The annotation class for the [[serializable]] annotation."]},nm:"SerializableAnnotation"},Empty:{pa:1,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"}],nm:"Sequential"},{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Ranged"}],mt:"i",of:[{pk:".",nm:"empty"}],$at:{rest:{$t:{pk:".",nm:"Empty"},pa:3,mt:"g",an:{doc:["Returns `[]`."]},nm:"rest"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",an:{doc:["Returns a string description of the empty sequence: \n`[]`."]},nm:"string"},last:{$t:{pk:".",nm:"Null"},pa:3,mt:"g",an:{doc:["Returns `null`."]},nm:"last"},indexed:{$t:{pk:".",nm:"Empty"},pa:3,mt:"g",an:{doc:["Returns `[]`."]},nm:"indexed"},keys:{$t:{pk:".",nm:"Empty"},pa:3,mt:"g",an:{doc:["Returns `[]`."]},nm:"keys"},empty:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"g",an:{doc:["Returns `true`."]},nm:"empty"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",an:{doc:["Returns 0."]},nm:"size"},cycled:{$t:{pk:".",nm:"Empty"},pa:3,mt:"g",an:{doc:["Returns `[]`."]},nm:"cycled"},lastIndex:{$t:{pk:".",nm:"Null"},pa:3,mt:"g",an:{doc:["Returns `null`."]},nm:"lastIndex"},coalesced:{$t:{pk:".",nm:"Empty"},pa:3,mt:"g",an:{doc:["Returns `[]`."]},nm:"coalesced"},reversed:{$t:{pk:".",nm:"Empty"},pa:3,mt:"g",an:{doc:["Returns `[]`."]},nm:"reversed"},first:{$t:{pk:".",nm:"Null"},pa:3,mt:"g",an:{doc:["Returns `null`."]},nm:"first"},paired:{$t:{pk:".",nm:"Empty"},pa:3,mt:"g",an:{doc:["Returns `[]`."]},nm:"paired"}},$m:{spanFrom:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],mt:"m",an:{doc:["Returns `[]` for any given span."]},nm:"spanFrom"},select:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"select"},trimLeading:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"elem"}]],mt:"prm",$pt:"f",nm:"trimming"}]],mt:"m",nm:"trimLeading"},sublistFrom:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],mt:"m",nm:"sublistFrom"},prepend:{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Sequential"},pa:3,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Sequential"},mt:"prm",nm:"elements"}]],mt:"m",tp:[{nm:"Other"}],nm:"prepend"},takeWhile:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"elem"}]],mt:"prm",$pt:"f",nm:"taking"}]],mt:"m",nm:"takeWhile"},firstIndexWhere:{$t:{pk:".",nm:"Null"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"firstIndexWhere"},defines:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",an:{doc:["Returns `false` for any given index."]},nm:"defines"},skipWhile:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"elem"}]],mt:"prm",$pt:"f",nm:"skipping"}]],mt:"m",nm:"skipWhile"},iterator:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"}],nm:"Iterator"},pa:3,mt:"m",an:{doc:["Returns an iterator that is already exhausted."]},nm:"iterator"},trim:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"elem"}]],mt:"prm",$pt:"f",nm:"trimming"}]],mt:"m",nm:"trim"},slice:{$t:{$t:{pk:".",nm:"Empty"},count:2,pk:"$",nm:"Tuple"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"slice"},find:{$t:{pk:".",nm:"Null"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"find"},reduce:{$t:{pk:".",nm:"Null"},pa:3,ps:[[{$t:{nm:"Result"},ps:[[{$t:{nm:"Result"},mt:"prm",nm:"partial"},{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"accumulating"}]],mt:"m",tp:[{nm:"Result"}],nm:"reduce"},getFromFirst:{$t:{pk:".",nm:"Null"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",an:{doc:["Returns `null` for any given index."]},nm:"getFromFirst"},count:{$t:{pk:".",nm:"Integer"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",an:{doc:["Returns 0 for any given predicate."]},nm:"count"},sort:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{pk:".",nm:"Comparison"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"a"},{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"b"}]],mt:"prm",$pt:"f",nm:"comparing"}]],mt:"m",nm:"sort"},indexesWhere:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"indexesWhere"},each:{$t:{pk:".",nm:"Anything"},pa:3,ps:[[{$t:{pk:".",nm:"Anything"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"step"}]],$ff:1,mt:"m",$m:{step$522jkt:{$t:{pk:".",nm:"Anything"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],$ff:1,mt:"m",nm:"step"}},nm:"each"},flatMap:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Result"},{mt:"tp",nm:"OtherAbsent"}],nm:"Iterable"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"collecting"}]],mt:"m",tp:[{nm:"Result"},{sts:[{pk:".",nm:"Null"}],nm:"OtherAbsent"}],nm:"flatMap"},sequence:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",an:{doc:["Returns `[]`."]},nm:"sequence"},fold:{$t:{nm:"Result"},pa:3,ps:[[{$t:{nm:"Result"},mt:"prm",nm:"initial"}],[{$t:{nm:"Result"},ps:[[{$t:{nm:"Result"},mt:"prm",nm:"partial"},{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"accumulating"}]],mt:"m",tp:[{nm:"Result"}],nm:"fold"},take:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"taking"}]],mt:"m",nm:"take"},contains:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],mt:"m",an:{doc:["Returns `false` for any given element."]},nm:"contains"},measure:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",an:{doc:["Returns `[]` for any given measure."]},nm:"measure"},collect:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{nm:"Result"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"collecting"}]],mt:"m",tp:[{nm:"Result"}],nm:"collect"},withLeading:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Other"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Other"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"},pa:3,ps:[[{$t:{nm:"Other"},mt:"prm",nm:"element"}]],mt:"m",tp:[{nm:"Other"}],nm:"withLeading"},skip:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"skipping"}]],mt:"m",nm:"skip"},indexes:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",an:{doc:["Returns `[]`."]},nm:"indexes"},repeat:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"times"}]],mt:"m",an:{doc:["Returns `[]`."]},nm:"repeat"},by:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"step"}]],mt:"m",nm:"by"},defaultNullElements:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{nm:"Default"},mt:"prm",nm:"defaultValue"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Default"}],nm:"defaultNullElements"},trimTrailing:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"elem"}]],mt:"prm",$pt:"f",nm:"trimming"}]],mt:"m",nm:"trimTrailing"},map:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{nm:"Result"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"collecting"}]],mt:"m",tp:[{nm:"Result"}],nm:"map"},every:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"every"},withTrailing:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Other"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Other"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"},pa:3,ps:[[{$t:{nm:"Other"},mt:"prm",nm:"element"}]],mt:"m",tp:[{nm:"Other"}],nm:"withTrailing"},chain:{$t:{pk:".",tp:[{mt:"tp",nm:"Other"},{mt:"tp",nm:"OtherAbsent"}],nm:"Iterable"},pa:3,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"},{mt:"tp",nm:"OtherAbsent"}],nm:"Iterable"},mt:"prm",nm:"other"}]],mt:"m",tp:[{nm:"Other"},{sts:[{pk:".",nm:"Null"}],nm:"OtherAbsent"}],an:{doc:["Returns the given [[other]] iterable object."]},nm:"chain"},lastIndexWhere:{$t:{pk:".",nm:"Null"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"lastIndexWhere"},initial:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",nm:"initial"},sublistTo:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"sublistTo"},terminal:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",nm:"terminal"},follow:{$t:{pk:".",tp:[{mt:"tp",nm:"Other"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Iterable"},pa:3,ps:[[{$t:{nm:"Other"},mt:"prm",nm:"head"}]],mt:"m",tp:[{nm:"Other"}],nm:"follow"},any:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"any"},spread:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Empty"},{mt:"tp",nm:"Args"}],nm:"Callable"},pa:3,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Result"},{mt:"tp",nm:"Args"}],nm:"Callable"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"method"}]],mt:"m",tp:[{nm:"Result"},{sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"Anything"}],nm:"Sequential"}],nm:"Args"}],nm:"spread"},getFromLast:{$t:{pk:".",nm:"Null"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",an:{doc:["Returns `null` for any given index."]},nm:"getFromLast"},spanTo:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",an:{doc:["Returns `[]` for any given span."]},nm:"spanTo"},filter:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"filter"},sublist:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"sublist"},clone:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",an:{doc:["Returns `[]`."]},nm:"clone"},append:{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Sequential"},pa:3,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Sequential"},mt:"prm",nm:"elements"}]],mt:"m",tp:[{nm:"Other"}],nm:"append"},span:{$t:{pk:".",nm:"Empty"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",an:{doc:["Returns `[]` for any given span."]},nm:"span"}},an:{see:["Sequence"],tagged:["Sequences"],doc:["A sequence with no elements. The type `Empty` may be\nabbreviated `[]`, and an instance is produced by the \nexpression `[]`. That is, in the following expression,\n`none` has type `[]` and refers to the value `[]`:\n\n    [] none = [];\n\n(Whether the syntax `[]` refers to the type or the value \ndepends upon how it occurs grammatically.)"]},nm:"Empty"},not:{$t:{pk:".",nm:"Boolean"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Boolean"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Value"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"}],nm:"Callable"},mt:"prm",an:{doc:["The predicate function to negate"]},nm:"p"}],[{$t:{nm:"Value"},mt:"prm",nm:"val"}]],mt:"m",tp:[{dv:"in",nm:"Value"}],an:{tagged:["Functions"],doc:["Returns a function which is the logical negation of the \ngiven predicate function."]},nm:"not"},Number:{st:"Other",pa:1,sts:[{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Numeric"},{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Comparable"}],mt:"i",of:[{nm:"Other"}],$at:{negative:{$t:{pk:".",nm:"Boolean"},pa:5,mt:"a",an:{doc:["Determine if the number is strictly negative, that is, \nif `this<0`, where `0` is the additive identity."]},nm:"negative"},wholePart:{$t:{nm:"Other"},pa:5,mt:"a",an:{doc:["The integral value of the number after truncation of \nthe fractional part. For [[Integral]] numeric types, \nthe integral value of a number is the number itself."]},nm:"wholePart"},sign:{$t:{pk:".",nm:"Integer"},pa:9,mt:"g",an:{doc:["The sign of this number: \n\n- `1` if the number is [[positive]], \n- `-1` if it is [[negative]], or \n- `0` if it is the additive identity.\n\nMust satisfy:\n\n    x.magnitude.timesInteger(x.sign) == x"]},nm:"sign"},magnitude:{$t:{nm:"Other"},pa:9,mt:"g",an:{aliased:["absolute"],doc:["The magnitude of this number, defined for any instance \n`x` as:\n\n- `-x` if `x<0`, or \n- `x` otherwise,\n\nwhere `0` is the additive identity. Hence:\n\n- `x.magnitude >= 0` for any `x`, and\n- `x.magnitude == 0` if and only if `x==0`."]},nm:"magnitude"},positive:{$t:{pk:".",nm:"Boolean"},pa:5,mt:"a",an:{doc:["Determine if the number is strictly positive, that is, \nif `this>0`, where `0` is the additive identity."]},nm:"positive"},fractionalPart:{$t:{nm:"Other"},pa:5,mt:"a",an:{doc:["The fractional part of this number, after truncation of \nthe integral part. For [[Integral]] numeric types, the \nfractional part is always zero."]},nm:"fractionalPart"}},$m:{plusInteger:{$t:{nm:"Other"},pa:5,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"integer"}]],mt:"m",an:{doc:["The result of adding this number to the given \n[[Integer]]."]},nm:"plusInteger"},powerOfInteger:{$t:{nm:"Other"},pa:5,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"integer"}]],mt:"m",an:{doc:["The result of raising this number to the given \nnon-negative [[Integer]] power. For a negative power,\nthe behavior is implementation-dependent."],throws:["AssertionError","if the exponent is a negative power and this is \nan integral numeric type"]},nm:"powerOfInteger"},timesInteger:{$t:{nm:"Other"},pa:5,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"integer"}]],mt:"m",an:{doc:["The result of multiplying this number by the given \n[[Integer]]."]},nm:"timesInteger"}},tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Number"}],nm:"Other"}],an:{see:["Integer","Float"],tagged:["Numbers"],by:["Gavin"],doc:["Abstraction of [[numeric|Numeric]] types with a natural \n[[total order|Comparable]], including the built-in numeric \ntypes [[Integer]] and [[Float]].\n\nA `Number` has a well-defined [[magnitude]] together with a \n[[sign]] of type [[Integer]], defined for any instance `x`\nas follows:\n\n- if `x==0` then `x.sign==0` and `x.magnitude==0`,\n- if `x>0` then `x.sign==1` and `x.magnitude==x`, or\n- if `x<0` then `x.sign==-1` and `x.magnitude==-x`,\n\nwhere `0` is the additive identity of the numeric type.\n\nNot every value commonly considered to be a \"number\" is\na `Number`. For example, complex numbers aren't `Number`s\nsince they don't have a total order."]},nm:"Number"},unflatten:{$t:{nm:"Return"},pa:65,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Return"},{mt:"tp",nm:"Args"}],nm:"Callable"},mt:"prm",nm:"flatFunction"}],[{$t:{nm:"Args"},mt:"prm",nm:"args"}]],mt:"m",tp:[{nm:"Return"},{sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"Anything"}],nm:"Sequential"}],nm:"Args"}],an:{see:["flatten"],tagged:["Functions"],doc:["Given a function with parameter types `P1`, `P2`, ..., `Pn`, \nreturn a function with a single parameter of tuple type \n`[P1, P2, ..., Pn]`.\n\nThat is, if `fun` has type `W(X,Y,Z)` then `unflatten(fun)` \nhas type `W([X,Y,Z])`.\n\nIn the case of a variadic function, the returned function \nhas a single parameter whose type is a sequence type or \nunterminated tuple type:\n\n- if the given function has a single variadic parameter of \n  type `S*`, the returned function accepts `[S*]`,\n- if the given function has a single variadic parameter of \n  type `S+`, the returned function accepts `[S+]`,\n- if the given function has multiple parameters with types\n  `P1`, `P2`, ..., `Pn`, `S*`, the returned function \n  accepts `[P1, P2, ..., Pn, S*]`, or\n- if the given function has multiple parameters with types\n  `P1`, `P2`, ..., `Pn`, `S+`, the returned function \n  accepts `[P1, P2, ..., Pn, S+]`."]},nm:"unflatten"},Iterator:{pa:1,mt:"i",$m:{next:{$t:{comp:"u",l:[{nm:"Element"},{pk:".",nm:"Finished"}]},pa:5,mt:"m",an:{doc:["The next element, or [[finished]] if there are no more \nelements to be iterated.\n\nRepeated invocations of `next()` for a given iterator\nmust eventually produce any given element of the stream\nto which the iterator belongs. A given iterator must\nnot produce the same element of the stream more often\nthan the element occurs in the stream.\n\nIf an invocation of `next()` for a given iterator \nproduces the value `finished`, then every future \ninvocation of `next()` for that iterator must also\nproduce the value `finished`.\n\nAn iterator for a nonfinite stream may never produce\nthe value `finished`."]},nm:"next"}},tp:[{dv:"out",nm:"Element"}],an:{see:["Iterable"],tagged:["Streams"],by:["Gavin"],doc:["Produces the elements of an [[Iterable]] object. For \nexample, this class has an `Iterator` that produces the \nintegers from `min` to `max`:\n\n    class IntegerIterable(Integer min, Integer max) \n           satisfies {Integer+} {\n       iterator() => object satisfies Iterator<Integer> {\n           variable value i = min;\n           next() => i<=max then i++ else finished;\n       };\n    }\n\nAn iterator is _exhausted_ when [[next]] produces the \nvalue [[finished]]."]},nm:"Iterator"},every:{$t:{pk:".",nm:"Boolean"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Boolean"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"values"}]],mt:"m",an:{see:["any","Iterable.every"],tagged:["Streams"],doc:["Determines if every one of the given boolean values \n(usually a comprehension) is `true`.\n\n    Boolean allPositive = every { for (x in xs) x>0.0 };\n\nIf there are no boolean values, return `true`."]},nm:"every"},parseIntegerExponent:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"char"}]],mt:"m",nm:"parseIntegerExponent"},apply:{$t:{nm:"Return"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Return"},{mt:"tp",nm:"Args"}],nm:"Callable"},mt:"prm",nm:"f"},{$t:{nm:"Args"},mt:"prm",nm:"args"}]],mt:"m",tp:[{nm:"Return"},{sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"Anything"}],nm:"Sequential"}],nm:"Args"}],an:{see:["unflatten"],tagged:["Functions"],doc:["Applies an arbitrary [[Callable]] to the given \n[[arguments|args]]. The arguments must be packaged into a \n[[Tuple]] whose type is compatible with the `Callable` type. \n\nFor example, given the following argument tuple:\n\n     [Boolean(Character), Boolean, Boolean] tuple\n         = [Character.whitespace, true, false];\n\nWe can apply [[String.split]] to the arguments given in\n`tuple` as follows:\n\n    String string = ... ;\n    {String*} strings = apply(string.split, tuple);\n\nApplication may be abbreviated using the spread operator:\n\n    String string = ... ;\n    {String*} strings = string.split(*tuple)\n\nIn practice, this behaves as if the `Callable` were called \nwith the elements of the tuple as its arguments. The\nexamples above are both equivalent to:\n\n    string.split(Character.whitespace, true, false)"]},nm:"apply"},false:{super:{pk:".",nm:"Boolean"},pa:65,mt:"o",$at:{string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"}},an:{tagged:["Basic types"],doc:["A value representing falsity in Boolean logic."]},nm:"false"},suppressWarnings:{$t:{pk:".",nm:"SuppressWarningsAnnotation"},pa:513,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"String"}],nm:"Sequential"},mt:"prm",an:{doc:["The warning types to suppress.\n\nAllowed warning types are:\n`filenameNonAscii`,\n`filenameCaselessCollision`,\n`deprecation`,\n`compilerAnnotation`,\n`doclink`,\n`expressionTypeNothing`,\n`unusedDeclaration`,\n`unusedImport`,\n`ceylonNamespace`,\n`javaNamespace,` \n`suppressedAlready`, \n`suppressesNothing`, \n`unknownWarning`, \n`ambiguousAnnotation`,\n`javaAnnotationElement`."]},seq:1,nm:"warnings"}]],mt:"m",an:{doc:["Annotation to suppress compilation warnings of the \n[[specified types|warnings]] when typechecking the \nannotated program element."]},nm:"suppressWarnings"},equal:{super:{pk:".",nm:"Comparison"},pa:1,mt:"o",$at:{reversed:{$t:{pk:".",nm:"Comparison"},pa:3,mt:"g",nm:"reversed"}},an:{tagged:["Comparisons"],doc:["The value is exactly equal to the given value."]},nm:"equal"},Integer:{super:{pk:".",nm:"Object"},pa:97,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"}],nm:"Integral"},{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"}],nm:"Binary"},{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",pk:".",nm:"Integer"}],nm:"Exponentiable"}],ps:[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"integer"}],mt:"c",$at:{nearestFloat:{$t:{pk:".",nm:"Float"},pa:65,mt:"a",an:{doc:["The nearest [[Float]] to this number. \n\n- For any integer with [[magnitude]] smaller than \n  [[runtime.maxExactIntegralFloat]] (2<sup>53<\/sup>), \n  this is a `Float` with the exact same mathematical \n  value (and the same value as [[float]]). \n- For larger integers on the JVM platform, the `Floats` \n  are less dense than the `Integers` so there may be \n  loss of precision.\n\nThis method never throws an [[OverflowException]]."]},nm:"nearestFloat"},negated:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"negated"},successor:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"successor"},string:{$t:{pk:".",nm:"String"},pa:67,mt:"a",an:{see:["formatInteger"]},nm:"string"},byte:{$t:{pk:".",nm:"Byte"},pa:65,mt:"a",an:{doc:["A [[Byte]] whose [[signed|Byte.signed]] and\n[[unsigned|Byte.unsigned]] interpretations are \ncongruent modulo 256 to this integer."]},nm:"byte"},sign:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"sign"},predecessor:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"predecessor"},positive:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"a",nm:"positive"},float:{$t:{pk:".",nm:"Float"},pa:65,mt:"a",an:{see:["runtime.maxExactIntegralFloat"],doc:["The number, represented as a [[Float]], if such a \nrepresentation is possible. \n\n- Any integer with [[magnitude]] smaller than \n  [[runtime.maxExactIntegralFloat]] (2<sup>53<\/sup>) \n  has such a representation.\n- For larger integers on the JVM platform, an \n  [[OverflowException]] is thrown."],throws:["OverflowException","if the number cannot be represented as a `Float`\nwithout loss of precision, that is, if \n\n    this.magnitude>runtime.maxExactIntegralFloat"]},nm:"float"},integer$woput0:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"integer"},zero:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"a",nm:"zero"},character:{$t:{pk:".",nm:"Character"},pa:65,mt:"a",an:{doc:["The UTF-32 character with this UCS code point."],throws:["OverflowException","if this integer is not in the range \n`0..#10FFFF` of legal Unicode code points"]},nm:"character"},not:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"not"},unit:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"a",nm:"unit"},negative:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"a",nm:"negative"},wholePart:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"wholePart"},even:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"g",an:{doc:["Determine if this integer is even.\n\nAn integer `i` is even if there exists an integer `k` \nsuch that:\n\n    i == 2*k\n\nThus, `i` is even if and only if `i%2 == 0`."]},nm:"even"},magnitude:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",an:{aliased:["absolute"]},nm:"magnitude"},hash:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"hash"},fractionalPart:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"fractionalPart"}},$m:{minus:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],mt:"m",nm:"minus"},largerThan:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],mt:"m",nm:"largerThan"},compare:{$t:{pk:".",nm:"Comparison"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],mt:"m",nm:"compare"},divided:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],mt:"m",nm:"divided"},neighbour:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"offset"}]],mt:"m",nm:"neighbour"},times:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],mt:"m",nm:"times"},offsetSign:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],mt:"m",nm:"offsetSign"},notLargerThan:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],mt:"m",nm:"notLargerThan"},divides:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],mt:"m",nm:"divides"},and:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],mt:"m",nm:"and"},get:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",an:{doc:["If the `index` is for an addressable bit, the value of \nthat bit. Otherwise false."]},nm:"get"},xor:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],mt:"m",nm:"xor"},power:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["The result of raising this number to the given \nnon-negative integer power, where `0^0` evaluates to \n`1`."],throws:["AssertionError","if the given [[power|other]] is negative"]},nm:"power"},leftLogicalShift:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"shift"}]],mt:"m",an:{doc:["If shift is in the range of addressable bits \n(`0..runtime.integerAddressableSize-1`), shift the \naddressable bits to the left by `shift` positions.\nOtherwise shift the addressable bits to the left by \n`(bits + (shift % bits)) % bits` where \n`bits=runtime.integerAddressableSize`."]},nm:"leftLogicalShift"},flip:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",an:{doc:["If the `index` is for an addressable bit, an instance \nwith the same addressable bits as this instance, but \nwith that bit flipped. Otherwise an instance with the \nsame addressable bits as this instance."]},nm:"flip"},plusInteger:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"integer"}]],mt:"m",nm:"plusInteger"},smallerThan:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],mt:"m",nm:"smallerThan"},set:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"},{$t:{pk:".",nm:"Boolean"},def:1,mt:"prm",nm:"bit"}]],mt:"m",an:{doc:["If the `index` is for an addressable bit, an instance \nwith the same addressable bits as this instance, but \nwith that bit set to `bit`. Otherwise an instance with \nthe same addressable bits as this instance."]},nm:"set"},or:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],mt:"m",nm:"or"},offset:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],mt:"m",nm:"offset"},clear:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",an:{doc:["If the `index` is for an addressable bit, an instance \nwith the same addressable bits as this instance, but \nwith that bit cleared. Otherwise an instance with the \nsame addressable bits as this instance."]},nm:"clear"},rightLogicalShift:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"shift"}]],mt:"m",an:{doc:["If shift is in the range of addressable bits \n(`0..runtime.integerAddressableSize-1`), shift the \naddressable bits to the right by `shift` positions, \nwith zero extension. Otherwise shift the addressable \nbits to the right by `(bits + (shift % bits)) % bits` \nwhere `bits=runtime.integerAddressableSize`."]},nm:"rightLogicalShift"},plus:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],mt:"m",nm:"plus"},rightArithmeticShift:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"shift"}]],mt:"m",an:{doc:["If shift is in the range of addressable bits \n(`0..runtime.integerAddressableSize-1`), shift the \naddressable bits to the right by `shift` positions, \nwith sign extension. Otherwise shift the addressable \nbits to the right by `(bits + (shift % bits)) % bits` \nwhere `bits=runtime.integerAddressableSize`."]},nm:"rightArithmeticShift"},equals:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],mt:"m",an:{doc:["Determines if the given object is equal to this `Integer`,\nthat is, if:\n\n- the given object is an `Integer` representing the \n  same whole number.\n\nOr if:\n\n- the given object is a [[Float]],\n- its value is neither [[Float.undefined]], nor \n  [[infinity]],\n- the [[fractional part|Float.fractionalPart]] of its \n  value equals `0.0`, and\n- the [[integer part|Float.integer]] part of its value \n  equals this integer, and\n- this integer is between -2<sup>53<\/sup> and \n  2<sup>53<\/sup> (exclusive)."]},nm:"equals"},remainder:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],mt:"m",nm:"remainder"},modulo:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"modulus"}]],mt:"m",nm:"modulo"},powerOfInteger:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"integer"}]],mt:"m",an:{doc:["The result of raising this number to the given \nnon-negative integer power, where `0^0` evaluates to \n`1`."],throws:["AssertionError","if the given [[power|integer]] is negative"]},nm:"powerOfInteger"},timesInteger:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"integer"}]],mt:"m",nm:"timesInteger"},notSmallerThan:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],mt:"m",nm:"notSmallerThan"}},an:{see:["runtime.integerSize","parseInteger","formatInteger"],tagged:["Basic types","Numbers"],doc:["An exact representation of a positive whole number, \nnegative whole number, or zero. The largest and smallest \nrepresentable values are platform-dependent:\n\n- For the JVM runtime, integer values between\n  -2<sup>63<\/sup> and 2<sup>63<\/sup>-1 may be represented \n  without overflow.\n- For the JavaScript runtime, integer values with a\n  magnitude no greater than 2<sup>53<\/sup> may be\n  represented without loss of precision.\n\nOverflow or loss of precision occurs silently (with no \nexception raised).\n\nAn integer is considered equal to its [[float]] \nrepresentation, if that exists. That is, for every integer \n`int`, either `int.float` throws an [[OverflowException]], \nor the expression `int.float==int` evaluates to `true`.\n\nAn integer is represented as a sequence of bits. Not all of \nthe bits in the representation may be addressed by the \nmethods inherited from [[Binary]]:\n\n- For the JVM runtime, the bits at all indices (0 to 63) \n  are addressable.\n- For the JavaScript runtime, the bits at indices 0 to 31 \n  are addressable.\n\nLiteral integers may be written in decimal, hexadecimal, or\nbinary notation:\n\n    8660\n    #21D4\n    $10000111010100\n\nUnderscores may be used to group digits:\n\n    8660\n    #21_D4\n    $10_0001_1101_0100"]},nm:"Integer"},AbstractAnnotation:{super:{pk:".",nm:"Basic"},pa:561,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"AbstractAnnotation"},{comp:"u",mt:"tp",l:[{pk:"ceylon.language.meta.declaration",nm:"ClassDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ConstructorDeclaration"}]},{mt:"tp",pk:".",nm:"Anything"}],nm:"OptionalAnnotation"}],mt:"c",an:{doc:["The annotation class for the [[abstract]] annotation."]},nm:"AbstractAnnotation"},forItem:{$t:{nm:"Result"},pa:1,ps:[[{$t:{nm:"Result"},ps:[[{$t:{nm:"Item"},mt:"prm",nm:"item"}]],mt:"prm",$pt:"f",nm:"resulting"}],[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Object"},{mt:"tp",nm:"Item"}],nm:"Entry"},mt:"prm",nm:"entry"}]],mt:"m",tp:[{nm:"Item"},{nm:"Result"}],an:{see:["forKey"],tagged:["Functions"],doc:["A function that returns the result of applying the given \n[[function|resulting]] to the [[item|Entry.item]] \nof a given [[Entry]], discarding its `key`.\n    \n    Map<String,List<Item>> map = ... ;\n    {Item?*} topItems = map.map(forItem(List<Item>.first));"]},nm:"forItem"},print:{$t:{pk:".",nm:"Anything"},pa:1,ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",nm:"val"}]],$ff:1,mt:"m",an:{see:["process.writeLine"],tagged:["Environment"],by:["Gavin"],doc:["Print a line to the standard output of the virtual machine \nprocess, printing the given value's `string`, or `<null>` \nif the value is `null`.\n\nThis function is a shortcut for:\n\n    process.writeLine(line?.string else \"<null>\")\n\nand is intended mainly for debugging purposes."]},nm:"print"},increasingItem:{$t:{pk:".",nm:"Comparison"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Object"},{mt:"tp",nm:"Item"}],nm:"Entry"},mt:"prm",nm:"x"},{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Object"},{mt:"tp",nm:"Item"}],nm:"Entry"},mt:"prm",nm:"y"}]],mt:"m",tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Item"}],nm:"Comparable"}],nm:"Item"}],an:{tagged:["Comparisons"],doc:["A comparator function which orders [[entries|Entry]] by \nincreasing [[natural order|Comparable]] of their \n[[items|Entry.item]].\n       \nThis function is intended for use with [[Iterable.sort]]\nand [[Iterable.max]]."]},nm:"increasingItem"},"$pkg-anns":{by:["Gavin King","Tom Bentley","Tako Schotanus","Stephane Epardaud","Enrique Zamudio"],doc:["The root package of the Ceylon language module, functioning\nas the core of the [Ceylon platform][sdk], and covering the \nfollowing areas of functionality:\n\n- the foundational types [[Anything]], [[Object]], and \n  [[Null]], and a [[logical boolean|Boolean]] type,\n- abstractions of [[numeric|Numeric]] types, along with\n  basic types representing [[integral|Integer]] and \n  [[floating point|Float]] values,\n- [[characters|Character]] and [[character strings|String]],\n- [[unsigned bytes|Byte]],\n- support for functional programming with \n  [[streams|Iterable]],\n- abstract interfaces for unmodifiable [[lists|List]],\n  [[sets|Set]], and [[maps|Map]],\n- a low-level abstraction of native [[arrays|Array]],\n- immutable [[sequences|Sequential]], [[ranges|Range]], and\n  [[tuples|Tuple]], which provide the foundation for \n  representing [[function types|Callable]] and lists of\n  function arguments,\n- generic higher-order functions, including for function \n  [[composition|compose]] and [[partial application|curry]],\n- [[exceptions|Throwable]] and support for management of\n  heavyweight [[destroyable|Destroyable]] and \n  [[obtainable|Obtainable]] objects,\n- support for loading [[resources|Resource]] packaged with\n  a module,\n- access to information about the current \n  [[virtual machine|runtime]], [[system|system]],\n  [[process]], and [[operating system|system]], and\n- support for definition of [[annotations|Annotation]].\n\nFinally, this module defines the [[most useful and\ninteresting void function of all time ever|print]].\n\nDeclarations belonging to this package need not be \nexplicitly imported by other source files.\n\n[sdk]: https:\/\/modules.ceylon-lang.org\/categories\/SDK"]},DocAnnotation:{super:{pk:".",nm:"Basic"},pa:561,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"DocAnnotation"},{mt:"tp",pk:".",nm:"Annotated"},{mt:"tp",pk:".",nm:"Anything"}],nm:"OptionalAnnotation"}],ps:[{$t:{pk:".",nm:"String"},pa:1,mt:"prm",an:{doc:["Documentation, in Markdown syntax, about the annotated \nprogram element"]},nm:"description"}],mt:"c",$at:{description:{$t:{pk:".",nm:"String"},pa:1,mt:"a",an:{doc:["Documentation, in Markdown syntax, about the annotated \nprogram element"]},nm:"description"}},an:{doc:["The annotation class for the [[doc]] annotation."]},nm:"DocAnnotation"},smaller:{super:{pk:".",nm:"Comparison"},pa:1,mt:"o",$at:{reversed:{$t:{pk:".",nm:"Comparison"},pa:3,mt:"g",nm:"reversed"}},an:{tagged:["Comparisons"],doc:["The value is smaller than the given value."]},nm:"smaller"},deprecated:{$t:{pk:".",nm:"DeprecationAnnotation"},pa:513,ps:[[{$t:{pk:".",nm:"String"},def:1,mt:"prm",an:{doc:["A description, in Markdown syntax, of why the program \nelement is deprecated, and what alternatives are \navailable."]},nm:"reason"}]],mt:"m",an:{doc:["Annotation to mark program elements which should not be \nused anymore."]},nm:"deprecated"},operatingSystem:{super:{pk:".",nm:"Basic"},pa:65,mt:"o",$at:{newline:{$t:{pk:".",nm:"String"},pa:65,mt:"a",an:{doc:["The line ending character sequence on this platform."]},nm:"newline"},pathSeparator:{$t:{pk:".",nm:"String"},pa:65,mt:"g",an:{doc:["The character used on this platform to use as a \nseparator between several paths in a list of paths."]},nm:"pathSeparator"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},name:{$t:{pk:".",nm:"String"},pa:65,mt:"g",an:{doc:["Returns the name of the operating system this process is\nrunning on: `linux`, `mac`, `unix`, `windows` or `other`."]},nm:"name"},fileSeparator:{$t:{pk:".",nm:"String"},pa:65,mt:"g",an:{doc:["The character used on this platform to separate the \nfolder\/file elements of a path."]},nm:"fileSeparator"},version:{$t:{pk:".",nm:"String"},pa:65,mt:"g",an:{doc:["Returns the version of the operating system this \nprocess is running on or `Unknown` if it was not\npossible to retrieve that information. The result\nis completely dependent on the underlying system."]},nm:"version"}},an:{see:["process","runtime","language","system"],tagged:["Environment"],doc:["Represents the operating system on which the current \nprocess is running."]},nm:"operatingSystem"},mapPairs:{$t:{pk:".",tp:[{mt:"tp",nm:"Result"},{comp:"u",mt:"tp",l:[{nm:"FirstAbsent"},{nm:"SecondAbsent"}]}],nm:"Iterable"},pa:1,ps:[[{$t:{nm:"Result"},ps:[[{$t:{nm:"First"},mt:"prm",nm:"first"},{$t:{nm:"Second"},mt:"prm",nm:"second"}]],mt:"prm",$pt:"f",an:{doc:["The mapping function to apply to the pair of elements."]},nm:"collecting"},{$t:{pk:".",tp:[{mt:"tp",nm:"First"},{mt:"tp",nm:"FirstAbsent"}],nm:"Iterable"},mt:"prm",nm:"firstIterable"},{$t:{pk:".",tp:[{mt:"tp",nm:"Second"},{mt:"tp",nm:"SecondAbsent"}],nm:"Iterable"},mt:"prm",nm:"secondIterable"}]],mt:"m",$m:{collecting$tyqi0b:{$t:{nm:"Result"},ps:[[{$t:{nm:"First"},mt:"prm",nm:"first"},{$t:{nm:"Second"},mt:"prm",nm:"second"}]],mt:"m",an:{doc:["The mapping function to apply to the pair of elements."]},nm:"collecting"}},$o:{iterable$x16jqt:{super:{pk:".",nm:"Basic"},sts:[{pk:".",tp:[{mt:"tp",nm:"Result"},{comp:"u",mt:"tp",l:[{nm:"FirstAbsent"},{nm:"SecondAbsent"}]}],nm:"Iterable"}],mt:"o",$m:{iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Result"}],nm:"Iterator"},pa:3,mt:"m",$o:{iterator$5i9ypz:{super:{pk:".",nm:"Basic"},sts:[{pk:".",tp:[{mt:"tp",nm:"Result"}],nm:"Iterator"}],mt:"o",$at:{firstIter$ruc02k:{$t:{pk:".",tp:[{mt:"tp",nm:"First"}],nm:"Iterator"},mt:"a",nm:"firstIter"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},secondIter$6wrzi8:{$t:{pk:".",tp:[{mt:"tp",nm:"Second"}],nm:"Iterator"},mt:"a",nm:"secondIter"}},$m:{next:{$t:{comp:"u",l:[{nm:"Result"},{pk:".",nm:"Finished"}]},pa:3,mt:"m",nm:"next"}},nm:"iterator"}},nm:"iterator"}},nm:"iterable"}},tp:[{nm:"Result"},{nm:"First"},{nm:"Second"},{sts:[{pk:".",nm:"Null"}],nm:"FirstAbsent"},{sts:[{pk:".",nm:"Null"}],nm:"SecondAbsent"}],an:{tagged:["Streams"],doc:["Given two streams, form a new stream by applying a binary\n[[mapping function|collecting]] to pairs of elements in the \ngiven streams.  If one of the streams is longer than the \nother, simply ignore additional elements of the longer \nstream with no pair in the other stream. The length of the \nresulting stream is the length of the shorter of the two \ngiven streams.\n\nFor any given streams `xs` and `ys`, and mapping function \n`f`, `mapPairs()` may be defined in terms of \n[[Iterable.map]], [[zipPairs]], and [[unflatten]]:\n\n    mapPairs(f, xs, ys) == zipPairs(xs, ys).map(unflatten(f))\n\nFor example the expression\n\n    mapPairs((Float x, Float y) => (x^2+y^2)^0.5, \n            {1.0, 2.0, 1.0}, {1.0, 1.0, 2.0})\n    \nevaluates to the stream `{ 1.0, 3.0, 3.0 }`."]},nm:"mapPairs"},Numeric:{st:"Other",pa:1,sts:[{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Invertible"}],mt:"i",of:[{nm:"Other"}],$m:{times:{$t:{nm:"Other"},pa:5,ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["The product of this number and the given number."]},nm:"times"},divided:{$t:{nm:"Other"},pa:5,ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],mt:"m",an:{see:["Integral.remainder","infinity"],doc:["The quotient obtained by dividing this number by the \ngiven number. For integral numeric types, this \noperation results in a \n[[remainder|Integral.remainder]].\n\nWhen the given number is `0`, the additive identity,\nthe behavior depends on the numeric type:\n\n- For some numeric types, including [[Integer]], \n  division by `0` results in an exception.\n- For others, including [[Float]], it results in a \n  special value of the type, for example, [[infinity]]."]},nm:"divided"}},tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Numeric"}],nm:"Other"}],an:{see:["Number"],tagged:["Numbers"],by:["Gavin"],doc:["Abstraction of numeric types with the usual binary \noperations:\n\n- addition, `x + y`, \n- subtraction, `x - y`, \n- multiplication, `x * y`, and \n- division, `x \/ y`, along with \n- additive inverse `-x`.\n\nA concrete class which implements this interface should be\na mathematical _ring_. That is:\n\n- both addition, `+`, and multiplication, `*`, should be\n  associative and commutative,\n- there should be additive and multiplicative identities,\n  denoted `0` and `1` respectively, satisfying `x+0 == x`\n  and `x*1 == x`,\n- every instance `x` should have an additive inverse `-x`, \n  satisfying `x + -x == 0`, and\n- multiplication should distribute over addition, \n  satisfying `x*(y+z) == x*y + x*z`.\n\nIt is preferred, but not required, that the class be a\nmathematical _field_. That is, in addition to the above:\n\n- every instance `x` such that `x!=0` should have a \n  multiplicative inverse `1\/x`, satisfying `x * 1\/x == 1`. \n\nFor numeric types which are not fields, for example, \n[[Integer]], there is still a division operation, which is\nunderstood to produce a [[remainder|Integral.remainder]].\nThe division operation should satisfy:\n\n- `x*y \/ y == x`\n\nfor any instance `y` other than `0`.\n\nFor numeric types which _are_ fields, division never\nproduces a remainder, and division should additionally \nsatisfy:\n\n- `x\/y * y == x`\n\nfor any instance `y` other than `0`.\n\nSome numeric types, for example complex numbers, do not \nhave a [[total order|Comparable]]. Numeric types with a \ntotal order also satisfy [[Number]]."]},nm:"Numeric"},byKey:{$t:{pk:".",nm:"Comparison"},pa:1,ps:[[{$t:{pk:".",nm:"Comparison"},ps:[[{$t:{nm:"Key"},mt:"prm",nm:"x"},{$t:{nm:"Key"},mt:"prm",nm:"y"}]],mt:"prm",$pt:"f",nm:"comparing"}],[{$t:{pk:".",tp:[{mt:"tp",nm:"Key"},{mt:"tp",pk:".",nm:"Object"}],nm:"Entry"},mt:"prm",nm:"x"},{$t:{pk:".",tp:[{mt:"tp",nm:"Key"},{mt:"tp",pk:".",nm:"Object"}],nm:"Entry"},mt:"prm",nm:"y"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Key"}],an:{see:["byItem"],tagged:["Comparisons"],doc:["A comparator for [[Entry]]s which compares their keys \naccording to the given [[comparing]] function.\n\n    value sortedEntries = map.sort(byKey(byIncreasing(String.lowercased)));\n\nThis function is intended for use with [[Iterable.sort]]\nand [[Iterable.max]]."]},nm:"byKey"},uncurry:{$t:{pk:".",tp:[{mt:"tp",nm:"Return"},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Argument"},{mt:"tp",nm:"First"},{mt:"tp",nm:"Rest"}],nm:"Tuple"}],nm:"Callable"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Return"},{mt:"tp",nm:"Rest"}],nm:"Callable"},ps:[[{$t:{nm:"First"},mt:"prm",nm:"first"}]],mt:"prm",$pt:"f",nm:"f"}]],mt:"m",tp:[{nm:"Return"},{nm:"Argument"},{sts:[{nm:"Argument"}],nm:"First"},{sts:[{pk:".",tp:[{mt:"tp",nm:"Argument"}],nm:"Sequential"}],nm:"Rest"}],an:{see:["curry","compose"],tagged:["Functions"],doc:["Uncurries a function, returning a function with one \nparameter list, given a function with two parameter lists, \nwhere the first parameter list has exactly one parameter. \nThe parameter list of the returned function has the \nparameter of the first parameter list of the original\nfunction, followed by all parameters of the second \nparameter list.\n\nThat is, if `fun` has type `W(Y,Z)(X)` then `uncurry(fun)` \nhas type `W(X,Y,Z)`."]},nm:"uncurry"},Ordinal:{st:"Other",pa:1,mt:"i",of:[{nm:"Other"}],$at:{successor:{$t:{nm:"Other"},pa:5,mt:"a",an:{doc:["The successor of this value."]},nm:"successor"},predecessor:{$t:{nm:"Other"},pa:5,mt:"a",an:{doc:["The predecessor of this value."]},nm:"predecessor"}},tp:[{dv:"out",sts:[{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Ordinal"}],nm:"Other"}],an:{see:["Character","Integer","Integral","Comparable","Enumerable"],tagged:["Numbers"],by:["Gavin"],doc:["Abstraction of _ordinal types_, that is, of types where \neach instance has a [[successor]] and [[predecessor]], such \nas:\n \n- types which represent or are isomorphic to the \n  mathematical integers, for example, [[Integer]] and other \n  [[Integral]] numeric types, and even [[Character]], along \n  with\n- enumerated types which are isomorphic to the mathematical\n  integers under modular arithmetic, for example, the days\n  of the week, and\n- enumerated types which are isomorphic to a bounded range \n  of integers, for example, a list of priorities.\n\nThe _increment_ operator `++` and _decrement_ operator `--`\nare defined for all types which satisfy `Ordinal`.\n\n    function increment() {\n        count++;\n    }\n\nMany ordinal types have a [[total order|Comparable]]. If an\nordinal type has a total order, then it should satisfy:\n\n- `x.successor >= x`, and\n- `x.predecessor <= x`.\n\nAn ordinal enumerated type `X` with a total order has \nwell-defined `maximum` and `minimum` values where\n`minimum<x<maximum` for any other instance `x` of `X`.\nThen the `successor` and `predecessor` operations should\nsatisfy:\n\n- `minimum.predecessor==minimum`, and\n- `maximum.successor==maximum`."]},nm:"Ordinal"},decreasingKey:{$t:{pk:".",nm:"Comparison"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Key"},{mt:"tp",pk:".",nm:"Anything"}],nm:"Entry"},mt:"prm",nm:"x"},{$t:{pk:".",tp:[{mt:"tp",nm:"Key"},{mt:"tp",pk:".",nm:"Anything"}],nm:"Entry"},mt:"prm",nm:"y"}]],mt:"m",tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Key"}],nm:"Comparable"}],nm:"Key"}],an:{tagged:["Comparisons"],doc:["A comparator function which orders [[entries|Entry]] by \ndecreasing [[natural order|Comparable]] of their \n[[keys|Entry.key]].\n       \nThis function is intended for use with [[Iterable.sort]]\nand [[Iterable.max]]."]},nm:"decreasingKey"},foldPairs:{$t:{nm:"Result"},pa:1,ps:[[{$t:{nm:"Result"},mt:"prm",nm:"initial"},{$t:{nm:"Result"},ps:[[{$t:{nm:"Result"},mt:"prm",nm:"partial"},{$t:{nm:"First"},mt:"prm",nm:"first"},{$t:{nm:"Second"},mt:"prm",nm:"second"}]],mt:"prm",$pt:"f",an:{doc:["The accumulating function to apply to each pair of \nelements."]},nm:"accumulating"},{$t:{pk:".",tp:[{mt:"tp",nm:"First"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"firstIterable"},{$t:{pk:".",tp:[{mt:"tp",nm:"Second"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"secondIterable"}]],mt:"m",$m:{accumulating$wxcgon:{$t:{nm:"Result"},ps:[[{$t:{nm:"Result"},mt:"prm",nm:"partial"},{$t:{nm:"First"},mt:"prm",nm:"first"},{$t:{nm:"Second"},mt:"prm",nm:"second"}]],mt:"m",an:{doc:["The accumulating function to apply to each pair of \nelements."]},nm:"accumulating"}},tp:[{nm:"Result"},{nm:"First"},{nm:"Second"}],an:{tagged:["Streams"],doc:["Given two streams, return the result of applying the given \n[[accumulating function|accumulating]] to each pair of \nelements of the given streams in turn. If one of the \nstreams is longer than the other, simply ignore additional \nelements of the longer stream with no pair in the other \nstream.\n\nFor any given streams `xs` and `ys`, initial value `z`, and\ncombining function `f`, `foldPairs()` may be defined in \nterms of [[Iterable.fold]], [[zipPairs]], and [[unflatten]]:\n\n    foldPairs(z, f, xs, ys) == zipPairs(xs, ys).fold(z)(unflatten(f))"]},nm:"foldPairs"},Boolean:{super:{pk:".",nm:"Basic"},pa:321,mt:"c",of:[{pk:".",nm:"true"},{pk:".",nm:"false"}],an:{see:["parseBoolean"],tagged:["Basic types"],by:["Gavin"],doc:["A type capable of representing the values [[true]] and\n[[false]] of Boolean logic."]},nm:"Boolean"},FormalAnnotation:{super:{pk:".",nm:"Basic"},pa:561,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"FormalAnnotation"},{comp:"u",mt:"tp",l:[{pk:"ceylon.language.meta.declaration",nm:"FunctionDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ValueDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ClassOrInterfaceDeclaration"}]},{mt:"tp",pk:".",nm:"Anything"}],nm:"OptionalAnnotation"}],mt:"c",an:{doc:["The annotation class for the [[formal]] annotation."]},nm:"FormalAnnotation"},zip:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Head"}]},{mt:"tp",nm:"Head"},{mt:"tp",nm:"Tail"}],nm:"Tuple"},{comp:"u",mt:"tp",l:[{nm:"HeadAbsent"},{nm:"TailAbsent"}]}],nm:"Iterable"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Head"},{mt:"tp",nm:"HeadAbsent"}],nm:"Iterable"},mt:"prm",nm:"heads"},{$t:{pk:".",tp:[{mt:"tp",nm:"Tail"},{mt:"tp",nm:"TailAbsent"}],nm:"Iterable"},mt:"prm",nm:"tails"}]],mt:"m",tp:[{nm:"Element"},{nm:"Head"},{sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"}],nm:"Tail"},{sts:[{pk:".",nm:"Null"}],nm:"HeadAbsent"},{sts:[{pk:".",nm:"Null"}],nm:"TailAbsent"}],an:{tagged:["Streams"],doc:["Given a stream of values, and a stream of [[tuples|Tuple]], \nproduce a new stream of tuples formed by prepending the \nvalues in the [[first stream|heads]] to the tuples in the \n[[second stream|tails]]. The length of the resulting stream \nis the length of the shorter of the two given streams.\n\nThus:\n\n    zip(heads, tails)[i] == [heads[i], *tails[i]]\n\nfor every `0<=i<smallest(heads.size,tails.size)`."]},nm:"zip"},Finished:{super:{pk:".",nm:"Basic"},pa:257,mt:"c",of:[{pk:".",nm:"finished"}],an:{see:["Iterator"],tagged:["Streams"],doc:["The type of the value that indicates that an [[Iterator]] \nis exhausted and has no more values to return."]},nm:"Finished"},LicenseAnnotation:{super:{pk:".",nm:"Basic"},pa:561,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"LicenseAnnotation"},{mt:"tp",pk:"ceylon.language.meta.declaration",nm:"Module"},{mt:"tp",pk:".",nm:"Anything"}],nm:"OptionalAnnotation"}],ps:[{$t:{pk:".",nm:"String"},pa:1,mt:"prm",an:{doc:["The name, text, or URL of the license."]},nm:"description"}],mt:"c",$at:{description:{$t:{pk:".",nm:"String"},pa:1,mt:"a",an:{doc:["The name, text, or URL of the license."]},nm:"description"}},an:{doc:["The annotation class for the [[license]] annotation."]},nm:"LicenseAnnotation"},"$pkg-pa":1,anyPair:{$t:{pk:".",nm:"Boolean"},pa:1,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"First"},mt:"prm",nm:"first"},{$t:{nm:"Second"},mt:"prm",nm:"second"}]],mt:"prm",$pt:"f",an:{doc:["The binary predicate function to apply to each pair of \nelements."]},nm:"selecting"},{$t:{pk:".",tp:[{mt:"tp",nm:"First"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"firstIterable"},{$t:{pk:".",tp:[{mt:"tp",nm:"Second"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"secondIterable"}]],mt:"m",$m:{selecting$hn51wc:{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"First"},mt:"prm",nm:"first"},{$t:{nm:"Second"},mt:"prm",nm:"second"}]],mt:"m",an:{doc:["The binary predicate function to apply to each pair of \nelements."]},nm:"selecting"}},tp:[{nm:"First"},{nm:"Second"}],an:{see:["everyPair"],tagged:["Streams"],doc:["Given two streams, return `true` if some pair of elements \nin the given streams satisfies the given binary [[predicate\nfunction|selecting]], or `false` otherwise. If one of the\nstreams is longer than the other, simply ignore additional \nelements of the longer stream with no pair in the other \nstream. If either stream is empty, return `false`.\n\nFor any given streams `xs` and `ys`, and predicate function \n`p`, `anyPair()` may be defined in terms of \n[[Iterable.any]], [[zipPairs]], and [[unflatten]]:\n\n    anyPair(p, xs, ys) == zipPairs(xs, ys).any(unflatten(p))"]},nm:"anyPair"},nothing:{$t:{pk:".",nm:"Nothing"},pa:1,mt:"g",an:{tagged:["Basic types"],doc:["A value getter of type `Nothing`. The expression `nothing`\nis formally assignable to any type, but produces an \nexception when evaluated.\n\n(This is most useful for tool-generated implementations of\n`formal` members.)"],throws:["AssertionError","when evaluated"]},nm:"nothing"},formatFloat:{$t:{pk:".",nm:"String"},pa:1,ps:[[{$t:{pk:".",nm:"Float"},mt:"prm",an:{doc:["The floating point value to format."]},nm:"float"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The minimum number of allowed decimal places.\n\nIf `minDecimalPlaces<=0`, the result may have no\ndecimal point."]},nm:"minDecimalPlaces"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The maximum number of allowed decimal places.\n\nIf `maxDecimalPlaces<=0`, the result always has no\ndecimal point."]},nm:"maxDecimalPlaces"}]],mt:"m",an:{see:["formatInteger","parseFloat"],tagged:["Numbers"],doc:["The string decimal representation of the given \n[[floating point number|float]]. If the given number is \n[[negative|Float.negative]], the string representation will \nbegin with `-`. The [[whole part|Float.wholePart]] and \n[[fractional parts|Float.fractionalPart]] of the number are\nseparated by a `.` decimal point. Digits consist of decimal \ndigits `0` to `9`. \n\nThe number of decimal places following the decimal point is \ncontrolled by the parameters [[minDecimalPlaces]] and \n[[maxDecimalPlaces]], which default to `1` and `9` \nrespectively, so that by default the string representation\nalways contains a decimal point, and never contains more \nthan nine decimal places. The decimal representation is \ntruncated so that the number of decimal places never \nexceeds the specified maximum.\n\nFor example:\n\n- `formatFloat(1234.1234)` is `\"1234.1234\"`\n- `formatFloat(0.1234)` is `\"0.1234\"`\n- `formatFloat(1234.0)` is `\"1234.0\"`\n- `formatFloat(1234.0,0)` is `\"1234\"`\n- `formatFloat(1234.1234,6)` is `\"1234.123400\"`\n- `formatFloat(1234.1234,0,2)` is `\"1234.12\"`\n- `formatFloat(0.0001,2,2)` is `\"0.00\"`\n- `formatFloat(0.0001,0,2)` is `\"0\"`\n\nFinally:\n\n- `formatFloat(-0.0)` is `\"0.0\"`,\n- `formatFloat(0.0\/0)` is `\"NaN\"`,\n- `formatFloat(1.0\/0)` is `\"Infinity\"`, and\n- `formatFloat(-1.0\/0)` is `\"-Infinity\".`\n\nThis function never produces a representation involving \nscientific notation."]},nm:"formatFloat"},curry:{$t:{pk:".",tp:[{mt:"tp",nm:"Return"},{mt:"tp",nm:"Rest"}],nm:"Callable"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Return"},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Argument"},{mt:"tp",nm:"First"},{mt:"tp",nm:"Rest"}],nm:"Tuple"}],nm:"Callable"},mt:"prm",nm:"f"}],[{$t:{nm:"First"},mt:"prm",nm:"first"}]],mt:"m",tp:[{nm:"Return"},{nm:"Argument"},{sts:[{nm:"Argument"}],nm:"First"},{sts:[{pk:".",tp:[{mt:"tp",nm:"Argument"}],nm:"Sequential"}],nm:"Rest"}],an:{see:["uncurry","compose"],tagged:["Functions"],doc:["Curries a function, returning a function with two parameter \nlists, given a function with at least one parameter. The \nfirst parameter list of the returned function has just the \nfirst parameter of the original function, and the second \nparameter list has the remaining parameters.\n\nThat is, if `fun` has type `W(X,Y,Z)` then \n`curry(fun)` has type `W(Y,Z)(X)`."]},nm:"curry"},AliasesAnnotation:{super:{pk:".",nm:"Basic"},pa:561,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"AliasesAnnotation"},{mt:"tp",pk:".",nm:"Annotated"},{mt:"tp",pk:".",nm:"Anything"}],nm:"OptionalAnnotation"}],ps:[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"String"}],nm:"Sequential"},pa:1,mt:"prm",an:{doc:["The aliases, in plain text."]},seq:1,nm:"aliases"}],mt:"c",$at:{aliases:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"String"}],nm:"Sequential"},pa:1,mt:"a",an:{doc:["The aliases, in plain text."]},nm:"aliases"}},an:{doc:["The annotation class for the [[aliased]] annotation."]},nm:"AliasesAnnotation"},system:{super:{pk:".",nm:"Basic"},pa:65,mt:"o",$at:{milliseconds:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{doc:["The elapsed time in milliseconds since midnight, \n1 January 1970."]},nm:"milliseconds"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},timezoneOffset:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{doc:["Returns the offset, in milliseconds, to add to UTC to \nget the local time for default timezone for this system."]},nm:"timezoneOffset"},nanoseconds:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{doc:["The elapsed time in nanoseconds since an arbitrary \nstarting point."]},nm:"nanoseconds"},locale:{$t:{pk:".",nm:"String"},pa:65,mt:"a",an:{doc:["Returns the IETF language tag representing the default \nlocale for this system."]},nm:"locale"},characterEncoding:{$t:{pk:".",nm:"String"},pa:65,mt:"a",an:{doc:["Returns the IANA character set name representing the default \ncharacter encoding for this system."]},nm:"characterEncoding"}},an:{see:["process","runtime","language","operatingSystem"],tagged:["Environment"],doc:["Represents the system on which the current process is \nexecuting.\n\nHolds information about system time and locale."]},nm:"system"},compose:{$t:{pk:".",tp:[{mt:"tp",nm:"X"},{mt:"tp",nm:"Args"}],nm:"Callable"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"X"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Y"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Y"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"}],nm:"Callable"},mt:"prm",nm:"x"},{$t:{pk:".",tp:[{mt:"tp",nm:"Y"},{mt:"tp",nm:"Args"}],nm:"Callable"},mt:"prm",nm:"y"}]],mt:"m",tp:[{nm:"X"},{nm:"Y"},{sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"Anything"}],nm:"Sequential"}],nm:"Args"}],an:{see:["curry","uncurry"],tagged:["Functions"],doc:["Given a function with return type `Y`, and a second \nfunction with a single parameter also of type `Y`, return \nthe composition of the two functions. The first function \nmay have any number of parameters.\n\nFor any such functions `f()` and `g()`,\n\n    compose(g,f)(*args)==g(f(*args))\n\nfor every possible argument tuple `args` of `f()`."]},nm:"compose"},Byte:{super:{pk:".",nm:"Object"},pa:97,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"Byte"}],nm:"Binary"},{pk:".",tp:[{mt:"tp",pk:".",nm:"Byte"}],nm:"Invertible"},{pk:".",tp:[{mt:"tp",pk:".",nm:"Byte"}],nm:"Enumerable"}],ps:[{$t:{pk:".",nm:"Integer"},mt:"prm",an:{doc:["An integer member of the congruence class of the \nresulting `Byte`.\n\nFor any integer `x>=0`:\n\n    x.byte.unsigned == x % 256\n    x.byte.signed == x % 256\n\nAnd for an integer `x<0`:\n\n    x.byte.unsigned == 256 + x % 256\n    x.byte.signed == x % 256\n\nAnd for any integers `x` and `y` which are congruent\nmodulo 256:\n\n    x.byte == y.byte"]},nm:"congruent",$hdn:1}],mt:"c",$at:{zero:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Whether this byte is zero."]},nm:"zero"},unit:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Whether this byte is one."]},nm:"unit"},negated:{$t:{pk:".",nm:"Byte"},pa:67,mt:"a",an:{doc:["The additive inverse of this byte. For any integer `x`:\n\n    (-x.byte).signed = -x.byte.signed"]},nm:"negated"},not:{$t:{pk:".",nm:"Byte"},pa:67,mt:"a",nm:"not"},successor:{$t:{pk:".",nm:"Byte"},pa:67,mt:"a",nm:"successor"},string:{$t:{pk:".",nm:"String"},pa:67,mt:"a",an:{doc:["The [[unsigned]] interpretation of this byte as a \nstring."]},nm:"string"},even:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Whether this byte is even."]},nm:"even"},congruent$4ssbsl:{$t:{pk:".",nm:"Integer"},mt:"a",an:{doc:["An integer member of the congruence class of the \nresulting `Byte`.\n\nFor any integer `x>=0`:\n\n    x.byte.unsigned == x % 256\n    x.byte.signed == x % 256\n\nAnd for an integer `x<0`:\n\n    x.byte.unsigned == 256 + x % 256\n    x.byte.signed == x % 256\n\nAnd for any integers `x` and `y` which are congruent\nmodulo 256:\n\n    x.byte == y.byte"]},nm:"congruent"},unsigned:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{doc:["This byte interpreted as an unsigned integer in the\nrange `0..255`."]},nm:"unsigned"},signed:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{doc:["This byte interpreted as a signed integer in the range \n`-128..127`."]},nm:"signed"},predecessor:{$t:{pk:".",nm:"Byte"},pa:67,mt:"a",nm:"predecessor"},hash:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"hash"}},$m:{or:{$t:{pk:".",nm:"Byte"},pa:67,ps:[[{$t:{pk:".",nm:"Byte"},mt:"prm",nm:"other"}]],mt:"m",nm:"or"},set:{$t:{pk:".",nm:"Byte"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"},{$t:{pk:".",nm:"Boolean"},def:1,mt:"prm",nm:"bit"}]],mt:"m",nm:"set"},offset:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Byte"},mt:"prm",nm:"other"}]],mt:"m",nm:"offset"},rightLogicalShift:{$t:{pk:".",nm:"Byte"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"shift"}]],mt:"m",nm:"rightLogicalShift"},neighbour:{$t:{pk:".",nm:"Byte"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"offset"}]],mt:"m",nm:"neighbour"},plus:{$t:{pk:".",nm:"Byte"},pa:67,ps:[[{$t:{pk:".",nm:"Byte"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["The modulo 256 sum of this byte and the given byte."]},nm:"plus"},rightArithmeticShift:{$t:{pk:".",nm:"Byte"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"shift"}]],mt:"m",nm:"rightArithmeticShift"},offsetSign:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Byte"},mt:"prm",nm:"other"}]],mt:"m",nm:"offsetSign"},and:{$t:{pk:".",nm:"Byte"},pa:67,ps:[[{$t:{pk:".",nm:"Byte"},mt:"prm",nm:"other"}]],mt:"m",nm:"and"},get:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"get"},equals:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],mt:"m",nm:"equals"},xor:{$t:{pk:".",nm:"Byte"},pa:67,ps:[[{$t:{pk:".",nm:"Byte"},mt:"prm",nm:"other"}]],mt:"m",nm:"xor"},leftLogicalShift:{$t:{pk:".",nm:"Byte"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"shift"}]],mt:"m",nm:"leftLogicalShift"},flip:{$t:{pk:".",nm:"Byte"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"flip"}},an:{tagged:["Basic types"],doc:["An 8-bit byte. A `Byte` value represents a congruence class\nof [[integers|Integer]] modulo 256, and may be interpreted \nas:\n\n- an [[unsigned]] integer value in the range `0..255`, or \n- a [[signed]] integer value in the range `-128..127`. \n\n`Byte` is not considered a full numeric type, supporting \nonly:\n\n- [[bitwise|Binary]] operations, and \n- addition and subtraction modulo 256.\n\n`Byte`s with modular addition form a [[mathematical \ngroup|Invertible]]. Thus, every byte `b` has an additive\ninverse `-b` where:\n\n    (-b).signed == -b.signed\n    (-b).unsigned == b.unsigned==0 then 0 else 256 - b.unsigned\n\n`Byte` is a [[recursive enumerable type|Enumerable]]. For\nexample, the range:\n\n    254.byte .. 1.byte\n    \ncontains the values `254.byte, 255.byte, 0.byte, 1.byte`.\n\n`Byte` does not have a [[total order|Comparable]] because\nany such order would:\n \n- be inconsistent with the definition of [[successor]] and \n  [[predecessor]] under modular addition, and\n- would depend on interpretation of the `Byte` value as\n  signed or unsigned.\n\nThus, to compare the magnitude of two bytes, it is \nnecessary to first convert them to either their `signed` or \n`unsigned` integer values.\n\n`Byte`s are useful mainly because they can be efficiently \nstored in an [[Array]]."]},nm:"Byte"},VariableAnnotation:{super:{pk:".",nm:"Basic"},pa:561,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"VariableAnnotation"},{mt:"tp",pk:"ceylon.language.meta.declaration",nm:"ValueDeclaration"},{mt:"tp",pk:".",nm:"Anything"}],nm:"OptionalAnnotation"}],mt:"c",an:{doc:["The annotation class for the [[variable]] annotation."]},nm:"VariableAnnotation"},doc:{$t:{pk:".",nm:"DocAnnotation"},pa:513,ps:[[{$t:{pk:".",nm:"String"},mt:"prm",an:{doc:["Documentation, in Markdown syntax, about the annotated element"]},nm:"description"}]],mt:"m",an:{doc:["Annotation to specify API documentation of a program\nelement."]},nm:"doc"},Object:{super:{pk:".",nm:"Anything"},pa:257,mt:"c",$at:{string:{$t:{pk:".",nm:"String"},pa:9,mt:"g",an:{doc:["A developer-friendly string representing the instance. \nConcatenates the name of the concrete class of the \ninstance with the `hash` of the instance. Subclasses \nare encouraged to refine this implementation to produce \na more meaningful representation."]},nm:"string"},hash:{$t:{pk:".",nm:"Integer"},pa:5,mt:"a",an:{doc:["The hash value of the value, which allows the value to \nbe an element of a hash-based set or key of a\nhash-based map. Implementations must respect the\nconstraint that:\n\n- if `x==y` then `x.hash==y.hash`.\n\nTherefore, a class which refines [[equals]] must also\nrefine `hash`.\n\nBecause the [[Integer]] type is platform-dependent \na compiler for a given platform is permitted to\nfurther manipulate the calculated hash for an object,\nand the resulting hash may differ between platforms."]},nm:"hash"}},$m:{equals:{$t:{pk:".",nm:"Boolean"},pa:5,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],mt:"m",an:{doc:["Determine if two values are equal. Implementations\nshould respect the constraints that:\n\n- if `x===y` then `x==y` (reflexivity), \n- if `x==y` then `y==x` (symmetry), \n- if `x==y` and `y==z` then `x==z` (transitivity).\n\nFurthermore it is recommended that implementations\nensure that if `x==y` then `x` and `y` have the same \nconcrete class.\n\nA class which explicitly refines `equals()` is said to \nsupport _value equality_, and the equality operator \n`==` is considered much more meaningful for such \nclasses than for a class which simply inherits the\ndefault implementation of _identity equality_ from\n[[Identifiable]]."]},nm:"equals"}},an:{see:["Basic","Null"],tagged:["Basic types"],by:["Gavin"],doc:["The abstract supertype of all types representing definite \nvalues. Any two values which are assignable to `Object` \nmay be compared for value equality using the `==` and `!=` \noperators, even if the values are of different concrete \ntype:\n\n    true == false\n    1 == \"hello world\"\n    \"hello\"+\" \"+\"world\" == \"hello world\"\n    Singleton(\"hello world\") == [\"hello world\"]\n\nHowever, since [[Null]] is not a subtype of `Object`, the\nvalue [[null]] cannot be compared to any other value \nusing the `==` operator. Thus, value equality is not \ndefined for optional types. This neatly bypasses the \nproblem of deciding the value of the expression \n`null==null`, which is simply illegal.\n\nA concrete subclass of `Object` must refine [[equals]] \nand [[hash]] (or inherit concrete refinements), providing \na concrete definition of value equality for the class.\n\nIn extreme cases it is acceptable for two values to be\nequal even when they are not instances of the same class.\nFor example, the [[Integer]] value `1` and the [[Float]]\nvalue `1.0` are considered equal. Except in these extreme\ncases, instances of different classes are considered\nunequal."]},nm:"Object"},Map:{pa:1,sts:[{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"Item"}],nm:"Entry"}],nm:"Collection"},{pk:".",tp:[{mt:"tp",pk:".",nm:"Object"},{mt:"tp",nm:"Item"}],nm:"Correspondence"}],mt:"i",$at:{keys:{$t:{pk:".",tp:[{mt:"tp",nm:"Key"}],nm:"Collection"},pa:11,mt:"g",$at:{size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"}},$m:{contains:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"key"}]],mt:"m",nm:"contains"},iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Key"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},clone:{$t:{pk:".",tp:[{mt:"tp",nm:"Key"}],nm:"Collection"},pa:3,mt:"m",nm:"clone"}},an:{doc:["A [[Collection]] containing the keys of this map."]},nm:"keys",$c:{anon$0$h7c2w9:{super:{pk:".",nm:"Basic"},sts:[{pk:".",tp:[{mt:"tp",nm:"Key"}],nm:"Collection"}],mt:"c",$anon:1,nm:"anon$0$h7c2w9"}}},distinct:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"Item"}],nm:"Entry"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:3,mt:"g",nm:"distinct"},items:{$t:{pk:".",tp:[{mt:"tp",nm:"Item"}],nm:"Collection"},pa:9,mt:"g",$at:{size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"}},$m:{contains:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"item"}]],mt:"m",nm:"contains"},iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Item"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},clone:{$t:{pk:".",tp:[{mt:"tp",nm:"Item"}],nm:"Collection"},pa:3,mt:"m",nm:"clone"}},an:{doc:["A [[Collection]] containing the items stored in this \nmap. An element can be stored under more than one key \nin the map, and so it can occur more than once in the \nresulting collection."]},nm:"items",$c:{anon$1$d5dsmm:{super:{pk:".",nm:"Basic"},sts:[{pk:".",tp:[{mt:"tp",nm:"Item"}],nm:"Collection"}],mt:"c",$anon:1,nm:"anon$1$d5dsmm"}}},hash:{$t:{pk:".",nm:"Integer"},pa:11,mt:"g",nm:"hash"},coalescedMap:{$t:{pk:".",tp:[{mt:"tp",nm:"Key"},{comp:"i",mt:"tp",l:[{nm:"Item"},{pk:".",nm:"Object"}]}],nm:"Map"},pa:9,mt:"g",$m:{iterator:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Key"},{comp:"i",mt:"tp",l:[{nm:"Item"},{pk:".",nm:"Object"}]}],nm:"Entry"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},getOrDefault:{$t:{comp:"u",l:[{nm:"Default"},{comp:"i",l:[{nm:"Item"},{pk:".",nm:"Object"}]}]},pa:3,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"key"},{$t:{nm:"Default"},mt:"prm",nm:"default"}]],mt:"m",tp:[{nm:"Default"}],nm:"getOrDefault"},get:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{comp:"i",l:[{nm:"Item"},{pk:".",nm:"Object"}]}]},pa:3,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"key"}]],mt:"m",nm:"get"},clone:{$t:{pk:".",tp:[{mt:"tp",nm:"Key"},{comp:"i",mt:"tp",l:[{nm:"Item"},{pk:".",nm:"Object"}]}],nm:"Map"},pa:3,mt:"m",nm:"clone"},defines:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"key"}]],mt:"m",nm:"defines"}},an:{see:["defaultNullItems"],doc:["A map with every entry of this map whose item is\nnon-null."]},nm:"coalescedMap",$c:{anon$7$hv3eij:{super:{pk:".",nm:"Object"},sts:[{pk:".",tp:[{mt:"tp",nm:"Key"},{comp:"i",mt:"tp",l:[{nm:"Item"},{pk:".",nm:"Object"}]}],nm:"Map"}],mt:"c",$anon:1,nm:"anon$7$hv3eij"}}}},$m:{inverse:{$t:{pk:".",tp:[{comp:"i",mt:"tp",l:[{nm:"Item"},{pk:".",nm:"Object"}]},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Key"}],nm:"Sequence"}],nm:"Map"},pa:9,mt:"m",an:{doc:["Invert this map, producing a new immutable map where \nthe keys of the new map are the non-null items of this\nmap, and each item of the new map is a nonempty \nsequence of keys of this map.\n\nFor example, the expression:\n\n    { \"fee\", \"fi\", \"fo\", \"fum\", \"foo\" }\n       .tabulate(String.size)\n       .inverse()\n\nproduces the map \n`{ 2->[\"fo\", \"fi\"], 3->[ \"fum\", \"fee\", \"foo\"] }`.\n\nThe order of keys in the key sequences is not defined\nand should not be relied upon.\n\nThis is an eager operation, and the resulting map does\nnot reflect changes to this map."]},nm:"inverse"},getOrDefault:{$t:{comp:"u",l:[{nm:"Item"},{nm:"Default"}]},pa:9,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"key"},{$t:{nm:"Default"},mt:"prm",nm:"default"}]],mt:"m",tp:[{nm:"Default"}],an:{see:["get"],doc:["Returns the item of the entry with the given [[key]], \nor the given [[default]] if there is no entry with the \ngiven `key` in this map.\n\nFor maps with non-null items, the expression:\n\n    map.getOrDefault(key, def)\n\nis equivalent to this common idiom:\n\n    map[key] else def\n\nHowever, when the map has null items, `getOrDefault()`\nwill preserve them.\n\nNote that high-quality implementations of `Map` should \nrefine this default implementation."]},nm:"getOrDefault"},filterKeys:{$t:{pk:".",tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"Item"}],nm:"Map"},pa:9,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Key"},mt:"prm",nm:"key"}]],mt:"prm",$pt:"f",an:{doc:["The predicate function that filters the keys of \nthis map, determining if there is a corresponding\nentry in the resulting map."]},nm:"filtering"}]],mt:"m",an:{doc:["Produces a map by applying a [[filtering]] function \nto the [[keys]] of this map. This is a lazy operation, \nreturning a view of this map."]},nm:"filterKeys"},defines:{$t:{pk:".",nm:"Boolean"},pa:7,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"key"}]],mt:"m",an:{see:["contains"],doc:["Determines if there is an entry in this map with the\ngiven [[key]]."]},nm:"defines"},patch:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Key"},{nm:"OtherKey"}]},{comp:"u",mt:"tp",l:[{nm:"Item"},{nm:"OtherItem"}]}],nm:"Map"},pa:9,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"OtherKey"},{mt:"tp",nm:"OtherItem"}],nm:"Map"},mt:"prm",nm:"other"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"OtherKey"},{nm:"OtherItem"}],an:{doc:["Produces a map whose keys are the union of the keys\nof this map, with the keys of the given [[map|other]].\nFor any given key in the resulting map, its associated\nitem is the item associated with the key in the given\nmap, if any, or the item associated with the key in \nthis map otherwise.\n\nThat is, for any `key` in the resulting patched map:\n\n    map.patch(other)[key] == other.getOrDefault(key, map[key])\n\nThis is a lazy operation producing a view of this map\nand the given map."]},nm:"patch"},contains:{$t:{pk:".",nm:"Boolean"},pa:11,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"entry"}]],mt:"m",an:{see:["defines"],doc:["Determines if the given [[value|entry]] is an [[Entry]]\nbelonging to this map."]},nm:"contains"},mapItems:{$t:{pk:".",tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"Result"}],nm:"Map"},pa:9,ps:[[{$t:{nm:"Result"},ps:[[{$t:{nm:"Key"},mt:"prm",nm:"key"},{$t:{nm:"Item"},mt:"prm",nm:"item"}]],mt:"prm",$pt:"f",an:{doc:["The function that transforms a key\/item pair of\nthis map, producing the item of the resulting map."]},nm:"mapping"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Result"}],an:{doc:["Produces a map with the same [[keys]] as this map. For \nevery key, the item is the result of applying the given \n[[transformation|Map.mapItems.mapping]] function to its \nassociated item in this map. This is a lazy operation, \nreturning a view of this map."]},nm:"mapItems"},defaultNullItems:{$t:{pk:".",tp:[{mt:"tp",nm:"Key"},{comp:"u",mt:"tp",l:[{comp:"i",l:[{nm:"Item"},{pk:".",nm:"Object"}]},{nm:"Default"}]}],nm:"Map"},pa:9,ps:[[{$t:{nm:"Default"},mt:"prm",an:{doc:["A default value that replaces `null` items."]},nm:"defaultValue"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Default"}],an:{see:["coalescedMap"],doc:["Produces a map containing the elements of this map, \nafter replacing every `null` item in the map with the \n[[given default value|defaultValue]]. The item `null` \ndoes not ocur in the resulting map."]},nm:"defaultNullItems"},get:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Item"}]},pa:7,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"key"}]],mt:"m",an:{see:["getOrDefault"],doc:["Returns the item of the entry with the given [[key]], \nor `null` if there is no entry with the given `key` in\nthis map."]},nm:"get"},equals:{$t:{pk:".",nm:"Boolean"},pa:11,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],mt:"m",an:{doc:["Two maps are considered equal iff they have the same \n_entry sets_. The entry set of a `Map` is the set of \n`Entry`s belonging to the map. Therefore, the maps are \nequal iff they have same set of `keys`, and for every \nkey in the key set, the maps have equal items."]},nm:"equals"},clone:{$t:{pk:".",tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"Item"}],nm:"Map"},pa:7,mt:"m",an:{doc:["A shallow copy of this map, that is, a map with the\nsame entries as this map, which do not change if the\nentries in this map change."]},nm:"clone"},lookup$h6x2fy:{$t:{comp:"u",l:[{nm:"Item"},{pk:".",nm:"Missing"}]},ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"key"}]],mt:"m",nm:"lookup"},defaultNullElements:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"Item"}],nm:"Entry"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:3,ps:[[{$t:{nm:"Default"},mt:"prm",nm:"defaultValue"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Default"}],nm:"defaultNullElements"}},tp:[{dv:"out",sts:[{pk:".",nm:"Object"}],def:{pk:".",nm:"Object"},nm:"Key"},{dv:"out",def:{pk:".",nm:"Anything"},nm:"Item"}],an:{see:["Entry","map","forKey","forItem","byItem","byKey"],tagged:["Collections"],doc:["A collection which maps _keys_ to _items_, where a key \ncan map to at most one item. Each such mapping may be \nrepresented by an [[Entry]]. Thus, each distinct key \noccurs in at most one entry. Two \nnon-[[identical|Identifiable]] keys are considered \ndistinct only if they are unequal, according to their own \ndefinition of [[value equality|Object.equals]].\n\nA `Map` is a [[Collection]] of its `Entry`s, and a \n[[Correspondence]] from keys to items.\n\nA new `Map` may be obtained by calling the function [[map]].\n\n    value settings = map { \"lang\"->\"en_AU\", \"loc\"->\"ES\" };\n\nThe presence of an entry in a map may be tested using the \n`in` operator:\n\n    if (\"lang\"->\"en_AU\" in settings) { ... }\n\nThe entries of the map may be iterated using `for`:\n\n    for (key->item in settings) { ... }\n\nThe item for a key may be obtained using the item\noperator:\n\n    String lang = settings[\"lang\"] else \"en_US\";\n\nAn implementation of `Map` may compare keys for equality \nusing [[Object.equals]] or [[Comparable.compare]]."]},nm:"Map"},larger:{super:{pk:".",nm:"Comparison"},pa:1,mt:"o",$at:{reversed:{$t:{pk:".",nm:"Comparison"},pa:3,mt:"g",nm:"reversed"}},an:{tagged:["Comparisons"],doc:["The value is larger than the given value."]},nm:"larger"},parseFloat:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Float"}]},pa:1,ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"string"}]],mt:"m",an:{see:["formatFloat","parseInteger"],tagged:["Numbers","Basic types"],doc:["The [[Float]] value of the given \n[[string representation|string]] of a decimal floating \npoint number, or `null` if the string does not represent a \ndecimal floating point number.\n\nIf the given string representation contains more digits\nthan can be represented by a `Float`, then the least \nsignificant digits are ignored.\n\nThe syntax accepted by this method is the same as the \nsyntax for a `Float` literal in the Ceylon language \nexcept that it may optionally begin with a sign \ncharacter (`+` or `-`) and may not contain grouping \nunderscore characters."]},nm:"parseFloat"},JoinedSequence:{super:{pk:".",nm:"Object"},sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"}],ps:[{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"},mt:"prm",nm:"firstSeq"},{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"},mt:"prm",nm:"secondSeq"}],mt:"c",$at:{rest:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,mt:"g",nm:"rest"},firstSeq$vc5yc7:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"},mt:"a",nm:"firstSeq"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"},last:{$t:{nm:"Element"},pa:3,mt:"g",nm:"last"},secondSeq$g3ri2t:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"},mt:"a",nm:"secondSeq"},first:{$t:{nm:"Element"},pa:3,mt:"g",nm:"first"}},$m:{spanTo:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"spanTo"},spanFrom:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],mt:"m",nm:"spanFrom"},iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},measure:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",nm:"measure"},slice:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},{mt:"tp",pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"}],nm:"Tuple"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"slice"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"getFromFirst"},span:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"span"}},tp:[{nm:"Element"}],nm:"JoinedSequence"},parseBoolean:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Boolean"}]},pa:1,ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"string"}]],mt:"m",an:{tagged:["Basic types"],doc:["The `Boolean` value of the given string representation of a \nboolean value, or `null` if the string does not represent a \nboolean value.\n\nRecognized values are `\"true\"`, `\"false\"`."]},nm:"parseBoolean"},zipPairs:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"First"},{comp:"u",l:[{nm:"Second"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"First"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Second"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Second"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"}],nm:"Tuple"},{comp:"u",mt:"tp",l:[{nm:"FirstAbsent"},{nm:"SecondAbsent"}]}],nm:"Iterable"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"First"},{mt:"tp",nm:"FirstAbsent"}],nm:"Iterable"},mt:"prm",nm:"firstElements"},{$t:{pk:".",tp:[{mt:"tp",nm:"Second"},{mt:"tp",nm:"SecondAbsent"}],nm:"Iterable"},mt:"prm",nm:"secondElements"}]],mt:"m",tp:[{nm:"First"},{nm:"Second"},{sts:[{pk:".",nm:"Null"}],nm:"FirstAbsent"},{sts:[{pk:".",nm:"Null"}],nm:"SecondAbsent"}],an:{tagged:["Streams"],doc:["Given two streams, form a new stream consisting of all \npairs where, for any given index in the resulting stream, \nthe first element of the pair is the element occurring at \nthe same index in the [[first stream|firstElements]], and \nthe second element of the pair is the element occurring at \nthe same index in the [[second stream|secondElements]]. The \nlength of the resulting stream is the length of the shorter \nof the two given streams.\n\nThus:\n\n    zipPairs(xs, ys)[i] == [xs[i], ys[i]]\n\nfor every `0<=i<smallest(xs.size,ys.size)`."]},nm:"zipPairs"},className:{$t:{pk:".",nm:"String"},pa:65,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"obj"}]],mt:"m",an:{tagged:["Metamodel"],doc:["Return the name of the concrete class of the given object, \nin a format native to the virtual machine."]},nm:"className"},SuppressWarningsAnnotation:{super:{pk:".",nm:"Basic"},pa:561,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"SuppressWarningsAnnotation"},{comp:"u",mt:"tp",l:[{pk:"ceylon.language.meta.declaration",nm:"FunctionDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ValueDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ClassOrInterfaceDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ConstructorDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"Module"},{pk:"ceylon.language.meta.declaration",nm:"Package"},{pk:"ceylon.language.meta.declaration",nm:"Import"}]},{mt:"tp",pk:".",nm:"Anything"}],nm:"OptionalAnnotation"}],ps:[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"String"}],nm:"Sequential"},pa:1,mt:"prm",an:{doc:["The warning types to suppress."]},seq:1,nm:"warnings"}],mt:"c",$at:{warnings:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"String"}],nm:"Sequential"},pa:1,mt:"a",an:{doc:["The warning types to suppress."]},nm:"warnings"}},an:{doc:["The annotation class for the [[suppressWarnings]] \nannotation."]},nm:"SuppressWarningsAnnotation"},unzip:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{pk:".",tp:[{mt:"tp",nm:"Head"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},{comp:"u",l:[{pk:".",tp:[{mt:"tp",nm:"Tail"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Head"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{pk:".",tp:[{mt:"tp",nm:"Tail"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},{pk:".",nm:"Nothing"}]},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Tail"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"}],nm:"Tuple"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Head"}]},{mt:"tp",nm:"Head"},{mt:"tp",nm:"Tail"}],nm:"Tuple"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},mt:"prm",nm:"tuples"}]],mt:"m",tp:[{nm:"Element"},{nm:"Head"},{sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"}],nm:"Tail"},{sts:[{pk:".",nm:"Null"}],nm:"Absent"}],an:{tagged:["Streams"],doc:["Given a stream of tuples, return two streams. The\nfirst stream produces the first elements of the\ngiven tuples, and the second stream produces the\nremaining elements of the given tuples.\n\nThus:\n\n    tuples[i] == [unzip(tuples)[0][i], \n                 *unzip(tuples)[1][i]]"]},nm:"unzip"},Span:{super:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Range"},pa:2080,ps:[{$t:{nm:"Element"},pa:3,mt:"prm",an:{doc:["The start of the range."]},nm:"first",$hdn:1},{$t:{nm:"Element"},pa:3,mt:"prm",an:{doc:["The end of the range."]},nm:"last",$hdn:1}],mt:"c",$at:{rest:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,mt:"g",nm:"rest"},last:{$t:{nm:"Element"},pa:3,mt:"a",an:{doc:["The end of the range."]},nm:"last"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"},increasing:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"a",nm:"increasing"},recursive$1gdd1o:{$t:{pk:".",nm:"Boolean"},mt:"a",an:{doc:["Determines if the range is of recursive values, that \nis, if successors wrap back on themselves. All \nrecursive ranges are [[increasing]]."]},nm:"recursive"},decreasing:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"g",nm:"decreasing"},lastIndex:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"lastIndex"},first:{$t:{nm:"Element"},pa:3,mt:"a",an:{doc:["The start of the range."]},nm:"first"},reversed:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"},pa:3,mt:"g",an:{doc:["This range in reverse, with [[first]] and [[last]]\ninterchanged.\n\nFor any two range endpoints, `x` and `y`: \n\n    `(x..y).reversed == y..x`\n\nexcept for [[recursive]] ranges, where the elements are\nevaluated and collected into a new sequence."]},nm:"reversed"}},$m:{fromFirst$otuqgo:{$t:{nm:"Element"},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"offset"}]],mt:"m",nm:"fromFirst"},spanFrom:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],mt:"m",nm:"spanFrom"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",an:{doc:["The element of the range that occurs [[index]] values \nafter the start of the range."]},nm:"getFromFirst"},count:{$t:{pk:".",nm:"Integer"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",$m:{selecting$nzgblm:{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"m",nm:"selecting"}},nm:"count"},beforeFirst$3osfad:{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"}]],mt:"m",nm:"beforeFirst"},includesRange:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Range"},mt:"prm",nm:"range"}]],mt:"m",nm:"includesRange"},next$xciqj1:{$t:{nm:"Element"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"}]],mt:"m",nm:"next"},each:{$t:{pk:".",nm:"Anything"},pa:3,ps:[[{$t:{pk:".",nm:"Anything"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"step"}]],$ff:1,mt:"m",$m:{step$v5j5xq:{$t:{pk:".",nm:"Anything"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],$ff:1,mt:"m",nm:"step"}},nm:"each"},afterLast$dudvro:{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"}]],mt:"m",nm:"afterLast"},spanTo:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"spanTo"},iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:3,mt:"m",an:{doc:["An iterator for the elements of the range. The returned \niterator produces elements from [[first]] and continues \nproducing elements until it reaches an element whose \n`offset` from [[last] is zero."]},nm:"iterator"},measure:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",nm:"measure"},shorterThan:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",nm:"shorterThan"},beforeLast$sti0n5:{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"}]],mt:"m",nm:"beforeLast"},by:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Iterable"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"step"}]],mt:"m",nm:"by"},equals:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],mt:"m",nm:"equals"},nextStep$sxlqah:{$t:{nm:"Element"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"step"}]],mt:"m",nm:"nextStep"},afterFirst$upgk2i:{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"}]],mt:"m",nm:"afterFirst"},longerThan:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",nm:"longerThan"},containsElement:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"}]],mt:"m",nm:"containsElement"},shifted:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Range"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"shift"}]],mt:"m",nm:"shifted"},span:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"span"}},tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Enumerable"}],nm:"Element"}],an:{see:["Measure","Enumerable"],by:["Gavin"],doc:["A [[Range]] of adjacent [[Enumerable]] values generated by \ntwo endpoints: [[first]] and [[last]]. The range includes \nboth endpoints, and all values falling _between_ the \nendpoints."]},nm:"Span",$c:{By$ry6enl:{super:{pk:".",nm:"Basic"},sts:[{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Iterable"}],ps:[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"step"}],mt:"c",$at:{size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},step$axxwpk:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"step"},first:{$t:{nm:"Element"},pa:3,mt:"g",nm:"first"}},$m:{iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:3,mt:"m",$at:{current$xkyyld:{$t:{nm:"Element"},pa:1027,mt:"a",nm:"current"},current$nxhyw:{$t:{comp:"u",l:[{nm:"Element"},{pk:".",nm:"Finished"}]},pa:1027,mt:"a",nm:"current"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},count$zhc9mv:{$t:{pk:".",nm:"Integer"},pa:1024,mt:"a",nm:"count"},firstTime$d2tu8c:{$t:{pk:".",nm:"Boolean"},pa:1027,mt:"a",nm:"firstTime"}},$m:{next:{$t:{comp:"u",l:[{nm:"Element"},{pk:".",nm:"Finished"}]},pa:3,mt:"m",nm:"next"}},nm:"iterator",$c:{anon$2$s5n2ng:{super:{pk:".",nm:"Basic"},sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"}],mt:"c",$anon:1,nm:"anon$2$s5n2ng"},anon$1$m4vs6j:{super:{pk:".",nm:"Basic"},sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"}],mt:"c",$anon:1,nm:"anon$1$m4vs6j"}}}},nm:"By$ry6enl"}}},Callable:{pa:65,mt:"i",tp:[{dv:"out",nm:"Return"},{dv:"in",sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"Anything"}],nm:"Sequential"}],nm:"Arguments"}],an:{see:["Tuple"],tagged:["Functions"],doc:["A reference to a function. The type arguments encode the \n[[return type|Return]] of the function along with its \n[[parameter types|Arguments]]. The parameter types are \nrepresented by a tuple type. Functions declared `void`\nare considered to have the return type `Anything`.\n\nFor example, the type of the anonymous function\n`(Float x, Integer y) => x^y+1` is:\n\n    Callable<Float, [Float,Integer]>\n\nwhich we usually abbreviate to `Float(Float,Integer)`.\n\nLikewise, the type of the function reference `plus<Float>` \nto the function [[plus]] is:\n\n    Callable<Float, [Float,Float]>\n\nwhich we abbreviate as `Float(Float,Float)`.\n\nA variadic function is represented using an unterminated \ntuple type. For example, the type of the function reference\n`concatenate<Object>` to the function [[concatenate]] is:\n\n    Callable<Object[], [{Object*}*]>\n\nwhich we usually abbreviate `Object({Object*}*)`.\n\nA function with defaulted parameters is represented using\na union type. For example, the type of the method reference\n`process.writeLine` to the method [[process.writeLine]] is:\n\n    Callable<Anything, [String]|[]>\n\nwhich we usually abbreviate `Anything(String=)`.\n\nAny instance of `Callable` may be _invoked_ by supplying a \npositional argument list:\n\n    Float(Float,Float) add = plus<Float>;\n    value four = add(2.0, 2.0);\n\nor by supplying a tuple containing the arguments:\n\n    Float(Float,Float) add = plus<Float>;\n    [Float,Float] twoAndTwo = [2.0, 2.0];\n    value four = add(*twoAndTwo);\n\nThe type of the tuple must be assignable to the type \nargument of `Arguments`.\n\nThis interface may not be implemented by user code."]},nm:"Callable"},decreasingItem:{$t:{pk:".",nm:"Comparison"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Object"},{mt:"tp",nm:"Item"}],nm:"Entry"},mt:"prm",nm:"x"},{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Object"},{mt:"tp",nm:"Item"}],nm:"Entry"},mt:"prm",nm:"y"}]],mt:"m",tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Item"}],nm:"Comparable"}],nm:"Item"}],an:{tagged:["Comparisons"],doc:["A comparator function which orders [[entries|Entry]] by \ndecreasing [[natural order|Comparable]] of their \n[[items|Entry.item]].\n       \nThis function is intended for use with [[Iterable.sort]]\nand [[Iterable.max]]."]},nm:"decreasingItem"},noop:{$t:{pk:".",nm:"Anything"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Anything"}],nm:"Sequential"},mt:"prm",seq:1,nm:"arguments"}]],$ff:1,mt:"m",an:{tagged:["Functions"],doc:["A `void` function that does nothing."]},nm:"noop"},native:{$t:{pk:".",nm:"NativeAnnotation"},pa:513,ps:[[{$t:{pk:".",nm:"String"},def:1,mt:"prm",nm:"backend"}]],mt:"m",an:{doc:["Annotation to mark a member whose implementation is defined \nin platform-native code."]},nm:"native"},identity:{$t:{nm:"Value"},pa:1,ps:[[{$t:{nm:"Value"},mt:"prm",nm:"argument"}]],mt:"m",tp:[{nm:"Value"}],an:{tagged:["Functions"],doc:["The identity function that always returns its argument."]},nm:"identity"},AnnotationAnnotation:{super:{pk:".",nm:"Basic"},pa:561,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"AnnotationAnnotation"},{comp:"u",mt:"tp",l:[{pk:"ceylon.language.meta.declaration",nm:"ClassDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"FunctionDeclaration"}]},{mt:"tp",pk:".",nm:"Anything"}],nm:"OptionalAnnotation"}],mt:"c",an:{doc:["The annotation class for the [[annotation]] meta-annotation."]},nm:"AnnotationAnnotation"},emptyMap:{super:{pk:".",nm:"Object"},pa:1,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Map"}],mt:"o",$at:{size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"},keys:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"}],nm:"Collection"},pa:3,mt:"g",nm:"keys"},items:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"}],nm:"Collection"},pa:3,mt:"g",nm:"items"},empty:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"g",nm:"empty"}},$m:{getOrDefault:{$t:{nm:"Default"},pa:3,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"key"},{$t:{nm:"Default"},mt:"prm",nm:"default"}]],mt:"m",tp:[{nm:"Default"}],nm:"getOrDefault"},containsAny:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Object"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"elements"}]],mt:"m",nm:"containsAny"},count:{$t:{pk:".",nm:"Integer"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Entry"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"count"},containsEvery:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Object"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"elements"}]],mt:"m",nm:"containsEvery"},skip:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Entry"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"skipping"}]],mt:"m",nm:"skip"},any:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Entry"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"any"},each:{$t:{pk:".",nm:"Anything"},pa:3,ps:[[{$t:{pk:".",nm:"Anything"},ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Entry"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"step"}]],$ff:1,mt:"m",$m:{step$t2ndu6:{$t:{pk:".",nm:"Anything"},ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Entry"},mt:"prm",nm:"element"}]],$ff:1,mt:"m",nm:"step"}},nm:"each"},defines:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"index"}]],mt:"m",nm:"defines"},findLast:{$t:{pk:".",nm:"Null"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Entry"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"findLast"},take:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Entry"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"taking"}]],mt:"m",nm:"take"},iterator:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Entry"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},contains:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],mt:"m",nm:"contains"},mapItems:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Map"},pa:3,ps:[[{$t:{nm:"Result"},ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"key"},{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"item"}]],mt:"prm",$pt:"f",nm:"mapping"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Result"}],nm:"mapItems"},find:{$t:{pk:".",nm:"Null"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Entry"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"find"},get:{$t:{pk:".",nm:"Null"},pa:3,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"key"}]],mt:"m",nm:"get"},by:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Entry"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"step"}]],mt:"m",nm:"by"},clone:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Map"},pa:3,mt:"m",nm:"clone"},every:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Entry"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"every"}},an:{tagged:["Collections"],doc:["An immutable [[Map]] with no entries."]},nm:"emptyMap"},Exponentiable:{st:"This",pa:1,sts:[{pk:".",tp:[{mt:"tp",nm:"This"}],nm:"Numeric"}],mt:"i",of:[{nm:"This"}],$m:{power:{$t:{nm:"This"},pa:5,ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["The result of raising this number to the given power."]},nm:"power"}},tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"This"},{mt:"tp",nm:"Other"}],nm:"Exponentiable"}],nm:"This"},{sts:[{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Numeric"}],nm:"Other"}],an:{see:["Integer","Float"],tagged:["Numbers"],doc:["Abstraction of [[numeric types|Numeric]] that may be raised \nto a power using the _exponentiation_ operator `x ^ n` \nwhich accepts an instance of `Exponentiable` as its first\noperand, and an exponent as its second operand.\n\n    function exp(Float x) => e^x;\n\nThe exponentiation operation should obey the usual index\nlaws, including:\n\n- `x^0 == 1`\n- `x^1 == x`\n- `x^(-1) == 1\/x`\n- `x^(m+n) == x^m * x^n`\n- `x^(m-n) == x^m \/ x^n`\n- `x^(m*n) == (x^m)^n`\n- `(x*y)^n == x^n * y^n`\n\nwhere `0` is the additive identity, and `1` is the \nmultiplicative identity.\n\nNote that in general, the type of the exponent may be \ndifferent to the numeric type which is exponentiated. For\nexample, a `Rational` number class might be a subtype of\n`Exponentiable<Rational,Integer>`, thus accepting only\nwhole-number exponents."]},nm:"Exponentiable"},Invertible:{st:"Other",pa:1,sts:[{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Summable"}],mt:"i",of:[{nm:"Other"}],$at:{negated:{$t:{nm:"Other"},pa:5,mt:"a",an:{doc:["The additive inverse of this value."]},nm:"negated"}},$m:{minus:{$t:{nm:"Other"},pa:9,ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["The difference between this number and the given \nnumber. Must produce the value `x + -y`."]},nm:"minus"}},tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Invertible"}],nm:"Other"}],an:{see:["Integer","Float"],tagged:["Numbers"],by:["Gavin"],doc:["Abstraction of [[additive|Summable]] numeric types which \nsupport a unary operation `-x` producing the additive\ninverse of `x`. Every `Invertible` type supports a binary \nsubtraction operation `x-y`.\n\n    Integer negativeOne = -1;\n    Float delta = x-y;\n\nA concrete class that implements this interface should be a \nmathematical _group_. That is, it should have an additive \nidentity, denoted `0`, and satisfy:\n\n- `0+x == x+0 == x`\n- `x + -x == 0`\n\nSubtraction must be defined so that it is consistent with\nthe additive inverse:\n\n- `x - y == x + -y`"]},nm:"Invertible"},map:{$t:{pk:".",tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"Item"}],nm:"Map"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"Item"}],nm:"Entry"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",an:{doc:["The stream of entries."]},nm:"stream"},{$t:{nm:"Item"},ps:[[{$t:{nm:"Item"},mt:"prm",nm:"earlier"},{$t:{nm:"Item"},mt:"prm",nm:"later"}]],def:1,mt:"prm",$pt:"f",an:{doc:["A function that chooses between items with \nduplicate keys. By default, the item that\noccurs _earlier_ in the stream is chosen."]},nm:"choosing"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Key"},{nm:"Item"}],an:{doc:["Create a new immutable [[Map]] containing every [[Entry]] \nproduced by the given [[stream]], resolving items with\nduplicate keys according to the given [[function|choosing]].\n\nFor example:\n\n    map { 1->\"hello\", 2->\"goodbye\" }\n\nproduces the map `{ 1->\"hello\", 2->\"goodbye\" }`.\n\nThis is an eager operation and the resulting map does\nnot reflect changes to the given [[stream]]."]},nm:"map"},product:{$t:{nm:"Value"},pa:65,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Value"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Iterable"},mt:"prm",nm:"values"}]],mt:"m",tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Value"}],nm:"Numeric"}],nm:"Value"}],an:{see:["sum"],tagged:["Streams","Numbers"],doc:["Given a nonempty stream of [[Numeric]] values, return the \nproduct of the values.\n\n    {Float+} values = ... ;\n    Float result = product(values);\n\nFor the case of a possibly-empty stream, form a nonempty \nstream starting with the unit element (the [[multiplicative\nidentity|Numeric]]).\n\n    {Float*} values = ... ;\n    Float result = product { 1.0, *values };"]},nm:"product"},max:{$t:{comp:"u",l:[{nm:"Absent"},{nm:"Value"}]},pa:65,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Value"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},mt:"prm",nm:"values"}]],mt:"m",tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Value"}],nm:"Comparable"}],nm:"Value"},{sts:[{pk:".",nm:"Null"}],nm:"Absent"}],an:{see:["Comparable","min","largest","Iterable.max"],tagged:["Comparisons","Streams"],doc:["Given a stream of [[Comparable]] values, return the largest \nvalue in the stream, or `null` if the stream is empty.\n\nFor any nonempty stream `it`, `max(it)` evaluates to the \nfirst element of `it` such that for every element `e` of \n`it`, `max(it) >= e`.\n\nNote that [[Iterable.max]] may be used to find the largest \nvalue in any stream, as determined by a given comparator \nfunction."]},nm:"max"},minRadix:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"minRadix"},abstract:{$t:{pk:".",nm:"AbstractAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to mark a class as abstract. An `abstract` class\nmay have `formal` members, but may not be directly \ninstantiated. An enumerated class must be `abstract`."]},nm:"abstract"},Annotation:{pa:1,mt:"i",of:[{pk:".",tp:[{mt:"tp",pk:".",nm:"Annotation"},{mt:"tp",pk:".",nm:"Anything"},{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Anything"}],nm:"ConstrainedAnnotation"}],an:{see:["OptionalAnnotation","SequencedAnnotation","annotations","optionalAnnotation","sequencedAnnotations"],doc:["The supertype of all *annotation classes*. \n\n### Annotation classes\n\nAn *annotation class* must satisfy `Annotation`,\n[[OptionalAnnotation]],  or [[SequencedAnnotation]] and \nmust be annotated `final annotation`. For example:\n\n    \"An annotation class.\"\n    final annotation class Example(shared String description) \n          satisfies Annotation {}\n\nAnnotation classes which satisfy `Annotation` directly \nmay be applied to any program element that supports \nannotations (see [[Annotated]]). In practice, annotation \nclasses often satisfy [[OptionalAnnotation]] or \n[[SequencedAnnotation]] in order to prevent annotations \nbeing applied to inappropriate program elements.\n\nEach initializer parameter of an annotation class must \nhave one of the following types:\n\n* `Integer`, `Float`, `Character`, or `String`,\n* an enumerated type whose cases are all anonymous \n  classes, such as `Boolean`,\n* a subtype of [[ceylon.language.meta.declaration::Declaration]]\n* an annotation class,\n* `{T*}` or `[T*]` where `T` is a legal annotation \n  parameter type, or\n* any tuple type whose element types are legal annotation \n  parameter types.\n\nAn initializer parameter of an annotation class may be \nvariadic or defaulted.\n\n### Annotation constructors\n\nAn *annotation constructor* is simply a top level \nfunction, annotated with `annotation` whose return type \nis an annotation class type. For example:\n\n    \"An annotation constructor.\"\n    annotation Example example(String description=\"\") \n        => Example(description);\n\nEach parameter of an annotation constructor must have one \nof the following types:\n\n* `Integer`, `Float`, `Character`, or `String`,\n* an enumerated type whose cases are all anonymous classes, \n  such as `Boolean`,\n* a subtype of [[ceylon.language.meta.declaration::Declaration]],\n* an annotation type,\n* `{T*}` or `[T*]` where `T` is a legal annotation \n  constructor parameter type, or\n* any tuple type whose element types are legal annotation \n  constructor parameter types.\n\nA parameter of an annotation constructor may be variadic \nor defaulted.\n\nThe constructor must simply instantiate and return the \nannotation class, and there are strict rules about the \narguments to the instantiation.\n\nA given annotation class can have multiple annotation \nconstructors."]},nm:"Annotation"},Annotated:{pa:1,mt:"i",$m:{annotated:{$t:{pk:".",nm:"Boolean"},pa:5,mt:"m",tp:[{sts:[{pk:".",nm:"Annotation"}],nm:"Annotation"}],an:{doc:["true if this element has at least one annotation of the given annotation type."]},nm:"annotated"}},an:{see:["Annotation"],doc:["A program element that can\nbe annotated."]},nm:"Annotated"},SealedAnnotation:{super:{pk:".",nm:"Basic"},pa:561,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"SealedAnnotation"},{comp:"u",mt:"tp",l:[{pk:"ceylon.language.meta.declaration",nm:"ClassOrInterfaceDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ConstructorDeclaration"}]},{mt:"tp",pk:".",nm:"Anything"}],nm:"OptionalAnnotation"}],mt:"c",an:{doc:["The annotation class for the [[sealed]] annotation."]},nm:"SealedAnnotation"},Destroyable:{pa:1,sts:[{pk:".",nm:"Usable"}],mt:"i",$m:{destroy:{$t:{pk:".",nm:"Anything"},pa:5,ps:[[{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Throwable"}]},mt:"prm",an:{doc:["The exception propagating out of the body of the \n`try` statement, or `null` if no exception was\npropagated."]},nm:"error"}]],$ff:1,mt:"m",an:{doc:["Destroy this resource. Called when execution of the \nbody of the `try` statement ends, even if an exception \npropagates out of the body of the `try`."]},nm:"destroy"}},an:{see:["Obtainable"],tagged:["Basic types"],doc:["Abstract supertype of resources which are created at the \nbeginning of a `try` statement and destroyed when the \nstatement completes. Unlike an [[Obtainable]] resource, a \nsingle instance of `Destroyable` may not be reused between \nmultiple `try` statements or multiple executions of the \nsame `try` statement. \n\n    try (tx = Transaction()) {\n        ...\n    }\n\n- The resource is instantiated before the body of the `try` \n  statement is executed, and\n- [[destroy]] is called when execution of the body of the \n  `try` statement ends, even if an exception propagates out \n  of the body of the `try`."]},nm:"Destroyable"},shuffle:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Result"},{mt:"tp",nm:"FirstArgs"}],nm:"Callable"},{mt:"tp",nm:"SecondArgs"}],nm:"Callable"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Result"},{mt:"tp",nm:"SecondArgs"}],nm:"Callable"},{mt:"tp",nm:"FirstArgs"}],nm:"Callable"},mt:"prm",nm:"f"}]],mt:"m",tp:[{nm:"Result"},{sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"Anything"}],nm:"Sequential"}],nm:"FirstArgs"},{sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"Anything"}],nm:"Sequential"}],nm:"SecondArgs"}],an:{see:["curry"],tagged:["Functions"],doc:["Given a function with two parameter lists, return a \nfunction with the order of the argument lists reversed. The \nparameter lists may have any number of parameters.\n\nThat is, if `fun` has type `W(A,B)(X,Y,Z)` then \n`shuffle(fun)` has type `W(X,Y,Z)(A,B)`.\n\nThis function is often used in conjunction with `curry()`."]},nm:"shuffle"},Tuple:{super:{pk:".",nm:"Object"},pa:2145,sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"}],ps:[{$t:{nm:"First"},pa:67,mt:"prm",an:{doc:["The first element of this tuple. (The head of the \nlinked list.)"]},nm:"first",$hdn:1},{$t:{nm:"Rest"},pa:67,mt:"prm",an:{doc:["A tuple with the elements of this tuple, except for the\nfirst element. (The tail of the linked list.)"]},nm:"rest",$hdn:1}],mt:"c",$at:{rest:{$t:{nm:"Rest"},pa:67,mt:"a",an:{doc:["A tuple with the elements of this tuple, except for the\nfirst element. (The tail of the linked list.)"]},nm:"rest"},size:{$t:{pk:".",nm:"Integer"},pa:67,mt:"g",nm:"size"},last:{$t:{nm:"Element"},pa:67,mt:"g",an:{doc:["The last element of this tuple."]},nm:"last"},lastIndex:{$t:{pk:".",nm:"Integer"},pa:67,mt:"g",nm:"lastIndex"},first:{$t:{nm:"First"},pa:67,mt:"a",an:{doc:["The first element of this tuple. (The head of the \nlinked list.)"]},nm:"first"}},$m:{spanTo:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"spanTo"},spanFrom:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],mt:"m",nm:"spanFrom"},iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:67,mt:"m",nm:"iterator"},contains:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],mt:"m",an:{doc:["Determine if the given value is an element of this\ntuple."]},nm:"contains"},measure:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",nm:"measure"},withLeading:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]},{mt:"tp",nm:"Other"},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"First"},{mt:"tp",nm:"Rest"}],nm:"Tuple"}],nm:"Tuple"},pa:67,ps:[[{$t:{nm:"Other"},mt:"prm",an:{doc:["The first element of the resulting tuple."]},nm:"element"}]],mt:"m",tp:[{nm:"Other"}],an:{doc:["Return a new tuple that starts with the specified\n[[element]], followed by the elements of this tuple."]},nm:"withLeading"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"getFromFirst"},clone:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"First"},{mt:"tp",nm:"Rest"}],nm:"Tuple"},pa:67,mt:"m",an:{doc:["This tuple."]},nm:"clone"},withTrailing:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"First"},{comp:"u",l:[{comp:"u",l:[{nm:"Element"},{nm:"Other"}]},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"First"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],nm:"Sequence"}],nm:"Tuple"},pa:67,ps:[[{$t:{nm:"Other"},mt:"prm",an:{doc:["The last element of the resulting tuple."]},nm:"element"}]],mt:"m",tp:[{nm:"Other"}],an:{doc:["Return a new tuple containing the elements of this \ntuple, followed by the given [[element]]."]},nm:"withTrailing"},append:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"First"},{comp:"u",l:[{comp:"u",l:[{nm:"Element"},{nm:"Other"}]},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"First"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],nm:"Sequential"}],nm:"Tuple"},pa:67,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Sequential"},mt:"prm",an:{doc:["The list of elements to be appended."]},nm:"elements"}]],mt:"m",tp:[{nm:"Other"}],an:{doc:["Return a tuple containing the elements of this \ntuple, followed by the given [[elements]]."]},nm:"append"},span:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"end"}]],mt:"m",nm:"span"}},tp:[{dv:"out",nm:"Element"},{dv:"out",sts:[{nm:"Element"}],nm:"First"},{dv:"out",sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"}],def:{pk:".",nm:"Empty"},nm:"Rest"}],an:{tagged:["Sequences","Basic types","Collections"],by:["Gavin"],doc:["A _tuple_ is a typed linked list. Each instance of \n`Tuple` represents the value and type of a single link.\nThe attributes `first` and `rest` allow us to retrieve a \nvalue from the list without losing its static type \ninformation.\n\n    value point = Tuple(0.0, Tuple(0.0, Tuple(\"origin\")));\n    Float x = point.first;\n    Float y = point.rest.first;\n    String label = point.rest.rest.first;\n\nUsually, we abbreviate code involving tuples.\n\n    [Float,Float,String] point = [0.0, 0.0, \"origin\"];\n    Float x = point[0];\n    Float y = point[1];\n    String label = point[2];\n\nA list of types enclosed in brackets is an abbreviated \ntuple type. An instance of `Tuple` may be constructed by \nsurrounding a value list in brackets:\n\n    [String,String] words = [\"hello\", \"world\"];\n\nThe index operator with a literal integer argument is a \nshortcut for a chain of evaluations of `rest` and \n`first`. For example, `point[1]` means `point.rest.first`.\n\nA _terminated_ tuple type is a tuple where the type of\nthe last link in the chain is `Empty`. An _unterminated_ \ntuple type is a tuple where the type of the last link\nin the chain is `Sequence` or `Sequential`. Thus, a \nterminated tuple type has a length that is known\nstatically. For an unterminated tuple type only a lower\nbound on its length is known statically.\n\nHere, `point` is an unterminated tuple:\n\n    String[] labels = ... ;\n    [Float,Float,String*] point = [0.0, 0.0, *labels];\n    Float x = point[0];\n    Float y = point[1];\n    String? firstLabel = point[2];\n    String[] allLabels = point[2...];"]},nm:"Tuple"},span:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Range"},pa:1,ps:[[{$t:{nm:"Element"},mt:"prm",nm:"first"},{$t:{nm:"Element"},mt:"prm",nm:"last"}]],mt:"m",tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Enumerable"}],nm:"Element"}],an:{doc:["Produces a [[Range]] of adjacent [[Enumerable]] values \ngenerated by two endpoints: [[first]] and [[last]]. The \nrange includes both endpoints, and all values falling \n_between_ the endpoints.\n\n- For a recursive enumerable type, a value falls between \n  the endpoints if its [[offset|Enumerable.offset]] from \n  `first` is less than the offset of `last` from `first`.\n- For a linear enumerable type, a value falls between the\n  endpoints if the \n  [[sign of its offset|Enumerable.offsetSign]] from `first` \n  is the same as the sign of the offset of `last` from \n  `first` and the sign of its offset from `last` is the \n  opposite of the sign of the offset of `last` from `first`.\n\nMore precisely, if `x`, `first`, and `last` are of \n`Enumerable` type `X`, then `x in first..last` if and \nonly if:\n\n- `X` is recursive and `x.offset(first)<last.offset(first)`,\n or\n- `X` is linear and \n `x.offsetSign(first)==last.offsetSign(first)` and\n `x.offsetSign(last)==-last.offsetSign(first)`.\n\nFor a linear enumerable type, a range is either \n[[increasing|Range.increasing]] or \n[[decreasing|Range.decreasing]]:\n\n- in an increasing range, a value occurs before its \n [[successor|Ordinal.successor]] and after its \n [[predecessor|Ordinal.predecessor]], but\n- in a decreasing range, a value occurs after its \n `successor` and before its `predecessor`.\n\nThe direction of the range depends upon the sign of the\noffset of `last` from `first`: \n\n- if `last.offsetSign(first)>=0` the range is increasing,\n  but\n- if `last.offsetSign(first)<0`, the range is decreasing.\n\nA range for a recursive enumerable type is always \nincreasing.\n\nThe _span operator_ `..` is an abbreviation for `span()`:\n\n    for (i in min..max) { ... }\n    if (char in 'A'..'Z') { ... }\n\nThe span operator accepts the first and last values of \nthe range. It may produce an increasing range:\n\n    0..5    \/\/ [0, 1, 2, 3, 4, 5]\n    0..0    \/\/ [0]\n\nOr it may produce a decreasing range:\n\n    5..0    \/\/ [5, 4, 3, 2, 1, 0]\n    0..-5   \/\/ [0, -1, -2, -3, -4, -5]"]},nm:"span"},Null:{super:{pk:".",nm:"Anything"},pa:257,mt:"c",of:[{pk:".",nm:"null"}],an:{see:["null"],tagged:["Basic types"],by:["Gavin"],doc:["The type of the [[null]] value. Any union type of form \n`Null|T` is considered an _optional_ type, whose values\ninclude `null`. Any type of this form may be written as\n`T?` for convenience.\n\nThe `if (exists ... )` construct, or, alternatively,\n`assert (exists ...)`, may be used to narrow an optional \ntype to a _definite_ type, that is, a subtype of \n[[Object]]:\n\n    String? firstArg = process.arguments.first;\n    if (exists firstArg) {\n        print(\"hello \" + firstArg);\n    }\n\nThe `else` operator evaluates its second operand if and \nonly if its first operand is `null`:\n\n    String name = process.arguments.first else \"world\";\n\nThe `then` operator evaluates its second operand when\nits first operand evaluates to `true`, and produces `null` \notherwise:\n\n    Float? diff = x>=y then x-y;\n\nThe `?.` operator may be used to evaluate an attribute\nor invoke a method of an optional type, evaluating to\n`null` when the receiver is missing:\n\n    value [firstName, lastName] =\n            let (fullName = process.arguments.first?.trimmed,\n                 bits = fullName?.split()?.sequence() else []) \n                    [bits[0], bits[1]];\n    assert (exists firstName, exists lastName);\n\nNo equivalence relation is defined for `Null`. In \nparticular, neither `null==null` nor `null===null` are\nconsidered meaningful. Therefore, `Null` is neither\n[[Identifiable]], nor does it define \n[[value equality|Object.equals]]."]},nm:"Null"},commaList:{$t:{pk:".",nm:"String"},ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Anything"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"elements"}]],mt:"m",nm:"commaList"},SearchableList:{pa:1,sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"}],mt:"i",$m:{occurrences:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:9,ps:[[{$t:{nm:"Element"},mt:"prm",an:{doc:["The value. If null, it is considered to occur\nat any index in this list with a null element."]},nm:"element"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The smallest index to consider."]},nm:"from"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The number of indexes to consider."]},nm:"length"}]],mt:"m",an:{doc:["The indexes in this list at which the given \n[[value|element]] occurs."]},nm:"occurrences"},firstOccurrence:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:9,ps:[[{$t:{nm:"Element"},mt:"prm",an:{doc:["The value. If null, it is considered to occur\nat any index in this list with a null element."]},nm:"element"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The smallest index to consider."]},nm:"from"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The number of indexes to consider."]},nm:"length"}]],mt:"m",an:{doc:["The first index in this list at which the given \n[[value|element]] occurs, that falls within the segment \n`from:length` defined by the optional \n[[starting index|from]] and [[length]]."]},nm:"firstOccurrence"},lastOccurrence:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:9,ps:[[{$t:{nm:"Element"},mt:"prm",an:{doc:["The value. If null, it is considered to occur\nat any index in this list with a null element."]},nm:"element"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The smallest index to consider, interpreted as\na reverse index counting from the _end_ of the \nlist, where `0` is the last element of the list, \nand `size-1` is the first element of the list."]},nm:"from"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The number of indexes to consider."]},nm:"length"}]],mt:"m",an:{doc:["The last index in this list at which the given \n[[value|element]] occurs, that falls within the range \n`size-length-from:length` defined by the optional \n[[starting index|from]], interpreted as a reverse index \ncounting from the _end_ of the list, and [[length]]."]},nm:"lastOccurrence"},firstInclusion:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:9,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},mt:"prm",nm:"sublist"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The smallest index to consider."]},nm:"from"}]],mt:"m",an:{doc:["The first index in this list at which the given \n[[list|sublist]] occurs as a sublist, that is greater \nthan or equal to the optional [[starting index|from]]."]},nm:"firstInclusion"},includesAt:{$t:{pk:".",nm:"Boolean"},pa:9,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",an:{doc:["The index at which the [[sublist]] might occur."]},nm:"index"},{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},mt:"prm",nm:"sublist"}]],mt:"m",an:{doc:["Determine if the given [[list|sublist]] occurs as a \nsublist at the given index of this list."]},nm:"includesAt"},includes:{$t:{pk:".",nm:"Boolean"},pa:9,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},mt:"prm",nm:"sublist"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The smallest index to consider."]},nm:"from"}]],mt:"m",an:{doc:["Determine if the given [[list|sublist]] occurs as a \nsublist at some index in this list, at any index that \nis greater than or equal to the optional \n[[starting index|from]]."]},nm:"includes"},occursAt:{$t:{pk:".",nm:"Boolean"},pa:9,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",an:{doc:["The index at which the value might occur."]},nm:"index"},{$t:{nm:"Element"},mt:"prm",an:{doc:["The value. If null, it is considered to occur\nat any index in this list with a null element."]},nm:"element"}]],mt:"m",an:{doc:["Determines if the given [[value|element]] occurs at the \ngiven index in this list."]},nm:"occursAt"},occurs:{$t:{pk:".",nm:"Boolean"},pa:9,ps:[[{$t:{nm:"Element"},mt:"prm",an:{doc:["The value. If null, it is considered to occur\nat any index in this list with a null element."]},nm:"element"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The smallest index to consider."]},nm:"from"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The number of indexes to consider."]},nm:"length"}]],mt:"m",an:{doc:["Determines if the given [[value|element]] occurs as an \nelement of this list, at any index that falls within\nthe segment `from:length` defined by the optional \n[[starting index|from]] and [[length]]."]},nm:"occurs"},inclusions:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:9,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},mt:"prm",nm:"sublist"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The smallest index to consider."]},nm:"from"}]],mt:"m",an:{doc:["The indexes in this list at which the given \n[[list|sublist]] occurs as a sublist, that are greater \nthan or equal to the optional [[starting index|from]]."]},nm:"inclusions"},lastInclusion:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:9,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"List"},mt:"prm",nm:"sublist"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The smallest index to consider, interpreted as\na reverse index counting from the _end_ of the \nlist, where `0` is the last element of the list, \nand `size-1` is the first element of the list."]},nm:"from"}]],mt:"m",an:{doc:["The last index in this list at which the given \n[[list|sublist]] occurs as a sublist, that falls within \nthe range `0:size-from+1-sublist.size` defined by the \noptional [[starting index|from]], interpreted as a \nreverse index counting from the _end_ of the list."]},nm:"lastInclusion"}},tp:[{nm:"Element"}],an:{see:["String","Array"],doc:["A [[List]] which can be efficiently searched for \noccurrences of a given element, or for inclusions of a \ngiven sublist of elements. This interface provides \noperations for finding:\n\n- _occurrences_ of a single value in the list, and\n- _inclusions_ of a given sublist of values in the list.\n\nOccurrences and inclusions are identified by a list index\nat which the value or sublist of values occurs in the list. \nIn the case of an inclusion, it is the index of the first \nmatching value from the sublist.\n\nInclusions may overlap. For example:\n\n    \"yoyoyoyoyo\".inclusions(\"yoy\")\n\nproduces the stream `{ 0, 2, 4, 6 }`.\n\nAn empty list is considered to be included at every index,\nincluding the index [[size]] at the very end of the \nlist. Thus:\n\n    \"hello\".inclusions(\"\")\n\nproduces the stream `{ 0, 1, 2, 3, 4, 5 }`, with 6 \ninclusions in a string of length 5. \n\nIn particular:\n\n- `\"\".inclusions(\"x\")` is the empty stream `{}`, but\n- `\"\".inclusions(\"\")` is the stream `{ 0 }`."]},nm:"SearchableList"},TagsAnnotation:{super:{pk:".",nm:"Basic"},pa:561,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"TagsAnnotation"},{mt:"tp",pk:".",nm:"Annotated"},{mt:"tp",pk:".",nm:"Anything"}],nm:"OptionalAnnotation"}],ps:[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"String"}],nm:"Sequential"},pa:1,mt:"prm",an:{doc:["The tags, in plain text."]},seq:1,nm:"tags"}],mt:"c",$at:{tags:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"String"}],nm:"Sequential"},pa:1,mt:"a",an:{doc:["The tags, in plain text."]},nm:"tags"}},an:{doc:["The annotation class for the [[tagged]] annotation."]},nm:"TagsAnnotation"},flatten:{$t:{pk:".",tp:[{mt:"tp",nm:"Return"},{mt:"tp",nm:"Args"}],nm:"Callable"},pa:65,ps:[[{$t:{nm:"Return"},ps:[[{$t:{nm:"Args"},mt:"prm",nm:"tuple"}]],mt:"prm",$pt:"f",nm:"tupleFunction"}]],mt:"m",tp:[{nm:"Return"},{sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"Anything"}],nm:"Sequential"}],nm:"Args"}],an:{see:["unflatten"],tagged:["Functions"],doc:["Given a function with a single parameter of tuple type \n`[P1, P2, ..., Pn]`, return a function with multiple \nparameters of type `P1`, `P2`, ..., `Pn`.\n\nThat is, if `fun` has type `W([X,Y,Z])` then `flatten(fun)` \nhas type `W(X,Y,Z)`.\n\nIn the case of a function whose parameter type is a \nsequence type or unterminated tuple type, the returned \nfunction is variadic:\n\n- if the given function accepts `[S*]`, the returned \n  function has a single variadic parameter of type `S*`,\n- if the given function accepts `[S+]`, the returned \n  function has a single variadic parameter of type `S+`,\n- if the given function accepts `[P1, P2, ..., Pn, S*]`, \n  the returned function has multiple parameters with types\n  `P1`, `P2`, ..., `Pn`, `S*`, or\n- if the given function accepts `[P1, P2, ..., Pn, S+]`,\n  the returned function has multiple parameters with types\n  `P1`, `P2`, ..., `Pn`, `S+`."]},nm:"flatten"},identical:{$t:{pk:".",nm:"Boolean"},pa:1,ps:[[{$t:{pk:".",nm:"Identifiable"},mt:"prm",an:{doc:["An object with well-defined identity."]},nm:"x"},{$t:{pk:".",nm:"Identifiable"},mt:"prm",an:{doc:["A second object with well-defined identity."]},nm:"y"}]],mt:"m",an:{see:["identityHash"],tagged:["Comparisons"],doc:["Determine if the arguments are [[identical]]. Equivalent to\n`x===y`. Only instances of [[Identifiable]] have \nwell-defined identity."]},nm:"identical"},Ranged:{st:"Subrange",pa:1,sts:[{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"}],mt:"i",of:[{nm:"Subrange"}],$m:{spanTo:{$t:{nm:"Subrange"},pa:5,ps:[[{$t:{nm:"Index"},mt:"prm",nm:"to"}]],mt:"m",an:{doc:["Obtain a span containing the elements between the first \nindex of this ranged stream and given [[end index|to]].\n\nThe span should contain elements of this stream, up to \nthe element at the given [[ending index|to]], in the \nsame order as they are produced by the [[iterator]] of\nthe stream.\n\nWhen the given index does not belong to this ranged \nstream, the behavior is implementation dependent."]},nm:"spanTo"},spanFrom:{$t:{nm:"Subrange"},pa:5,ps:[[{$t:{nm:"Index"},mt:"prm",nm:"from"}]],mt:"m",an:{doc:["Obtain a span containing the elements between the given\n[[starting index|from]] and the last index of this \nranged object.\n\nThe span should contain elements of this stream, \nstarting from the element at the given [[starting \nindex|from]], in the same order as they are produced by \nthe [[iterator]] of the stream.\n\nWhen the given index does not belong to this ranged \nstream, the behavior is implementation dependent."]},nm:"spanFrom"},measure:{$t:{nm:"Subrange"},pa:5,ps:[[{$t:{nm:"Index"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",an:{doc:["Obtain a measure containing the mapped values starting \nfrom the given [[starting index|from]], with the given \n[[length]]. If `length<=0`, the resulting measure is \nempty.\n\nThe measure should contain the given [[number|length]] \nof elements of this stream, starting from the element \nat the given [[starting index|from]], in the same order \nas they are produced by the [[iterator]] of the stream. \nIn the case where the iterator would be exhausted \nbefore [[length]] elements are produced, the resulting \nmeasure contains only those elements which were \nproduced before the iterator was exhausted, and the \nlength of the measure is less then the given `length`.\n\nWhen the given index does not belong to this ranged \nobject, the behavior is implementation dependent."]},nm:"measure"},span:{$t:{nm:"Subrange"},pa:5,ps:[[{$t:{nm:"Index"},mt:"prm",nm:"from"},{$t:{nm:"Index"},mt:"prm",nm:"to"}]],mt:"m",an:{doc:["Obtain a span containing the elements between the two \ngiven indices. \n\nThe span should contain elements of this stream, \nstarting from the element at the given [[starting \nindex|from]], and ending with the element at the given \n[[ending index|to]], in the same order as they are \nproduced by the [[iterator]] of the stream, except when \nthe ending index occurs earlier than the starting index, \nin which case they occur in the opposite order.\n\nWhen one or both of the given indices does not belong \nto this ranged stream, the behavior is implementation \ndependent."]},nm:"span"}},tp:[{dv:"in",nm:"Index"},{dv:"out",nm:"Element"},{dv:"out",sts:[{pk:".",tp:[{mt:"tp",nm:"Index"},{mt:"tp",nm:"Element"},{mt:"tp",nm:"Subrange"}],nm:"Ranged"}],nm:"Subrange"}],an:{see:["List","Sequence","String"],doc:["Abstract supertype of _ranged streams_ mapping a range of \ndiscrete indices to elements of the stream, and supporting \noperations that produce a subrange of indexed elements. The \ntype parameter [[Subrange]] abstracts the type of the \nresulting subrange. A subrange may be obtained from an \ninstance of `Ranged` using the _span_ and _measure_ \noperators.\n\nOften, in a [[List]] or sorted map for example, an index\nand its element are distinct values. Sometimes, in a sorted \nset for example, the index and element are identical.\n\nThe _span_ operator accepts the first and last indices of \nthe subrange.\n\n    print(\"hello world\"[0..5]); \/\/prints \"hello\"\n    print(\"hello world\"[6..6]); \/\/prints \"w\"\n\nIf the last index is smaller than the first index, the\nsubrange is reversed.\n\n    print(\"hello world\"[5..0]); \/\/prints \"olleh\"\n\nIf the range of indices identified by the first and last\nindices is outside the range of indices of this object, an\nempty subrange is produced.\n\n    print(\"hello world\"[-5..-1]); \/\/prints \"\"\n    print(\"hello world\"[11..11]); \/\/prints \"\"\n\nThe first index may be omitted, implying that the subrange\nextends forward from the smallest possible index (in this\ncase `runtime.minIntegerValue-1`) to the given index.\n\n    print(\"hello world\"[...5]) \/\/prints \"hello\"\n\nIf the first index is before the first index of this object, \nan empty subrange is produced. (A reversed subrange is \nnever produced.)\n\n    print(\"hello world\"[-5...]); \/\/prints \"\"\n\nThe last index may be omitted, implying that the subrange \nextends forward from the given index to the largest \npossible index (in this case `runtime.maxIntegerValue+1`).\n\n    print(\"hello world\"[6...]) \/\/prints \"world\"\n\nIf the last index is after the last index of this object, \nan empty subrange is produced. (A reversed subrange is \nnever produced.)\n\n    print(\"hello world\"[11...]); \/\/prints \"\"\n\nThe _measure_ operator accepts the first index and maximum \nlength of the subrange.\n\n    print(\"hello world\"[6:5]) \/\/prints \"world\"\n    print(\"hello world\"[6:0]) \/\/prints \"\"\n\nIf the length is nonpositive, the subrange is empty. If the\nrange of indices identified by the first index and length\nis outside the range of indices of this object, an empty\nsubrange is produced. (A reversed subrange is never \nproduced.)\n\n    print(\"hello world\"[-3:3]) \/\/prints \"\"\n    print(\"hello world\"[11:3]) \/\/prints \"\"\n    print(\"hello world\"[6:-3]) \/\/prints \"\"\n\nThe span and measure operations must be consistent. That is, \nfor every pair of indices `x` and `y` in the ranged object \n`ranged` such that `y` does not occur before `x` and the \nspan `ranged[x..y]` has length `n`:\n\n- `ranged[x..y]==ranged[x:n]`."]},nm:"Ranged"},aIntUpper:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"aIntUpper"},aliased:{$t:{pk:".",nm:"AliasesAnnotation"},pa:513,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"String"}],nm:"Sequential"},mt:"prm",an:{doc:["The aliases, in plain text."]},seq:1,nm:"aliases"}]],mt:"m",an:{doc:["Annotation to specify a list of aliases that tools such as auto-completion and\nquick-fixes should consider, to help users find a declaration using its aliases."]},nm:"aliased"},DeprecationAnnotation:{super:{pk:".",nm:"Basic"},pa:561,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"DeprecationAnnotation"},{mt:"tp",pk:".",nm:"Annotated"},{mt:"tp",pk:".",nm:"Anything"}],nm:"OptionalAnnotation"}],ps:[{$t:{pk:".",nm:"String"},pa:1,mt:"prm",an:{doc:["A description, in Markdown syntax, of why the program \nelement is deprecated, and of what alternatives are \navailable."]},nm:"description"}],mt:"c",$at:{reason:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"String"}]},pa:1,mt:"g",an:{doc:["A description, in Markdown syntax, of why the program \nelement is deprecated, and what alternatives are \navailable, or `null`."]},nm:"reason"},description:{$t:{pk:".",nm:"String"},pa:1,mt:"a",an:{doc:["A description, in Markdown syntax, of why the program \nelement is deprecated, and of what alternatives are \navailable."]},nm:"description"}},an:{doc:["The annotation class for the [[deprecated]] annotation."]},nm:"DeprecationAnnotation"},AssertionError:{super:{pk:".",nm:"Throwable"},pa:65,ps:[{$t:{pk:".",nm:"String"},mt:"prm",an:{doc:["A message describing the assertion that failed. In the\ncase of an `assert` statement, it is the text specified\nby the `doc` annotation.\n\nCertain tools interpret this message as \nmarkdown-formatted text."]},nm:"message",$hdn:1}],mt:"c",$at:{message$9g6fel:{$t:{pk:".",nm:"String"},mt:"a",an:{doc:["A message describing the assertion that failed. In the\ncase of an `assert` statement, it is the text specified\nby the `doc` annotation.\n\nCertain tools interpret this message as \nmarkdown-formatted text."]},nm:"message"}},an:{doc:["An error that occurs due to an incorrectly written program. \nAn instance is thrown when an assertion fails, that is, \nwhen a condition in an `assert` statement evaluates to \nfalse at runtime.\n\nThe assertion\n\n    \"x must be positive\"\n    assert (x>0);\n\nhas almost the same effect as this `if` statement\n    \n    if (!x>0) {\n        throw AssertionError(\"x must be positive\");\n    }"]},nm:"AssertionError"},maximumIntegerExponent:{$t:{pk:".",nm:"Integer"},mt:"a",an:{doc:["The maximum number of decimal digits that can be \nrepresented by an [[Integer]]."]},nm:"maximumIntegerExponent"},Character:{super:{pk:".",nm:"Object"},pa:97,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"Character"}],nm:"Comparable"},{pk:".",tp:[{mt:"tp",pk:".",nm:"Character"}],nm:"Enumerable"}],ps:[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"character"}],mt:"c",$at:{titlecased:{$t:{pk:".",nm:"Character"},pa:65,mt:"a",an:{doc:["The title case representation of this character."]},nm:"titlecased"},uppercase:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Determine if this is an uppercase representation of the\ncharacter. That is, if its Unicode general category is \n*Lu*."]},nm:"uppercase"},lowercased:{$t:{pk:".",nm:"Character"},pa:65,mt:"a",an:{see:["String.lowercased"],doc:["The lowercase representation of this character.\n\nConversion of uppercase characters to lowercase is\nperformed according to a locale-independent mapping\nthat produces incorrect results in certain locales\n(e.g. `tr-TR`).\n\nFurthermore, this conversion always produces a single\ncharacter, which is incorrect for characters whose\nuppercase representation comprises multiple characters,\nfor example İ. \nThus,\n\n- `'İ'.uppercased`\n  evaluates to `'i'`, whereas\n- `\"İ\".uppercased`\n  evaluates, more correctly, to the string \n  `\"i̇\"`.\n\nTherefore, for most purposes, it is better to use \n`char.string.lowercased` instead of `char.lowercased`."]},nm:"lowercased"},successor:{$t:{pk:".",nm:"Character"},pa:67,mt:"a",an:{doc:["The character with the unicode code point that is one\nless than this character."]},nm:"successor"},string:{$t:{pk:".",nm:"String"},pa:67,mt:"a",an:{doc:["A string containing just this character."]},nm:"string"},lowercase:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Determine if this is a lowercase representation of the\ncharacter. That is, if its Unicode general category is \n*Ll*."]},nm:"lowercase"},control:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Determine if this character is an ISO control \ncharacter."]},nm:"control"},integer:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{aliased:["codePoint"],doc:["The Unicode code point of the character, an [[Integer]]\nin the range `0..#10FFFF`."]},nm:"integer"},predecessor:{$t:{pk:".",nm:"Character"},pa:67,mt:"a",an:{doc:["The character with the unicode code point that is one\ngreater than this character."]},nm:"predecessor"},character$f3csq2:{$t:{pk:".",nm:"Character"},mt:"a",nm:"character"},uppercased:{$t:{pk:".",nm:"Character"},pa:65,mt:"a",an:{see:["String.uppercased"],doc:["The uppercase representation of this character, in the\n[[system]] default locale.\n\nConversion of lowercase characters to uppercase is\nperformed according to a locale-independent mapping\nthat produces incorrect results in certain locales\n(e.g. `tr-TR`).\n\nFurthermore, this conversion always produces a single\ncharacter, which is incorrect for characters whose\nuppercase representation comprises multiple characters,\nfor example ß. Thus,\n\n- `'ß'.uppercased`\n  evaluates to `'ß'`, \n  whereas\n- `\"ß\".uppercased`\n  evaluates, more correctly, to the string `\"SS\"`.\n\nTherefore, for most purposes, it is better to use \n`char.string.uppercased` instead of `char.uppercased`."]},nm:"uppercased"},titlecase:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Determine if this is a title case representation of the\ncharacter. That is, if its Unicode general category is \n*Lt*."]},nm:"titlecase"},letter:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Determine if this character is a letter. That is, if \nits Unicode general category is *Lu*, *Ll*, *Lt*, *Lm*,\nor *Lo*."]},nm:"letter"},whitespace:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Determine if this character is a whitespace character. \nThe following characters are whitespace characters:\n\n- *LINE FEED*, `\\n` or `\\{#000A}`,\n- *FORM FEED*, `\\f` or `\\{#000C}`,\n- *CARRIAGE RETURN*, `\\r` or `\\{#000D}`,\n- *HORIZONTAL TABULATION*, `\\t` or `\\{#0009}`,\n- *LINE TABULATION*, `\\{#000B}`,\n- *FILE SEPARATOR*, `\\{#001C}`,\n- *GROUP SEPARATOR*, `\\{#001D}`,\n- *RECORD SEPARATOR*, `\\{#001E}`,\n- *UNIT SEPARATOR*, `\\{#001F}`, and\n- any Unicode character in the general category *Zs*, \n  *Zl*, or *Zp* that is not a non-breaking space."]},nm:"whitespace"},hash:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",an:{doc:["The code point of the character."]},nm:"hash"},digit:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Determine if this character is a numeric digit. That \nis, if its Unicode general category is *Nd*."]},nm:"digit"}},$m:{largerThan:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"other"}]],mt:"m",nm:"largerThan"},compare:{$t:{pk:".",nm:"Comparison"},pa:67,ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"other"}]],mt:"m",an:{doc:["Compare this character with the given string character, \naccording to the Unicode code points of the characters."]},nm:"compare"},smallerThan:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"other"}]],mt:"m",nm:"smallerThan"},offset:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"other"}]],mt:"m",nm:"offset"},offsetSign:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"other"}]],mt:"m",nm:"offsetSign"},notLargerThan:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"other"}]],mt:"m",nm:"notLargerThan"},equals:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],mt:"m",an:{doc:["Determines if the given object is a character with the\nsame code point as this character."]},nm:"equals"},neighbour:{$t:{pk:".",nm:"Character"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"offset"}]],mt:"m",nm:"neighbour"},notSmallerThan:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"other"}]],mt:"m",nm:"notSmallerThan"}},an:{see:["String"],tagged:["Basic types","Strings"],by:["Gavin"],doc:["A 32-bit [Unicode][] character.\n\nLiteral characters may be written between single quotes:\n\n    ' '\n    '\\n'\n    '\\{#03C0}'\n    '\\{GREEK SMALL LETTER PI}'\n\nEvery `Character` has a unique [[Integer]]-valued Unicode \n_code point_.\n\n    Integer piCodePoint = '\\{GREEK SMALL LETTER PI}'.integer; \/\/ #03C0\n    Character pi = #03C0.character; \/\/ GREEK SMALL LETTER PI\n\nCharacters are [[Enumerable]], so character ranges may be\nproduced using the [[measure]] and [[span]] operators.\n\n    value lowerLatinLetters = 'a'..'z';\n    value upperLatinLetters = 'A':26;\n\nCharacters have a [[natural order|Comparable]] determined\nby their Unicode code points. So, for example, `'a'<'b'`,\nsince `'a'.integer<'b'.integer`.\n\n[Unicode]: http:\/\/www.unicode.org\/"]},nm:"Character"},Resource:{pa:1,mt:"i",$at:{size:{$t:{pk:".",nm:"Integer"},pa:5,mt:"a",an:{doc:["The size of the resource, in bytes."]},nm:"size"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},name:{$t:{pk:".",nm:"String"},pa:9,mt:"g",an:{doc:["The name of the resource; usually the filename."]},nm:"name"},uri:{$t:{pk:".",nm:"String"},pa:5,mt:"a",an:{doc:["The full path to the resource, expressed as a URI. For\na resource packaged within a module archive, this \nincludes both the path to the module archive file, and\nthe path of the resource within the module archive."]},nm:"uri"}},$m:{textContent:{$t:{pk:".",nm:"String"},pa:5,ps:[[{$t:{pk:".",nm:"String"},def:1,mt:"prm",nm:"encoding"}]],mt:"m",an:{doc:["Retrieves the contents of the resource as a [[String]],\nusing the specified encoding."]},nm:"textContent"}},an:{see:["Module.resourceByPath"],tagged:["Environment"],by:["Enrique Zamudio"],doc:["A file packaged within a module. A `Resource` may be \nobtained by calling [[Module.resourceByPath]], passing\na path that identifies the resource file.\n\nThe resource file itself must be placed in a _resource \ndirectory_ at compilation time, in a subdirectory \ncorresponding to the module to which the resource belongs.\nThe compiler is responsible for packaging the resource \nfile in a location accessible to the program at runtime:\n\n- In the case of a module compiled for execution on the \n  JVM, the resource file will be included in the `.car` \n  archive.\n- In the case of compilation to JavaScript, the resource\n  file will be copied to a `module-resources` directory\n  in the module repository.\n\nSuppose the following code occurs in a module named\n`com.redhat.example`:\n    \n    assert (exists resource \n       = `module`.resourceByPath(\"file.txt\"));\n    print(resource.textContent());\n\nThen the resource named `file.text` should be placed in \nthe subdirectory `com\/redhat\/example\/` of the resource \ndirectory.\n\nPaths with no leading `\/` are relative to the module's\nsubdirectory of the resource directory. Alternatively, a \nresource may be identified by a fully-qualified path \nbeginning with `\/`, for example:\n\n    assert (exists resource \n       = `module`.resourceByPath(\"\/com\/redhat\/example\/file.txt\"));\n    print(resource.textContent());"]},nm:"Resource"},comparing:{$t:{pk:".",nm:"Comparison"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:".",nm:"Comparison"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{comp:"u",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"Value"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Value"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"}],nm:"Tuple"}],nm:"Callable"}],nm:"Sequential"},mt:"prm",seq:1,nm:"comparators"}],[{$t:{nm:"Value"},mt:"prm",nm:"x"},{$t:{nm:"Value"},mt:"prm",nm:"y"}]],mt:"m",tp:[{dv:"in",nm:"Value"}],an:{see:["byDecreasing","byIncreasing","Iterable.max","Iterable.sort"],tagged:["Comparisons"],doc:["A single comparator function which delegates to each of the \ngiven [[comparator functions|comparators]] in turn, \nreturning the first result of [[smaller]] or [[larger]] if \nany, or returning [[equal]] otherwise.\n\nConsider the following type:\n\n    class Person(shared Integer age, shared String name) {}\n\nA stream of `Person`s may be sorted by `age`, breaking ties \nby `name`, like this:\n\n    people.sort(comparing(byDecreasing(Person.age), byIncreasing(Person.name)))\n\nIf no `comparators` are given, the resulting comparator\nalways returns `equal`.\n\nThis function is intended for use with [[Iterable.sort]]\nand [[Iterable.max]]."]},nm:"comparing"},runtime:{super:{pk:".",nm:"Basic"},pa:65,mt:"o",$at:{minIntegerValue:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{see:["Integer"],doc:["The smallest [[Integer]] value that can be represented \nby the runtime.\n\nIt is the minimum `Integer` that can be distinguished \nfrom its successor using below formula:\n\n`Integer(n-1) = Integer(n) - 1` with `Integer(0) = 0`"]},nm:"minIntegerValue"},epsilon:{$t:{pk:".",nm:"Float"},pa:65,mt:"a",an:{doc:["The _machine epsilon_ for [[floating point|Float]]\nvalues. That is, the smallest value `e` such that:\n\n    1.0 + e > 1.0"]},nm:"epsilon"},integerSize:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{see:["Integer"],doc:["The number of bits used to represent the value of an \n[[Integer]]."]},nm:"integerSize"},maxIntegerValue:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{see:["Integer"],doc:["The largest [[Integer]] value that can be represented \nby the runtime.\n\nIt is the maximum `Integer` that can be distinguished \nfrom its predecessor using below formula:\n\n`Integer(n+1) = Integer(n) + 1` with `Integer(0) = 0`"]},nm:"maxIntegerValue"},maxFloatValue:{$t:{pk:".",nm:"Float"},pa:65,mt:"a",an:{doc:["The largest finite [[Float]] value that can be \nrepresented by the runtime."]},nm:"maxFloatValue"},maxExactIntegralFloat:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{see:["Integer.float"],doc:["The largest [[Integer]] that can be exactly represented\nas a [[Float]] without loss of precision. The negative\nof this value is the smallest `Integer` that can be\nexactly represented as a `Float`."]},nm:"maxExactIntegralFloat"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},name:{$t:{pk:".",nm:"String"},pa:65,mt:"a",an:{doc:["The name of the runtime \/ virtual machine this process \nis running on."]},nm:"name"},integerAddressableSize:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{doc:["The number of bits of [[Integer]] instances which may \nbe manipulated via the methods inherited from\n[[Binary]]."]},nm:"integerAddressableSize"},version:{$t:{pk:".",nm:"String"},pa:65,mt:"a",an:{doc:["The version of the runtime \/ virtual machine this \nprocess is running on."]},nm:"version"},maxArraySize:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{see:["Array"],doc:["The maximum size of an [[Array]] that is possible for \nthis runtime. Note that this is a theoretical limit \nonly. In practice it is usually impossible to allocate \nan array of this size, due to memory constraints."]},nm:"maxArraySize"},minFloatValue:{$t:{pk:".",nm:"Float"},pa:65,mt:"a",an:{doc:["The smallest positive nonzero [[Float]] value that can \nbe represented by the runtime."]},nm:"minFloatValue"}},an:{see:["process","language","system","operatingSystem"],tagged:["Environment"],doc:["Represents the machine and virtual machine on which the \ncurrent process is executing.\n\nHolds information about runtime name, version and about \ninherent limitations like minimum\/maximum values that can \nbe represented by the runtime."]},nm:"runtime"},finished:{super:{pk:".",nm:"Finished"},pa:1,mt:"o",$at:{string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"}},an:{see:["Iterator"],tagged:["Streams"],doc:["A value that indicates that an [[Iterator]] is exhausted \nand has no more values to return."]},nm:"finished"},Sequence:{pa:17,sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Iterable"}],mt:"i",$at:{rest:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:7,mt:"a",an:{doc:["The rest of the sequence, without the first element."]},nm:"rest"},last:{$t:{nm:"Element"},pa:7,mt:"a",an:{doc:["The last element of the sequence, that is, the element\nwith index `sequence.lastIndex`."]},nm:"last"},size:{$t:{pk:".",nm:"Integer"},pa:7,mt:"a",an:{doc:["The non-negative length of this sequence, that is, the\nnumber of elements in this sequence."]},nm:"size"},string:{$t:{pk:".",nm:"String"},pa:11,mt:"g",nm:"string"},keys:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"}],nm:"Range"},pa:11,mt:"g",an:{doc:["An integer [[Range]] containing all indexes of this \nsequence, that is, the range `0..sequence.lastIndex`."]},nm:"keys"},lastIndex:{$t:{pk:".",nm:"Integer"},pa:11,mt:"g",an:{see:["size"],doc:["The index of the last element of the sequence."]},nm:"lastIndex"},first:{$t:{nm:"Element"},pa:7,mt:"a",an:{doc:["The first element of the sequence, that is, the element\nwith index `0`."]},nm:"first"},reversed:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"},pa:11,mt:"g",an:{doc:["A sequence containing the elements of this sequence in\nreverse order to the order in which they occur in this\nsequence."]},nm:"reversed"},empty:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"g",an:{doc:["Returns `false`, since every `Sequence` contains at\nleast one element."]},nm:"empty"}},$m:{spanFrom:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:11,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],mt:"m",nm:"spanFrom"},getElement$kis5ex:{$t:{nm:"Element"},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"getElement"},withLeading:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Other"},{comp:"u",l:[{nm:"Element"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"Other"},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"}],nm:"Tuple"},pa:11,ps:[[{$t:{nm:"Other"},mt:"prm",nm:"element"}]],mt:"m",tp:[{nm:"Other"}],an:{doc:["Return a nonempty sequence containing the given \n[[element]], followed by the elements of this \nsequence."]},nm:"withLeading"},prepend:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],nm:"Sequence"},pa:11,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Sequential"},mt:"prm",nm:"elements"}]],mt:"m",tp:[{nm:"Other"}],an:{doc:["Return a nonempty sequence containing the given \n[[elements]], followed by the elements of this \nsequence."]},nm:"prepend"},sort:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"},pa:11,ps:[[{$t:{pk:".",nm:"Comparison"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],mt:"prm",$pt:"f",an:{doc:["The function comparing pairs of elements."]},nm:"comparing"}]],mt:"m",$m:{comparing$kwry1o:{$t:{pk:".",nm:"Comparison"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],mt:"m",an:{doc:["The function comparing pairs of elements."]},nm:"comparing"}},an:{doc:["A nonempty sequence containing the elements of this\ncontainer, sorted according to a function imposing a \npartial order upon the elements."]},nm:"sort"},findLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:11,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"elem"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"findLast"},spanTo:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:11,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"spanTo"},sequence:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"},pa:11,mt:"m",an:{doc:["This nonempty sequence."]},nm:"sequence"},contains:{$t:{pk:".",nm:"Boolean"},pa:11,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],mt:"m",nm:"contains"},measure:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:11,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",nm:"measure"},indexes:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"}],nm:"Range"},pa:11,mt:"m",an:{doc:["An integer [[Range]] containing all indexes of this \nsequence, that is, the range `0..sequence.lastIndex`."]},nm:"indexes"},shorterThan:{$t:{pk:".",nm:"Boolean"},pa:11,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",nm:"shorterThan"},slice:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},{comp:"u",l:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},{pk:".",nm:"Nothing"}]},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"}],nm:"Tuple"},pa:11,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"slice"},find:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:11,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"elem"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"find"},repeat:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:11,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"times"}]],mt:"m",an:{doc:["Produces a sequence formed by repeating the elements of\nthis sequence the given [[number of times|times]], or\nthe [[empty sequence|empty]] if `times<=0`."]},nm:"repeat"},clone:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"},pa:11,mt:"m",an:{doc:["This nonempty sequence."]},nm:"clone"},longerThan:{$t:{pk:".",nm:"Boolean"},pa:11,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",nm:"longerThan"},collect:{$t:{pk:".",tp:[{mt:"tp",nm:"Result"}],nm:"Sequence"},pa:11,ps:[[{$t:{nm:"Result"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",an:{doc:["The transformation applied to the elements."]},nm:"collecting"}]],mt:"m",$m:{collecting$hecv2q:{$t:{nm:"Result"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"m",an:{doc:["The transformation applied to the elements."]},nm:"collecting"}},$o:{list$ap4q1c:{super:{pk:".",nm:"Object"},sts:[{pk:".",tp:[{mt:"tp",nm:"Result"}],nm:"List"}],mt:"o",$at:{size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"a",nm:"size"},lastIndex:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:3,mt:"g",nm:"lastIndex"}},$m:{getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Result"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"getFromFirst"}},nm:"list"}},tp:[{nm:"Result"}],an:{doc:["A nonempty sequence containing the results of applying \nthe given mapping to the elements of this sequence."]},nm:"collect"},withTrailing:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],nm:"Sequence"},pa:11,ps:[[{$t:{nm:"Other"},mt:"prm",nm:"element"}]],mt:"m",tp:[{nm:"Other"}],an:{doc:["Return a nonempty sequence containing the elements of \nthis sequence, followed by the given [[element]]."]},nm:"withTrailing"},append:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],nm:"Sequence"},pa:11,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Sequential"},mt:"prm",nm:"elements"}]],mt:"m",tp:[{nm:"Other"}],an:{doc:["Return a nonempty sequence containing the elements of \nthis sequence, followed by the given [[elements]]."]},nm:"append"},span:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:11,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"span"}},tp:[{dv:"out",def:{pk:".",nm:"Anything"},nm:"Element"}],an:{see:["Empty","ArraySequence","Range","Tuple","Singleton"],tagged:["Sequences"],by:["Gavin"],doc:["A nonempty, immutable sequence of values. The type \n`Sequence<Element>` may be abbreviated `[Element+]`.\n\nGiven a possibly-empty sequence of type `[Element*]`, the \n`if (nonempty ...)` construct, or, alternatively, \n`assert (nonempty ...)`, may be used to narrow to a \nsequence type to a nonempty sequence type:\n\n    [Integer*] nums = ... ;\n    if (nonempty nums) {\n        Integer first = nums.first;\n        Integer max = max(nums);\n        [Integer+] squares = nums.collect((Integer i) => i**2));\n        [Integer+] sorted = nums.sort(byIncreasing((Integer i) => i));\n    }\n\nOperations like `first`, `max()`, `collect()`, and `sort()`, \nwhich polymorphically produce a nonempty or non-null output \nwhen given a nonempty input are called \n_emptiness-preserving_.\n\n`Sequence` has the following subtypes:\n\n- [[ArraySequence]], a sequence backed by an [[Array]],\n- [[Range]], an efficient representation of a sequence of \n  adjacent [[enumerable values|Enumerable]],\n- [[Tuple]], a typed linked list, and\n- [[Singleton]], a sequence of just one element."]},nm:"Sequence",$c:{Reverse$t1rj1v:{super:{pk:".",nm:"Object"},sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"}],mt:"c",$at:{rest:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,mt:"g",nm:"rest"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"},last:{$t:{nm:"Element"},pa:3,mt:"g",nm:"last"},first:{$t:{nm:"Element"},pa:3,mt:"g",nm:"first"},reversed:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"},pa:3,mt:"g",nm:"reversed"}},$m:{spanTo:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"spanTo"},spanFrom:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],mt:"m",nm:"spanFrom"},iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},measure:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",nm:"measure"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"getFromFirst"},span:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"span"}},nm:"Reverse$t1rj1v"},Repeat$op9ozo:{super:{pk:".",nm:"Object"},sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"}],ps:[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"times"}],mt:"c",$at:{rest:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,mt:"g",nm:"rest"},last:{$t:{nm:"Element"},pa:3,mt:"g",nm:"last"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"},times$ryfnz9:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"times"},first:{$t:{nm:"Element"},pa:3,mt:"g",nm:"first"}},$m:{iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"getFromFirst"}},nm:"Repeat$op9ozo"}}},sort:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"elements"}]],mt:"m",tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Comparable"}],nm:"Element"}],an:{see:["Comparable","Iterable.sort"],tagged:["Streams","Comparisons"],doc:["Sort the given elements according to their \n[[natural order|Comparable]], returning a new \n[[sequence|Sequential]].\n\nNote that [[Iterable.sort]] may be used to sort any stream\naccording to a given comparator function."]},nm:"sort"},throws:{$t:{pk:".",nm:"ThrownExceptionAnnotation"},pa:513,ps:[[{$t:{pk:"ceylon.language.meta.declaration",nm:"Declaration"},mt:"prm",an:{doc:["The [[Exception]] type that is thrown."]},nm:"type"},{$t:{pk:".",nm:"String"},def:1,mt:"prm",an:{doc:["A description, in Markdown syntax, of the circumstances \nthat cause this exception to be thrown."]},nm:"when"}]],mt:"m",an:{doc:["Annotation to document the exception types thrown by a \nfunction, value, class, or constructor."]},nm:"throws"},Range:{super:{pk:".",nm:"Object"},pa:2321,sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"}],mt:"c",of:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Span"},{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Measure"}],$at:{increasing:{$t:{pk:".",nm:"Boolean"},pa:5,mt:"a",an:{doc:["Determines if the range is increasing, that is, if\nsuccessors occur after predecessors."]},nm:"increasing"},decreasing:{$t:{pk:".",nm:"Boolean"},pa:5,mt:"a",an:{doc:["Determines if the range is decreasing, that is, if\npredecessors occur after successors."]},nm:"decreasing"},coalesced:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Range"},pa:3,mt:"g",an:{doc:["Returns the range itself, since a range cannot contain \nnull elements."]},nm:"coalesced"}},$m:{contains:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],mt:"m",nm:"contains"},containsElement:{$t:{pk:".",nm:"Boolean"},pa:5,ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"m",an:{doc:["Determines if this range includes the given value."]},nm:"containsElement"},includesRange:{$t:{pk:".",nm:"Boolean"},pa:5,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Range"},mt:"prm",nm:"range"}]],mt:"m",an:{doc:["Determines if this range includes the given range."]},nm:"includesRange"},shifted:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Range"},pa:5,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"shift"}]],mt:"m",an:{doc:["Returns a range of the same length and type as this\n   range, with its endpoints shifted by the given number \n   of elements, where:\n   \n   - a negative [[shift]] measures \n     [[decrements|Ordinal.predecessor]], and \n   - a positive `shift` measures \n     [[increments|Ordinal.successor]]."]},nm:"shifted"}},tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Enumerable"}],nm:"Element"}],an:{see:["makeSpan","makeMeasure"],tagged:["Sequences"],doc:["A range of adjacent [[Enumerable]] values. Two values of an\nenumerable type are considered _adjacent_ if their \n[[offset|Enumerable.offset]] is of unit or zero magnitude. \nThus, a `Range` is a list of values where for every integer \n`index` where both `index` and `index+1` fall within the \nindices of the range:\n\n    range[index+1].offset(range[index]).magnitude <= 1\n\nA range is always nonempty, containing at least one value.\nThus, it is a [[Sequence]].\n\nA sequence of adjacent values may be represented very \nefficiently in memory, either:\n\n- via its endpoints, `first..last`, or \n- via an endpoint and length, `first:size`.\n\nFurthermore, certain operations are much more efficient \nthan for other lists, assuming that the enumerable type has \nefficient [[neighbour|Enumerable.neighbour]] and\n[[offset|Enumerable.offset]] functions.\n\nThe functions [[ceylon.language::span]] and \n[[ceylon.language::measure]], and corresponding operators \n`..` and `:` are used to create new instances of `Range`."]},nm:"Range"},serializable:{$t:{pk:".",nm:"SerializableAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to specify that a class is serializable.\n \nA serializable class may have instances that cannot be \nserialized if those instances have reachable references to \ninstances of non-serializable classes."]},nm:"serializable"},plus:{$t:{nm:"Value"},pa:1,ps:[[{$t:{nm:"Value"},mt:"prm",nm:"x"},{$t:{nm:"Value"},mt:"prm",nm:"y"}]],mt:"m",tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Value"}],nm:"Summable"}],nm:"Value"}],an:{see:["times","sum"],tagged:["Numbers"],doc:["Add the given [[Summable]] values.\n\n    (1..100).by(2).fold(0)(plus<Integer>)"]},nm:"plus"},Identifiable:{pa:1,mt:"i",$at:{hash:{$t:{pk:".",nm:"Integer"},pa:11,mt:"g",an:{see:["identityHash"],doc:["The system-defined identity hash value of the instance. \nSubtypes which refine `equals()` must also refine \n`hash`, according to the general contract defined by \n[[Object]]."]},nm:"hash"}},$m:{equals:{$t:{pk:".",nm:"Boolean"},pa:11,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],mt:"m",an:{doc:["Identity equality comparing the identity of the two \nvalues. May be refined by subtypes for which value \nequality is more appropriate. Implementations must\nrespect the constraint that if `x===y` then `x==y` \n(equality is consistent with identity)."]},nm:"equals"}},an:{tagged:["Basic types"],by:["Gavin"],doc:["The abstract supertype of all types with a well-defined\nnotion of identity. Values of type `Identifiable` may be \ncompared using the `===` operator to determine if they are \nreferences to the same object instance.\n\nFor the sake of convenience, this interface defines a \ndefault implementation of value equality equivalent to \nidentity. Of course, subtypes are encouraged to refine this \nimplementation."]},nm:"Identifiable"},formal:{$t:{pk:".",nm:"FormalAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to mark a member whose implementation must be \nprovided by subtypes."]},nm:"formal"},license:{$t:{pk:".",nm:"LicenseAnnotation"},pa:513,ps:[[{$t:{pk:".",nm:"String"},mt:"prm",an:{doc:["The name, text, or URL of the license."]},nm:"description"}]],mt:"m",an:{doc:["Annotation to specify the URL of the license of a module or \npackage."]},nm:"license"},Missing:{super:{pk:".",nm:"Basic"},mt:"c",of:[{pk:".",nm:"Missing.instance"}],nm:"Missing",$cn:{instance:{pa:1,nm:"instance"}}},findPair:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"First"},{comp:"u",l:[{nm:"Second"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"First"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Second"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Second"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"}],nm:"Tuple"}]},pa:1,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"First"},mt:"prm",nm:"first"},{$t:{nm:"Second"},mt:"prm",nm:"second"}]],mt:"prm",$pt:"f",an:{doc:["The binary predicate function to apply to each pair of \nelements."]},nm:"selecting"},{$t:{pk:".",tp:[{mt:"tp",nm:"First"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"firstIterable"},{$t:{pk:".",tp:[{mt:"tp",nm:"Second"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"secondIterable"}]],mt:"m",$m:{selecting$g8bdrb:{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"First"},mt:"prm",nm:"first"},{$t:{nm:"Second"},mt:"prm",nm:"second"}]],mt:"m",an:{doc:["The binary predicate function to apply to each pair of \nelements."]},nm:"selecting"}},tp:[{nm:"First"},{nm:"Second"}],an:{tagged:["Streams"],doc:["Given two streams, return the first pair of elements in the \ngiven streams that satisfies the given binary [[predicate\nfunction|selecting]], or null if no pair of elements \nsatisfies the predicate. If one of the streams is longer \nthan the other, simply ignore additional elements of the \nlonger stream with no pair in the other stream.\n\nFor any given streams `xs` and `ys`, and predicate function \n`p`, `findPair()` may be defined in terms of \n[[Iterable.find]], [[zipPairs]], and [[unflatten]]:\n\n    findPair(p, xs, ys) == zipPairs(xs, ys).find(unflatten(p))"]},nm:"findPair"},sequence:{$t:{comp:"u",l:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"},{nm:"Absent"}]},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},mt:"prm",nm:"elements"}]],mt:"m",tp:[{nm:"Element"},{sts:[{pk:".",nm:"Null"}],def:{pk:".",nm:"Null"},nm:"Absent"}],an:{see:["Iterable.sequence"],tagged:["Sequences"],by:["Gavin"],doc:["A [[nonempty sequence|Sequence]] of the given [[elements]], \nor  `null` if the given stream is empty. A non-null, but\npossibly empty, [[sequence|Sequential]] may be obtained \nusing the `else` operator:\n\n    [Element*] sequenceOfElements = sequence(elements) else [];"]},nm:"sequence"},expand:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{comp:"u",mt:"tp",l:[{nm:"OuterAbsent"},{nm:"InnerAbsent"}]}],nm:"Iterable"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"InnerAbsent"}],nm:"Iterable"},{mt:"tp",nm:"OuterAbsent"}],nm:"Iterable"},mt:"prm",nm:"iterables"}]],mt:"m",tp:[{nm:"Element"},{sts:[{pk:".",nm:"Null"}],nm:"OuterAbsent"},{sts:[{pk:".",nm:"Null"}],nm:"InnerAbsent"}],an:{see:["Iterable.flatMap","concatenate","Iterable.chain"],tagged:["Streams"],doc:["Given a [[stream|iterables]] whose elements are also \nstreams, return a new stream with all elements of every \nnested stream. If there are no nested streams, or if all of\nthe nested streams are empty, return an empty stream.\n\nFor example, the expression\n\n    expand { 1..3, {5}, \"hi\" }\n\nresults in the stream `{ 1, 2, 3, 5, 'h', 'i' }` which has\nthe type `{Integer|Character*}`."]},nm:"expand"},null:{super:{pk:".",nm:"Null"},pa:1,mt:"o",an:{tagged:["Basic types"],by:["Gavin"],doc:["The null value."]},nm:"null"},ArraySequence:{super:{pk:".",nm:"Object"},pa:2097,sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"}],ps:[{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Array"},mt:"prm",nm:"array",$hdn:1}],mt:"c",$at:{rest:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,mt:"g",nm:"rest"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"},last:{$t:{nm:"Element"},pa:3,mt:"g",nm:"last"},array$sfdy8d:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Array"},mt:"a",nm:"array"},first:{$t:{nm:"Element"},pa:3,mt:"g",nm:"first"}},$m:{reduce:{$t:{comp:"u",l:[{nm:"Result"},{nm:"Element"}]},pa:3,ps:[[{$t:{nm:"Result"},ps:[[{$t:{comp:"u",l:[{nm:"Result"},{nm:"Element"}]},mt:"prm",nm:"partial"},{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"accumulating"}]],mt:"m",$m:{accumulating$lf3r4a:{$t:{nm:"Result"},ps:[[{$t:{comp:"u",l:[{nm:"Result"},{nm:"Element"}]},mt:"prm",nm:"partial"},{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"m",nm:"accumulating"}},tp:[{nm:"Result"}],nm:"reduce"},spanFrom:{$t:{comp:"u",l:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"ArraySequence"},{pk:".",nm:"Empty"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],mt:"m",nm:"spanFrom"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"getFromFirst"},count:{$t:{pk:".",nm:"Integer"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"count"},sort:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"},pa:3,ps:[[{$t:{pk:".",nm:"Comparison"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],mt:"prm",$pt:"f",nm:"comparing"}]],mt:"m",$m:{comparing$r21usz:{$t:{pk:".",nm:"Comparison"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],mt:"m",nm:"comparing"}},nm:"sort"},any:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"any"},each:{$t:{pk:".",nm:"Anything"},pa:3,ps:[[{$t:{pk:".",nm:"Anything"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"step"}]],$ff:1,mt:"m",nm:"each"},findLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"findLast"},spanTo:{$t:{comp:"u",l:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"ArraySequence"},{pk:".",nm:"Empty"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"spanTo"},contains:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],mt:"m",nm:"contains"},iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},measure:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",nm:"measure"},find:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"find"},clone:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"},pa:3,mt:"m",nm:"clone"},every:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"every"},collect:{$t:{pk:".",tp:[{mt:"tp",nm:"Result"}],nm:"Sequence"},pa:3,ps:[[{$t:{nm:"Result"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"collecting"}]],mt:"m",$m:{collecting$5nxe1r:{$t:{nm:"Result"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"m",nm:"collecting"}},tp:[{nm:"Result"}],nm:"collect"},span:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"span"}},tp:[{dv:"out",nm:"Element"}],an:{see:["seq"],tagged:["Collections","Sequences"],by:["Tom"],doc:["A [[Sequence]] backed by an [[Array]]. \n\nSince [[Array]]s are mutable, this class is private to the\nlanguage module, where we can be sure the `Array` is not\nmodified after the `ArraySequence` has been initialized."]},nm:"ArraySequence"},aIntLower:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"aIntLower"},Singleton:{super:{pk:".",nm:"Object"},pa:2081,sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"}],ps:[{$t:{nm:"Element"},mt:"prm",nm:"element"}],mt:"c",$at:{rest:{$t:{pk:".",nm:"Empty"},pa:3,mt:"g",an:{doc:["Returns `Empty`."]},nm:"rest"},last:{$t:{nm:"Element"},pa:3,mt:"g",an:{doc:["Returns the element contained in this `Singleton`."]},nm:"last"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",an:{doc:["Returns `1`."]},nm:"size"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},element$kjdnp3:{$t:{nm:"Element"},mt:"a",nm:"element"},lastIndex:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",an:{doc:["Returns `0`."]},nm:"lastIndex"},coalesced:{$t:{comp:"u",l:[{pk:".",tp:[{comp:"i",mt:"tp",l:[{nm:"Element"},{pk:".",nm:"Object"}]}],nm:"Singleton"},{pk:".",nm:"Empty"}]},pa:3,mt:"g",nm:"coalesced"},first:{$t:{nm:"Element"},pa:3,mt:"g",an:{doc:["Returns the element contained in this `Singleton`."]},nm:"first"},reversed:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Singleton"},pa:3,mt:"g",an:{doc:["Return this singleton."]},nm:"reversed"},hash:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"hash"}},$m:{spanFrom:{$t:{comp:"u",l:[{pk:".",nm:"Empty"},{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Singleton"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],mt:"m",nm:"spanFrom"},select:{$t:{comp:"u",l:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Singleton"},{pk:".",nm:"Empty"}]},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"select"},skip:{$t:{comp:"u",l:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Singleton"},{pk:".",nm:"Empty"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"skipping"}]],mt:"m",nm:"skip"},iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},find:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"e"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"find"},map:{$t:{pk:".",tp:[{mt:"tp",nm:"Result"}],nm:"Singleton"},pa:3,ps:[[{$t:{nm:"Result"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"e"}]],mt:"prm",$pt:"f",nm:"collecting"}]],mt:"m",tp:[{nm:"Result"}],nm:"map"},every:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"e"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"every"},reduce:{$t:{nm:"Element"},pa:3,ps:[[{$t:{nm:"Result"},ps:[[{$t:{comp:"u",l:[{nm:"Result"},{nm:"Element"}]},mt:"prm",nm:"partial"},{$t:{nm:"Element"},mt:"prm",nm:"e"}]],mt:"prm",$pt:"f",nm:"accumulating"}]],mt:"m",tp:[{nm:"Result"}],nm:"reduce"},chain:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Iterable"},pa:3,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"},{mt:"tp",nm:"OtherAbsent"}],nm:"Iterable"},mt:"prm",nm:"other"}]],mt:"m",tp:[{nm:"Other"},{sts:[{pk:".",nm:"Null"}],nm:"OtherAbsent"}],nm:"chain"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",an:{doc:["Returns the contained element, if the specified \nindex is `0`."]},nm:"getFromFirst"},count:{$t:{pk:".",nm:"Integer"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",an:{doc:["Returns `1` if this `Singleton`'s element\nsatisfies the predicate, or `0` otherwise."]},nm:"count"},sort:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Singleton"},pa:3,ps:[[{$t:{pk:".",nm:"Comparison"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"a"},{$t:{nm:"Element"},mt:"prm",nm:"b"}]],mt:"prm",$pt:"f",nm:"comparing"}]],mt:"m",nm:"sort"},any:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"e"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"any"},each:{$t:{pk:".",nm:"Anything"},pa:3,ps:[[{$t:{pk:".",nm:"Anything"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"step"}]],$ff:1,mt:"m",nm:"each"},findLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"e"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"findLast"},spanTo:{$t:{comp:"u",l:[{pk:".",nm:"Empty"},{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Singleton"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"spanTo"},filter:{$t:{comp:"u",l:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Singleton"},{pk:".",nm:"Empty"}]},pa:3,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"e"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"filter"},fold:{$t:{nm:"Result"},pa:3,ps:[[{$t:{nm:"Result"},mt:"prm",nm:"initial"}],[{$t:{nm:"Result"},ps:[[{$t:{nm:"Result"},mt:"prm",nm:"partial"},{$t:{nm:"Element"},mt:"prm",nm:"e"}]],mt:"prm",$pt:"f",nm:"accumulating"}]],mt:"m",tp:[{nm:"Result"}],nm:"fold"},take:{$t:{comp:"u",l:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Singleton"},{pk:".",nm:"Empty"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"taking"}]],mt:"m",nm:"take"},contains:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],mt:"m",an:{doc:["Returns `true` if the specified element is this \n`Singleton`'s element."]},nm:"contains"},measure:{$t:{comp:"u",l:[{pk:".",nm:"Empty"},{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Singleton"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",an:{doc:["Returns a `Singleton` if the given starting index \nis `0` and the given `length` is greater than `0`.\nOtherwise, returns an instance of `Empty`."]},nm:"measure"},equals:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],mt:"m",an:{doc:["A `Singleton` can be equal to another `List` if \nthat `List` has only one element which is equal to \nthis `Singleton`'s element."]},nm:"equals"},clone:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Singleton"},pa:3,mt:"m",an:{doc:["Returns a `Singleton` with the same element."]},nm:"clone"},collect:{$t:{pk:".",tp:[{mt:"tp",nm:"Result"}],nm:"Singleton"},pa:3,ps:[[{$t:{nm:"Result"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"collecting"}]],mt:"m",tp:[{nm:"Result"}],nm:"collect"},span:{$t:{comp:"u",l:[{pk:".",nm:"Empty"},{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Singleton"}]},pa:3,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",an:{doc:["Returns a `Singleton` if the given starting index \nis `0`. Otherwise, returns an instance of `Empty`."]},nm:"span"}},tp:[{dv:"out",nm:"Element"}],an:{tagged:["Sequences"],doc:["A [[Sequence]] with exactly one [[element]], which may be \nnull."]},nm:"Singleton"},true:{super:{pk:".",nm:"Boolean"},pa:65,mt:"o",$at:{string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"}},an:{tagged:["Basic types"],doc:["A value representing truth in Boolean logic."]},nm:"true"},unzipPairs:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{pk:".",tp:[{mt:"tp",nm:"First"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},{comp:"u",l:[{pk:".",tp:[{mt:"tp",nm:"Second"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"First"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{pk:".",tp:[{mt:"tp",nm:"Second"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},{pk:".",nm:"Nothing"}]},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Second"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"}],nm:"Tuple"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"First"},{comp:"u",l:[{nm:"Second"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"First"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Second"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Second"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"}],nm:"Tuple"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},mt:"prm",nm:"pairs"}]],mt:"m",tp:[{nm:"First"},{nm:"Second"},{sts:[{pk:".",nm:"Null"}],nm:"Absent"}],an:{tagged:["Streams"],doc:["Given a stream of pairs, return two streams. The\nfirst stream produces the first elements of the\ngiven pairs, and the second stream produces the\nsecond elements of the given pairs.\n\nThus:\n\n    pairs[i] == [unzipPairs(pairs)[0][i], \n                 unzipPairs(pairs)[1][i]]"]},nm:"unzipPairs"},Collection:{pa:1,sts:[{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"}],mt:"i",$at:{string:{$t:{pk:".",nm:"String"},pa:11,mt:"g",an:{doc:["A string of form `\"{ x, y, z }\"` where `x`, `y`, and \n`z` are the `string` representations of the elements of \nthis collection, as produced by the iterator of the \ncollection, or the string `\"{}\"` if this collection \nis empty. If the collection iterator produces the value \n`null`, the string representation contains the string \n`\"<null>\"`."]},nm:"string"},permutations:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:1,mt:"g",$at:{multiset$e71tjc:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",nm:"Element"}],nm:"Entry"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"a",nm:"multiset"},empty:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"g",nm:"empty"}},$m:{iterator:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"}},an:{doc:["The permutations of this collection, as a stream of\nnonempty [[sequences|Sequence]]. That is, a stream\nproducing every distinct ordering of the elements of\nthis collection.\n\nFor example,\n\n    \"ABC\".permutations.map(String)\n\nis the stream of strings\n`{ \"ABC\", \"ACB\", \"BAC\", \"BCA\", \"CAB\", \"CBA\" }`.\n\nIf this collection is empty, the resulting stream is\nempty.\n\nThe permutations are enumerated lexicographically\naccording to the order in which each distinct element \nof this collection is first produced by its iterator.\nNo permutation is repeated.\n\nTwo elements are considered distinct if either:\n\n- they are both instances of `Object`, and are \n  [[unequal|Object.equals]], or\n- one element is an `Object` and the other is `null`."]},nm:"permutations",$c:{anon$0$nynyhw:{super:{pk:".",nm:"Basic"},sts:[{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"}],mt:"c",$anon:1,nm:"anon$0$nynyhw"}}},empty:{$t:{pk:".",nm:"Boolean"},pa:11,mt:"g",an:{doc:["Determine if the collection is empty, that is, if it \nhas no elements."]},nm:"empty"}},$m:{contains:{$t:{pk:".",nm:"Boolean"},pa:11,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],mt:"m",an:{doc:["Return `true` if the given object is an element of this \ncollection. In this default implementation, and in most \nrefining implementations, return `false` otherwise. An \nacceptable refining implementation may return `true` \nfor objects which are not elements of the collection, \nbut this is not recommended. (For example, the \n`contains()` method of `String` returns `true` for any \nsubstring of the string.)"]},nm:"contains"},clone:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Collection"},pa:5,mt:"m",an:{doc:["A shallow copy of this collection, that is, a \ncollection with identical elements which does not\nchange if this collection changes. If this collection\nis immutable, it is acceptable to return a reference to\nthis collection. If this collection is mutable, a newly\ninstantiated collection must be returned."]},nm:"clone"}},tp:[{dv:"out",def:{pk:".",nm:"Anything"},nm:"Element"}],an:{see:["List","Map","Set"],tagged:["Collections"],doc:["An iterable collection of elements of finite [[size]], with \na well-defined notion of [[value equality|equals]]. \n`Collection` is the abstract supertype of [[List]], [[Map]], \nand [[Set]].\n\nA `Collection` forms a [[Category]] of its elements, and is \n[[Iterable]]. The elements of a collection are not\nnecessarily distinct when compared using [[Object.equals]].\n\nA `Collection` may be [[cloned|clone]]. If a collection is\nimmutable, it is acceptable that `clone()` produce a\nreference to the collection itself. If a collection is\nmutable, `clone()` should produce a collection containing \nreferences to the same elements, with the same structure as \nthe original collection&mdash;that is, it should produce a \nshallow copy of the collection.\n\nAll `Collection`s are required to support a well-defined\nnotion of [[value equality|Object.equals]], but the\ndefinition of equality depends upon the kind of collection.\nEquality for `Map`s and `Set`s has a quite different\ndefinition to equality for `List`s. Instances of two \ndifferent kinds of collection are never equal&mdash;for\nexample, a `Map` is never equal to a `List`."]},nm:"Collection"},Throwable:{super:{pk:".",nm:"Basic"},pa:337,ps:[{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"String"}]},def:1,mt:"prm",an:{doc:["A description of the problem."]},nm:"description",$hdn:1},{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Throwable"}]},pa:1,def:1,mt:"prm",an:{doc:["The underlying cause of this exception."]},nm:"cause",$hdn:1}],mt:"c",$at:{string:{$t:{pk:".",nm:"String"},pa:11,mt:"g",nm:"string"},description$arbt90:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"String"}]},mt:"a",an:{doc:["A description of the problem."]},nm:"description"},cause:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Throwable"}]},pa:1,mt:"a",an:{doc:["The underlying cause of this exception."]},nm:"cause"},suppressed:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Throwable"}],nm:"Sequential"},pa:65,mt:"a",an:{doc:["The exceptions that were suppressed in order to \npropagate this exception."]},nm:"suppressed"},message:{$t:{pk:".",nm:"String"},pa:9,mt:"g",an:{see:["cause"],doc:["A message describing the problem. This default \nimplementation returns the description, if any, or \notherwise the message of the cause, if any."]},nm:"message"}},$m:{printStackTrace:{$t:{pk:".",nm:"Anything"},pa:1,$ff:1,mt:"m",an:{see:["printTrace"],doc:["Print the stack trace to the standard error of the \nvirtual machine process."]},nm:"printStackTrace"},addSuppressed:{$t:{pk:".",nm:"Anything"},pa:65,ps:[[{$t:{pk:".",nm:"Throwable"},mt:"prm",nm:"suppressed"}]],$ff:1,mt:"m",an:{doc:["The given exception was suppressed in order to \npropagate this exception."]},nm:"addSuppressed"}},an:{tagged:["Basic types"],by:["Gavin","Tom"],doc:["The abstract supertype of values indicating exceptional \nconditions. An exception may be raised using the `throw` \nstatement, and handled using the `catch` clause of the `try` \nstatement. An instance of `Throwable` may be passed from\n`throw` to `catch`.\n    \n    void tryToDoIt() {\n        if (canDoIt()) {\n            doIt();\n        }\n        else {\n            throw CantDoIt(); \/\/the Throwable\n        }\n    }\n    \n    try {\n        tryToDoIt();\n    }\n    catch (CantDoIt e) {\n        e.printStackTrace();\n    }\n\nAn instance of `Throwable` represents a problem, typically \nan _unexpected failure_. Either:\n\n- a unrecoverable error in the program, especially an \n  [[AssertionError]], or\n- a transient, and possibly-recoverable [[Exception]].\n\nThe use of the exceptions facility to manage _expected \nfailures_, that is, failures that are usually handled by \nthe immediate caller of an operation, is discouraged. \nInstead, the failure should be represented as a return \nvalue of the operation being called.\n\nFor example, nonexistence of a file should not result in an \nexception. Instead, an `openFile()` operation should return \nthe type `File?`, where a `null` return value indicates \nnonexistence. On the other hand, failure to read from an\nalready open file could result in an `Exception`."]},nm:"Throwable"},arrayOfSize:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Array"},pa:1,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",an:{doc:["The size of the resulting array. If the size is \nnon-positive, an empty array will be created."]},nm:"size"},{$t:{nm:"Element"},mt:"prm",an:{doc:["The element value with which to populate the array.\nAll elements of the resulting array will have the \nsame value."]},nm:"element"}]],mt:"m",tp:[{nm:"Element"}],an:{see:["runtime.maxArraySize"],tagged:["Collections"],deprecated:["Use [[Array.ofSize]]"],doc:["Create an array of the specified [[size]], populating every \nindex with the given [[element]]. The specified `size` must \nbe no larger than [[runtime.maxArraySize]]. If `size<=0`, \nthe new array will have no elements."],throws:["AssertionError","if `size>runtime.maxArraySize`"]},nm:"arrayOfSize"},Basic:{super:{pk:".",nm:"Object"},pa:257,sts:[{pk:".",nm:"Identifiable"}],mt:"c",an:{tagged:["Basic types"],by:["Gavin"],doc:["The default superclass when no superclass is explicitly\nspecified using `extends`. For the sake of convenience, \nthis class inherits [[Identifiable]] along with its\n[[default definition|Identifiable.equals]] of value \nequality. Classes which aren't `Identifiable` should \ndirectly extend [[Object]]."]},nm:"Basic"},largest:{$t:{nm:"Element"},pa:1,ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],mt:"m",tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Comparable"}],nm:"Element"}],an:{see:["Comparable","smallest","max"],tagged:["Comparisons"],doc:["Given two [[Comparable]] values, return largest of the two."]},nm:"largest"},Category:{pa:1,mt:"i",$m:{contains:{$t:{pk:".",nm:"Boolean"},pa:5,ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"m",an:{see:["containsEvery","containsAny"],doc:["Returns `true` if the given value belongs to this\n`Category`, that is, if it is an element of this\n`Category`, or `false` otherwise.\n\nFor most `Category`s the following relationship is \nsatisfied by every pair of elements `x` and `y`:\n\n- if `x==y`, then `x in category == y in category`\n\nHowever, it is possible to form a useful `Category` \nconsistent with some other equivalence relation, for \nexample `===`. Therefore implementations of `contains()` \nwhich do not satisfy this relationship are tolerated."]},nm:"contains"},containsAny:{$t:{pk:".",nm:"Boolean"},pa:9,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"elements"}]],mt:"m",an:{see:["contains","containsEvery"],doc:["Returns `true` if any one of the given values belongs \nto this `Category`, or `false` otherwise."]},nm:"containsAny"},containsEvery:{$t:{pk:".",nm:"Boolean"},pa:9,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"elements"}]],mt:"m",an:{see:["contains","containsAny"],doc:["Returns `true` if every one of the given values belongs \nto this `Category`, or `false` otherwise."]},nm:"containsEvery"}},tp:[{dv:"in",sts:[{pk:".",nm:"Object"}],def:{pk:".",nm:"Object"},nm:"Element"}],an:{tagged:["Collections"],by:["Gavin"],doc:["Abstract supertype of objects that contain other values, \ncalled *elements*, where it is possible to efficiently \ndetermine if a given value is an element.\n\n`Category` models a mathematical set, but is distinct \nfrom the [[Set]] collection type.\n\nThe `in` operator may be used to determine if a value\nbelongs to a `Category`:\n\n    if (69 in 0..100) { ... }\n    assert (key->item in { for (n in 0..100) n.string->n**2 });\n\nAn object may be a `Category` of two different disjoint\nelement types. For example, [[String]] is a `Category`\nof its `Character`s and of its substrings.\n\n    if (\"hello\" in \"hello world\") { ... }\n    assert ('.' in string);\n\nEvery meaningful `Category` is formed from elements with\nsome equivalence relation. Ordinarily, that equivalence\nrelation is [[value equality|Object.equals]]. Thus,\nordinarily, `x==y` implies that `x in cat == y in cat`.\nBut this contract is not required since it is possible to \nform a meaningful `Category` using a different \nequivalence relation. For example, an `IdentitySet` is a \nmeaningful `Category`, where the equivalence relation is\n[[identity equality|Identifiable]].\n\nSince [[Null]] is not considered to have any meaningful\nequivalence relation, a `Category` may not contain the\n[[null value|null]].\n\nNote that even though `Category<Element>` is declared\ncontravariant in its [[element type|Element]], most types\nthat inherit `Category` are covariant in their element\ntype, and therefore satisfy `Category<Object>`, resulting\nin some loss of typesafety. For such types, [[contains]] \nshould return `false` for any value that is not an \ninstance of the element type. For example, `String` is a \n`Category<Object>`, not a `Category<Character|String>`,\nand `x in string` evaluates to `false` for every `x` that\nis not a `String` or `Character`."]},nm:"Category"},printAll:{$t:{pk:".",nm:"Anything"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Anything"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"values"},{$t:{pk:".",nm:"String"},def:1,mt:"prm",an:{doc:["A character sequence to use to separate the values"]},nm:"separator"}]],$ff:1,mt:"m",an:{see:["process.write"],tagged:["Environment"],by:["Gavin"],doc:["Print multiple values to the standard output of the virtual \nmachine process as a single line of text, separated by a\ngiven character sequence."]},nm:"printAll"},times:{$t:{nm:"Value"},pa:1,ps:[[{$t:{nm:"Value"},mt:"prm",nm:"x"},{$t:{nm:"Value"},mt:"prm",nm:"y"}]],mt:"m",tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Value"}],nm:"Numeric"}],nm:"Value"}],an:{see:["plus","product"],tagged:["Numbers"],doc:["Multiply the given [[Numeric]] values.\n\n    (1..100).by(2).fold(1)(times<Integer>)"]},nm:"times"},and:{$t:{pk:".",nm:"Boolean"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Boolean"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Value"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"}],nm:"Callable"},mt:"prm",an:{doc:["The first predicate function"]},nm:"p"},{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Boolean"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Value"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"}],nm:"Callable"},mt:"prm",an:{doc:["The second predicate function"]},nm:"q"}],[{$t:{nm:"Value"},mt:"prm",nm:"val"}]],mt:"m",tp:[{dv:"in",nm:"Value"}],an:{tagged:["Functions"],doc:["Returns a function which is the logical conjunction of the \ngiven predicate functions."]},nm:"and"},NativeAnnotation:{super:{pk:".",nm:"Basic"},pa:561,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"NativeAnnotation"},{mt:"tp",pk:".",nm:"Annotated"},{mt:"tp",pk:".",nm:"Anything"}],nm:"OptionalAnnotation"}],ps:[{$t:{pk:".",nm:"String"},pa:1,mt:"prm",an:{doc:["The compiler backend that this native annotation applies to,\nor the empty string to declare the annotated element is a\nnative header."]},nm:"backend",$hdn:1}],mt:"c",$at:{backend:{$t:{pk:".",nm:"String"},pa:1,mt:"a",an:{doc:["The compiler backend that this native annotation applies to,\nor the empty string to declare the annotated element is a\nnative header."]},nm:"backend"}},an:{doc:["The annotation class for the [[native]] annotation."]},nm:"NativeAnnotation"},ChainedIterator:{super:{pk:".",nm:"Basic"},sts:[{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],nm:"Iterator"}],ps:[{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"first"},{$t:{pk:".",tp:[{mt:"tp",nm:"Other"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"second"}],mt:"c",$at:{iter$2p4fla:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],nm:"Iterator"},pa:1027,mt:"a",nm:"iter"},second$9dpb6y:{$t:{pk:".",tp:[{mt:"tp",nm:"Other"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"a",nm:"second"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},first$4h62ti:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"a",nm:"first"},more$5ang2r:{$t:{pk:".",nm:"Boolean"},pa:1027,mt:"a",nm:"more"}},$m:{next:{$t:{comp:"u",l:[{nm:"Element"},{nm:"Other"},{pk:".",nm:"Finished"}]},pa:3,mt:"m",nm:"next"}},tp:[{dv:"out",nm:"Element"},{dv:"out",nm:"Other"}],an:{see:["Iterable.chain"],tagged:["Streams"],by:["Enrique Zamudio"],doc:["An [[Iterator]] that returns the elements of two\n[[Iterable]]s, as if they were chained together."]},nm:"ChainedIterator"},CycledIterator:{super:{pk:".",nm:"Basic"},sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"}],ps:[{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"iterable"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"times"}],mt:"c",$at:{string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},iter$glpg04:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:1027,mt:"a",nm:"iter"},times$6c4zeu:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"times"},count$2etvtx:{$t:{pk:".",nm:"Integer"},pa:1024,mt:"a",nm:"count"},iterable$oksliy:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"a",nm:"iterable"}},$m:{next:{$t:{comp:"u",l:[{nm:"Element"},{pk:".",nm:"Finished"}]},pa:3,mt:"m",nm:"next"}},tp:[{nm:"Element"}],nm:"CycledIterator"},zipEntries:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"Item"}],nm:"Entry"},{comp:"u",mt:"tp",l:[{nm:"KeyAbsent"},{nm:"ItemAbsent"}]}],nm:"Iterable"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"KeyAbsent"}],nm:"Iterable"},mt:"prm",nm:"keys"},{$t:{pk:".",tp:[{mt:"tp",nm:"Item"},{mt:"tp",nm:"ItemAbsent"}],nm:"Iterable"},mt:"prm",nm:"items"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Key"},{nm:"Item"},{sts:[{pk:".",nm:"Null"}],nm:"KeyAbsent"},{sts:[{pk:".",nm:"Null"}],nm:"ItemAbsent"}],an:{tagged:["Streams"],doc:["Given two streams, form a new stream consisting of all \n[[entries|Entry]] where, for any given index in the \nresulting stream, the [[key|Entry.key]] of the entry is the \nelement occurring at the same index in the \n[[first stream|keys]], and the [[item|Entry.item]] is the \nelement occurring at the same index in the \n[[second stream|items]]. The length of the resulting stream \nis the length of the shorter of the two given streams.\n\nThus:\n\n    zipEntries(keys, items)[i] == keys[i] -> items[i]\n\nfor every `0<=i<smallest(keys.size,items.size)`."]},nm:"zipEntries"},process:{super:{pk:".",nm:"Basic"},pa:65,mt:"o",$at:{string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},arguments:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"String"}],nm:"Sequential"},pa:65,mt:"a",an:{doc:["The command line arguments to the virtual machine."]},nm:"arguments"}},$m:{exit:{$t:{pk:".",nm:"Nothing"},pa:65,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"code"}]],mt:"m",an:{doc:["Force the virtual machine to terminate with the given\nexit code."]},nm:"exit"},namedArgumentPresent:{$t:{pk:".",nm:"Boolean"},pa:65,ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"name"}]],mt:"m",an:{doc:["Determine if an argument of form `-name` or `--name` \nwas specified among the command line arguments to \nthe virtual machine."]},nm:"namedArgumentPresent"},environmentVariableValue:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"String"}]},pa:65,ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"name"}]],mt:"m",an:{doc:["The value of the given environment variable defined \nfor the current virtual machine process."]},nm:"environmentVariableValue"},flush:{$t:{pk:".",nm:"Anything"},pa:65,$ff:1,mt:"m",an:{doc:["Flush the standard output of the virtual machine \nprocess."]},nm:"flush"},flushError:{$t:{pk:".",nm:"Anything"},pa:65,$ff:1,mt:"m",an:{doc:["Flush the standard error of the \nvirtual machine process."]},nm:"flushError"},writeErrorLine:{$t:{pk:".",nm:"Anything"},pa:1,ps:[[{$t:{pk:".",nm:"String"},def:1,mt:"prm",nm:"line"}]],$ff:1,mt:"m",an:{doc:["Print a line to the standard error of the virtual \nmachine process."]},nm:"writeErrorLine"},namedArgumentValue:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"String"}]},pa:65,ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"name"}]],mt:"m",an:{doc:["The value of the first argument of form `-name=value`, \n`--name=value`, or `-name value` specified among the \ncommand line arguments to the virtual machine, if\nany."]},nm:"namedArgumentValue"},propertyValue:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"String"}]},pa:65,ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"name"}]],mt:"m",an:{doc:["The value of the given system property of the virtual\nmachine, if any."]},nm:"propertyValue"},writeLine:{$t:{pk:".",nm:"Anything"},pa:1,ps:[[{$t:{pk:".",nm:"String"},def:1,mt:"prm",nm:"line"}]],$ff:1,mt:"m",an:{see:["print"],doc:["Print a line to the standard output of the virtual \nmachine process."]},nm:"writeLine"},readLine:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"String"}]},pa:65,mt:"m",an:{doc:["Read a line of input text from the standard input of \nthe virtual machine process. Returns a line of text \nafter removal of line-termination characters, or `null`\nto indicate the standard input has been closed."]},nm:"readLine"},write:{$t:{pk:".",nm:"Anything"},pa:65,ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"string"}]],$ff:1,mt:"m",an:{doc:["Print a string to the standard output of the virtual\nmachine process."]},nm:"write"},writeError:{$t:{pk:".",nm:"Anything"},pa:65,ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"string"}]],$ff:1,mt:"m",an:{doc:["Print a string to the standard error of the virtual \nmachine process."]},nm:"writeError"}},an:{see:["language","runtime","system","operatingSystem"],tagged:["Environment"],by:["Gavin","Tako"],doc:["Represents the current process (instance of the virtual\nmachine)."]},nm:"process"},or:{$t:{pk:".",nm:"Boolean"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Boolean"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Value"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"}],nm:"Callable"},mt:"prm",an:{doc:["The first predicate function"]},nm:"p"},{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Boolean"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Value"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"}],nm:"Callable"},mt:"prm",an:{doc:["The second predicate function"]},nm:"q"}],[{$t:{nm:"Value"},mt:"prm",nm:"val"}]],mt:"m",tp:[{dv:"in",nm:"Value"}],an:{tagged:["Functions"],doc:["Returns a function which is the logical disjunction of the \ngiven predicate functions."]},nm:"or"},decreasing:{$t:{pk:".",nm:"Comparison"},pa:1,ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],mt:"m",tp:[{sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Comparable"}],nm:"Element"}],an:{see:["increasing","byDecreasing","Iterable.max","Iterable.sort"],tagged:["Comparisons"],doc:["A comparator function which orders elements in decreasing \n[[natural order|Comparable]].\n\n       \"Hello World!\".sort(decreasing)\n\nThis function is intended for use with [[Iterable.sort]]\nand [[Iterable.max]]."]},nm:"decreasing"},any:{$t:{pk:".",nm:"Boolean"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Boolean"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"values"}]],mt:"m",an:{see:["every","Iterable.any"],tagged:["Streams"],doc:["Determines if any one of the given boolean values \n(usually a comprehension) is `true`.\n\n    Boolean anyNegative = any { for (x in xs) x<0.0 };\n\nIf there are no boolean values, return `false`."]},nm:"any"},unzipEntries:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{pk:".",tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},{comp:"u",l:[{pk:".",tp:[{mt:"tp",nm:"Item"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},{mt:"tp",pk:".",tp:[{comp:"u",mt:"tp",l:[{pk:".",tp:[{mt:"tp",nm:"Item"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},{pk:".",nm:"Nothing"}]},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Item"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},{mt:"tp",pk:".",nm:"Empty"}],nm:"Tuple"}],nm:"Tuple"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"Item"}],nm:"Entry"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},mt:"prm",nm:"entries"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Key"},{nm:"Item"},{sts:[{pk:".",nm:"Null"}],nm:"Absent"}],an:{tagged:["Streams"],doc:["Given a stream of entries, return two streams. The\nfirst stream produces the keys of the given entries, \nand the second stream produces the items of the given \nentries.\n\nThus:\n\n    entries[i] == unzipEntries(entries)[0][i] \n               -> unzipEntries(entries)[1][i]"]},nm:"unzipEntries"},Exception:{super:{pk:".",nm:"Throwable"},pa:65,ps:[{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"String"}]},def:1,mt:"prm",an:{doc:["A description of the problem."]},nm:"description",$hdn:1},{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Throwable"}]},def:1,mt:"prm",an:{doc:["The underlying cause of this exception."]},nm:"cause",$hdn:1}],mt:"c",$at:{cause$tn7i4g:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Throwable"}]},mt:"a",an:{doc:["The underlying cause of this exception."]},nm:"cause"},description$etadt1:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"String"}]},mt:"a",an:{doc:["A description of the problem."]},nm:"description"}},an:{by:["Gavin","Tom"],doc:["The supertype of all unexpected transient failures. An\n`Exception` is usually unrecoverable from the point of view \nof the immediate caller of an operation.\n\nFor example, code that interacts with a relational database \nisn't typically written to recover from transaction \nrollback or loss of network connectivity. However, these \nconditions aren't completely unrecoverable from the point \nof view of the program's generic exception handling \ninfrastructure. Therefore, they are best treated as \n`Exception`s.\n\nA subclass of `Exception` represents a more specific kind \nof problem, and may define additional attributes which \npropagate information about problems of that kind."]},nm:"Exception"},Array:{super:{pk:".",nm:"Basic"},pa:2145,sts:[{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"SearchableList"},{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",nm:"Element"},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Array"}],nm:"Ranged"}],ps:[{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"elements"}],mt:"c",$at:{last:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:67,mt:"a",nm:"last"},size:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"size"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},lastIndex:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:67,mt:"a",nm:"lastIndex"},coalesced:{$t:{pk:".",tp:[{comp:"i",mt:"tp",l:[{nm:"Element"},{pk:".",nm:"Object"}]},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:67,mt:"a",nm:"coalesced"},first:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:67,mt:"a",nm:"first"},hash:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"hash"},empty:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"a",nm:"empty"}},$m:{occurrences:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:67,ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",nm:"length"}]],mt:"m",nm:"occurrences"},spanFrom:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Array"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],mt:"m",nm:"spanFrom"},locate:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{comp:"i",mt:"tp",l:[{nm:"Element"},{pk:".",nm:"Object"}]}],nm:"Entry"}]},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"locate"},skip:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"skipping"}]],mt:"m",nm:"skip"},firstIndexWhere:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"firstIndexWhere"},occurs:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",nm:"length"}]],mt:"m",nm:"occurs"},defines:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",nm:"defines"},copyTo:{$t:{pk:".",nm:"Anything"},pa:65,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Array"},mt:"prm",an:{doc:["The array into which to copy the elements, which \nmay be this array."]},nm:"destination"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The index of the first element in this array to \ncopy."]},nm:"sourcePosition"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The index in the given array into which to copy the \nfirst element."]},nm:"destinationPosition"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The number of elements to copy."]},nm:"length"}]],$ff:1,mt:"m",an:{doc:["Efficiently copy the elements in the segment\n`sourcePosition:length` of this array to the segment \n`destinationPosition:length` of the given \n[[array|destination]], which may be this array."]},nm:"copyTo"},iterator:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"},pa:67,mt:"m",nm:"iterator"},find:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"find"},locateLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{comp:"i",mt:"tp",l:[{nm:"Element"},{pk:".",nm:"Object"}]}],nm:"Entry"}]},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"locateLast"},lastOccurrence:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:67,ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",nm:"length"}]],mt:"m",nm:"lastOccurrence"},by:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"step"}]],mt:"m",nm:"by"},occursAt:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"},{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"m",nm:"occursAt"},every:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"every"},reduce:{$t:{comp:"u",l:[{nm:"Result"},{nm:"Element"},{pk:".",nm:"Null"}]},pa:67,ps:[[{$t:{nm:"Result"},ps:[[{$t:{comp:"u",l:[{nm:"Result"},{nm:"Element"}]},mt:"prm",nm:"partial"},{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"accumulating"}]],mt:"m",tp:[{nm:"Result"}],nm:"reduce"},lastIndexWhere:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"lastIndexWhere"},move:{$t:{pk:".",nm:"Anything"},pa:65,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",an:{doc:["The source index of the element to move."]},nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",an:{doc:["The destination index to which the element is\nmoved."]},nm:"to"}]],$ff:1,mt:"m",an:{doc:["Efficiently move the element of this array at the given \n[[source index|from]] to the given \n[[destination index|to]], shifting every element \nfalling between the two given indices by one position \nto accommodate the change of position. If the source \nindex is larger than the destination index, elements \nare shifted toward the end of the array. If the source \nindex is smaller than the destination index, elements \nare shifted toward the start of the array. If the given \nindices are identical, no change is made to the array. \nThe array always contains the same elements before and \nafter this operation."],throws:["AssertionError","if either of the given indices is out of bounds"]},nm:"move"},set:{$t:{pk:".",nm:"Anything"},pa:65,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",an:{doc:["The index of the element to replace."]},nm:"index"},{$t:{nm:"Element"},mt:"prm",an:{doc:["The new element."]},nm:"element"}]],$ff:1,mt:"m",an:{doc:["Replace the existing element at the specified [[index]] \nwith the given [[element]]."],throws:["AssertionError","if the given index is out of bounds, that is, if \n`index<0` or if `index>lastIndex`"]},nm:"set"},swap:{$t:{pk:".",nm:"Anything"},pa:65,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",an:{doc:["The index of the first element."]},nm:"i"},{$t:{pk:".",nm:"Integer"},mt:"prm",an:{doc:["The index of the second element."]},nm:"j"}]],$ff:1,mt:"m",an:{doc:["Given two indices within this array, efficiently swap \nthe positions of the elements at these indices. If the \ntwo given indices are identical, no change is made to \nthe array. The array always contains the same elements\nbefore and after this operation."],throws:["AssertionError","if either of the given indices is out of bounds"]},nm:"swap"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",an:{doc:["Get the element at the specified index, or `null` if\nthe index falls outside the bounds of this array."]},nm:"getFromFirst"},count:{$t:{pk:".",nm:"Integer"},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"count"},indexesWhere:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"indexesWhere"},sort:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:67,ps:[[{$t:{pk:".",nm:"Comparison"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],mt:"prm",$pt:"f",an:{doc:["A comparison function that compares pairs of\nelements of this array."]},nm:"comparing"}]],mt:"m",an:{doc:["Sorts the elements in this array according to the \norder induced by the given \n[[comparison function|comparing]], returning a new\nsequence. This operation has no side-effect, and does\nnot modify the array."]},nm:"sort"},any:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"any"},each:{$t:{pk:".",nm:"Anything"},pa:67,ps:[[{$t:{pk:".",nm:"Anything"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"step"}]],$ff:1,mt:"m",nm:"each"},findLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"findLast"},sortInPlace:{$t:{pk:".",nm:"Anything"},pa:65,ps:[[{$t:{pk:".",nm:"Comparison"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],mt:"prm",$pt:"f",an:{doc:["A comparison function that compares pairs of\nelements of this array."]},nm:"comparing"}]],$ff:1,mt:"m",an:{doc:["Sorts the elements in this array according to the \norder induced by the given \n[[comparison function|comparing]]. This operation works \nby side-effect, modifying the array.  The array always \ncontains the same elements before and after this \noperation."]},nm:"sortInPlace"},getFromLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],mt:"m",an:{doc:["Get the element at the specified index, where the array\nis indexed from the _end_ of the array, or `null` if\nthe index falls outside the bounds of this array."]},nm:"getFromLast"},spanTo:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Array"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"spanTo"},filter:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"filter"},reverseInPlace:{$t:{pk:".",nm:"Anything"},pa:65,$ff:1,mt:"m",an:{doc:["Reverses the order of the current elements in this \narray. This operation works by side-effect, modifying \nthe array. The array always contains the same elements \nbefore and after this operation."]},nm:"reverseInPlace"},sequence:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Sequential"},pa:67,mt:"m",nm:"sequence"},take:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"taking"}]],mt:"m",nm:"take"},contains:{$t:{pk:".",nm:"Boolean"},pa:67,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],mt:"m",nm:"contains"},measure:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Array"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],mt:"m",nm:"measure"},firstOccurrence:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:67,ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",nm:"length"}]],mt:"m",nm:"firstOccurrence"},equals:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],mt:"m",nm:"equals"},clone:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Array"},pa:67,mt:"m",an:{doc:["A new array with the same elements as this array."]},nm:"clone"},locations:{$t:{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:".",nm:"Integer"},{comp:"i",mt:"tp",l:[{nm:"Element"},{pk:".",nm:"Object"}]}],nm:"Entry"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},pa:67,ps:[[{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],mt:"prm",$pt:"f",nm:"selecting"}]],mt:"m",nm:"locations"},span:{$t:{pk:".",tp:[{mt:"tp",nm:"Element"}],nm:"Array"},pa:67,ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],mt:"m",nm:"span"}},tp:[{nm:"Element"}],an:{tagged:["Collections"],doc:["A fixed-sized array of mutable elements. An _empty_ array \nis an array of [[size]] `0`. An array may be created with\na list of initial elements, or, via the constructor \n[[ofSize]], with a size and single initial value for all \nelements.\n\n    value array = Array { \"hello\", \"world\" };\n    value ints = Array.ofSize(1k, 0);\n\nArrays are mutable. Any element of an array may be set to a \nnew value.\n\n    value array = Array { \"hello\", \"world\" };\n    array.set(0, \"goodbye\");\n\nArrays are lists and support all operations inherited from \n[[List]], along with certain additional operations for \nefficient mutation of the array: [[set]], [[swap]], [[move]], \n[[sortInPlace]], [[reverseInPlace]], and [[copyTo]].\n\nThis class is provided primarily to support interoperation \nwith Java, and for some performance-critical low-level \nprogramming tasks."]},nm:"Array",$cn:{$def:{pa:65,ps:[{$t:{pk:".",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"elements"}],an:{doc:["Create an array with the given [[elements]]."]}},ofSize:{pa:65,ps:[{$t:{pk:".",nm:"Integer"},mt:"prm",an:{doc:["The size of the resulting array. If the size is \nnon-positive, an empty array will be created."]},nm:"size"},{$t:{nm:"Element"},mt:"prm",an:{doc:["The element value with which to populate the \narray. All elements of the resulting array will \nhave the same value."]},nm:"element"}],an:{see:["runtime.maxArraySize"],doc:["Create an array of the specified [[size]], populating \nevery index with the given [[element]]. The specified \n`size` must be no larger than [[runtime.maxArraySize]].\nIf `size<=0`, the new array will have no elements."],throws:["AssertionError","if `size>runtime.maxArraySize`"]},nm:"ofSize"}}},corresponding:{$t:{pk:".",nm:"Boolean"},pa:1,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"First"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"firstIterable"},{$t:{pk:".",tp:[{mt:"tp",nm:"Second"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"secondIterable"},{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"First"},mt:"prm",nm:"first"},{$t:{nm:"Second"},mt:"prm",nm:"second"}]],def:1,mt:"prm",$pt:"f",an:{doc:["The predicate function that compares an element of the\n[[first stream|firstIterable]] with the corresponding \nelement of the [[second stream|secondIterable]].\n\nBy default, the elements are compared by a predicate\nfunction that returns `true` if and only if the \nelements are [[equal|Object.equals]] or both `null`."]},nm:"comparing"}]],mt:"m",$m:{comparing$arwonf:{$t:{pk:".",nm:"Boolean"},ps:[[{$t:{nm:"First"},mt:"prm",nm:"first"},{$t:{nm:"Second"},mt:"prm",nm:"second"}]],mt:"m",an:{doc:["The predicate function that compares an element of the\n[[first stream|firstIterable]] with the corresponding \nelement of the [[second stream|secondIterable]].\n\nBy default, the elements are compared by a predicate\nfunction that returns `true` if and only if the \nelements are [[equal|Object.equals]] or both `null`."]},nm:"comparing"}},tp:[{nm:"First"},{nm:"Second"}],an:{see:["everyPair"],tagged:["Comparisons","Streams"],doc:["Compares corresponding elements of the given streams using \nthe given [[binary predicate function|comparing]]. Two \nelements are considered _corresponding_ if they occupy the\nsame position in their respective streams. Returns `true` \nif and only if:\n\n- the two streams have the same number of elements, and \n- if the predicate is satisfied for every pair of \n  corresponding elements.\n\nReturns `false` otherwise. If both streams are empty, \nreturn `true`.\n\nFor example:\n\n    corresponding({ 1, 2, 3, 4 }, 1:4)\n\nand:\n\n    corresponding({ 1, 2, 3, 4 }, \"1234\", \n           (Integer i, Character c) => i.string==c.string)\n\nboth evaluate to `true`."]},nm:"corresponding"},variable:{$t:{pk:".",nm:"VariableAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to mark a value as variable. A `variable` value \nmay be assigned multiple times."]},nm:"variable"},Correspondence:{pa:1,mt:"i",$at:{keys:{$t:{pk:".",tp:[{mt:"tp",nm:"Key"}],nm:"Category"},pa:9,mt:"g",$m:{contains:{$t:{pk:".",nm:"Boolean"},pa:3,ps:[[{$t:{nm:"Key"},mt:"prm",nm:"key"}]],mt:"m",nm:"contains"}},an:{see:["Correspondence.defines"],doc:["The `Category` of all keys for which a value is defined\nby this `Correspondence`."]},nm:"keys",$c:{anon$0$axfadl:{super:{pk:".",nm:"Basic"},sts:[{pk:".",tp:[{mt:"tp",nm:"Key"}],nm:"Category"}],mt:"c",$anon:1,nm:"anon$0$axfadl"}}}},$m:{getAll:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{pk:".",nm:"Null"},{nm:"Item"}]},{mt:"tp",nm:"Absent"}],nm:"Iterable"},pa:9,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"Absent"}],nm:"Iterable"},mt:"prm",nm:"keys"}]],mt:"m",tp:[{sts:[{pk:".",nm:"Null"}],nm:"Absent"}],an:{see:["Correspondence.get"],doc:["Returns the items defined for the given keys, in the \nsame order as the corresponding keys. For any key which \ndoes not have an item defined, the resulting stream \ncontains the value `null`."]},nm:"getAll"},get:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Item"}]},pa:5,ps:[[{$t:{nm:"Key"},mt:"prm",nm:"key"}]],mt:"m",an:{see:["Correspondence.getAll"],doc:["Returns the value defined for the given key, or `null` \nif there is no value defined for the given key."]},nm:"get"},definesEvery:{$t:{pk:".",nm:"Boolean"},pa:9,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Key"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"keys"}]],mt:"m",an:{see:["Correspondence.defines"],doc:["Determines if this `Correspondence` defines a value for\nevery one of the given keys."]},nm:"definesEvery"},definesAny:{$t:{pk:".",nm:"Boolean"},pa:9,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Key"},{mt:"tp",pk:".",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"keys"}]],mt:"m",an:{see:["Correspondence.defines"],doc:["Determines if this `Correspondence` defines a value for\nany one of the given keys."]},nm:"definesAny"},defines:{$t:{pk:".",nm:"Boolean"},pa:5,ps:[[{$t:{nm:"Key"},mt:"prm",nm:"key"}]],mt:"m",an:{see:["Correspondence.definesAny","Correspondence.definesEvery","Correspondence.keys"],doc:["Determines if there is a value defined for the given \nkey."]},nm:"defines"}},tp:[{dv:"in",sts:[{pk:".",nm:"Object"}],nm:"Key"},{dv:"out",def:{pk:".",nm:"Anything"},nm:"Item"}],an:{see:["Map","List","Category"],tagged:["Collections"],by:["Gavin"],doc:["Abstract supertype of objects which associate values with \nkeys.\n\n`Correspondence` does not satisfy [[Category]], since in \nsome cases&mdash;`List`, for example&mdash;it is convenient \nto consider the subtype a `Category` of its indexed items, \nand in other cases&mdash;`Map`, for example&mdash;it is \nconvenient to treat the subtype as a `Category` of its \n[[entries|Entry]].\n\nThe item corresponding to a given key may be obtained from \na `Correspondence` using the item operator:\n\n    value bg = settings[\"backgroundColor\"] else white;\n\nThe `get()` operation and item operator result in an\noptional type, to reflect the possibility that there may be\nno item for the given key."]},nm:"Correspondence"},stringify:{$t:{pk:".",nm:"String"},ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",nm:"val"}]],mt:"m",nm:"stringify"}},"ceylon.language.serialization":{SerializationContext:{pa:17,mt:"i",$m:{references:{$t:{pk:".",nm:"References"},pa:5,ps:[[{$t:{pk:"$",nm:"Anything"},mt:"prm",nm:"instance"}]],mt:"m",an:{doc:["Obtain the references of the given instance."],throws:["SerializationException","If the class is not serializable"]},nm:"references"}},an:{doc:["A context representing serialization of many objects to a \nsingle output stream. \n\nThe serialization library obtains an instance by calling \n[[serialization]] and then uses\n[[references]] to traverse the instances reachable from the \ninstance(s) being serialized.\n\nIt is the serialization library's responsibility to \nmanage object identity and handle cycles in the graph \nof object references. For example a serialization library \nthat produced a hierarchical format might ignore identity \nwhen an instance is encountered multiple times \n(resulting in duplicate subtrees in the output), and \nsimply throw an exception if it encountered a cycle. \n"]},nm:"SerializationContext"},SerializationException:{super:{pk:"$",nm:"Exception"},pa:1,ps:[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"message"},{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:"$",nm:"Throwable"}]},def:1,mt:"prm",nm:"cause"}],mt:"c",$at:{cause$tockc2:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:"$",nm:"Throwable"}]},mt:"a",nm:"cause"},message$lnvdpc:{$t:{pk:"$",nm:"String"},mt:"a",nm:"message"}},an:{doc:["Thrown to indicate an exception event during serialization"]},nm:"SerializationException"},"$pkg-pa":1,DeserializationContextImpl:{super:{pk:"$",nm:"Basic"},sts:[{pk:".",tp:[{mt:"tp",nm:"Id"}],nm:"DeserializationContext"}],mt:"c",$at:{memberTypeCache:{$t:{pk:".",tp:[{mt:"tp",pk:"$",tp:[{mt:"tp",pk:"$",nm:"Object"},{mt:"tp",pk:"$",nm:"String"}],nm:"Entry"},{mt:"tp",pk:"$",nm:"Object"}],nm:"NativeMap"},pa:1,mt:"a",an:{doc:["a cache of \"attribute\" (represented as a TypeDescriptor and an attribute name)\nto its type"]},nm:"memberTypeCache"},instances$t0uhew:{$t:{pk:".",tp:[{mt:"tp",nm:"Id"},{mt:"tp",pk:"$",nm:"Anything"}],nm:"NativeMap"},mt:"a",an:{doc:["The `Item` in the instances map is either a `Partial` or the actual instance\nthat's not ambiguous because `Partial` never leaks, so it's impossible\nfor a client to use the API to instantiate a `Partial`\nthey can only end up in the map due to our implementation.\n"]},nm:"instances"}},$m:{alreadyComplete:{$t:{pk:".",nm:"DeserializationException"},pa:1,ps:[[{$t:{nm:"Id"},mt:"prm",nm:"instanceId"}]],mt:"m",an:{doc:["A [[DeserializationException]] to day that the instance with the given id has already been instantiated."]},nm:"alreadyComplete"},leakInstance:{$t:{pk:"$",nm:"Anything"},pa:1,ps:[[{$t:{nm:"Id"},mt:"prm",nm:"id"}]],mt:"m",an:{doc:["Get the [[Partial]] or instance with the given id"]},nm:"leakInstance"},instance:{$t:{pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{nm:"Id"},mt:"prm",nm:"instanceId"},{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Anything"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"ClassModel"},mt:"prm",nm:"clazz"}]],$ff:1,mt:"m",nm:"instance"},attributeOrElement$7cs20f:{$t:{pk:"$",nm:"Anything"},ps:[[{$t:{nm:"Id"},mt:"prm",nm:"instanceId"},{$t:{pk:".",nm:"ReachableReference"},mt:"prm",nm:"attributeOrIndex"},{$t:{nm:"Id"},mt:"prm",nm:"attributeValueId"}]],$ff:1,mt:"m",an:{doc:["Get or create the [[Partial]] for `instanceId`; \nadd the given `attributeValueId` to its partial state."],throws:["DeserializationException","If the `instanceId` corresponds to a reconstructed \ninstance or to a partial that's already been instantiated"]},nm:"attributeOrElement"},reconstruct:{$t:{nm:"Instance"},pa:3,ps:[[{$t:{nm:"Id"},mt:"prm",nm:"instanceId"}]],mt:"m",tp:[{nm:"Instance"}],nm:"reconstruct"},getOrCreatePartial$gbff5y:{$t:{pk:".",nm:"Partial"},ps:[[{$t:{nm:"Id"},mt:"prm",nm:"instanceId"}]],mt:"m",an:{doc:["Get or create a [[Partial]] for the given `instanceId`."]},nm:"getOrCreatePartial"},attribute:{$t:{pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{nm:"Id"},mt:"prm",nm:"instanceId"},{$t:{pk:"ceylon.language.meta.declaration",nm:"ValueDeclaration"},mt:"prm",nm:"attribute"},{$t:{nm:"Id"},mt:"prm",nm:"attributeValueId"}]],$ff:1,mt:"m",nm:"attribute"},memberInstance:{$t:{pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{nm:"Id"},mt:"prm",nm:"containerId"},{$t:{nm:"Id"},mt:"prm",nm:"instanceId"}]],$ff:1,mt:"m",nm:"memberInstance"},instanceValue:{$t:{pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{nm:"Id"},mt:"prm",nm:"instanceId"},{$t:{pk:"$",nm:"Anything"},mt:"prm",nm:"instanceValue"}]],$ff:1,mt:"m",nm:"instanceValue"},element:{$t:{pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{nm:"Id"},mt:"prm",nm:"instanceId"},{$t:{pk:"$",nm:"Integer"},mt:"prm",nm:"index"},{$t:{nm:"Id"},mt:"prm",nm:"elementValueId"}]],$ff:1,mt:"m",nm:"element"}},tp:[{sts:[{pk:"$",nm:"Object"}],nm:"Id"}],an:{doc:["Implementation of [[DeserializationContext]] using a few native helper classes."]},nm:"DeserializationContextImpl"},ReferencesImpl:{super:{pk:"ceylon.language.impl",tp:[{mt:"tp",pk:"$",tp:[{mt:"tp",pk:".",nm:"ReachableReference"},{mt:"tp",pk:"$",nm:"Anything"}],nm:"Entry"},{mt:"tp",pk:"$",nm:"Null"}],nm:"BaseIterable"},sts:[{pk:".",nm:"References"},{pk:"$",nm:"Identifiable"}],ps:[{$t:{pk:"$",nm:"Anything"},pa:3,mt:"prm",nm:"instance",$hdn:1}],mt:"c",$at:{instance:{$t:{pk:"$",nm:"Anything"},pa:3,mt:"a",nm:"instance"},references:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"ReachableReference"},{mt:"tp",pk:"$",nm:"Null"}],nm:"Iterable"},pa:3,mt:"g",$m:{iterator:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"ReachableReference"}],nm:"Iterator"},pa:3,mt:"m",nm:"iterator"}},nm:"references",$c:{anon$1$jsb07w:{super:{pk:"ceylon.language.impl",tp:[{mt:"tp",pk:".",nm:"ReachableReference"},{mt:"tp",pk:"$",nm:"Null"}],nm:"BaseIterable"},sts:[{pk:"$",nm:"Identifiable"}],mt:"c",$anon:1,nm:"anon$1$jsb07w"}}}},$m:{iterator:{$t:{pk:"$",tp:[{mt:"tp",pk:"$",tp:[{mt:"tp",pk:".",nm:"ReachableReference"},{mt:"tp",pk:"$",nm:"Anything"}],nm:"Entry"}],nm:"Iterator"},pa:3,mt:"m",$at:{it$86cdjk:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"ReachableReference"}],nm:"Iterator"},mt:"a",nm:"it"}},$m:{next:{$t:{comp:"u",l:[{pk:"$",tp:[{mt:"tp",pk:".",nm:"ReachableReference"},{mt:"tp",pk:"$",nm:"Anything"}],nm:"Entry"},{pk:"$",nm:"Finished"}]},pa:3,mt:"m",nm:"next"}},nm:"iterator",$c:{anon$0$f2io3y:{super:{pk:"ceylon.language.impl",tp:[{mt:"tp",pk:"$",tp:[{mt:"tp",pk:".",nm:"ReachableReference"},{mt:"tp",pk:"$",nm:"Anything"}],nm:"Entry"}],nm:"BaseIterator"},sts:[{pk:"$",nm:"Identifiable"}],mt:"c",$anon:1,nm:"anon$0$f2io3y"}}}},nm:"ReferencesImpl"},Element:{pa:17,sts:[{pk:".",nm:"ReachableReference"}],mt:"i",$at:{index:{$t:{pk:"$",nm:"Integer"},pa:5,mt:"a",an:{doc:["The index of the element in the Array which makes the reference."]},nm:"index"}},an:{doc:["\nAn [[Array]] instance referring to another instance via one \nof its elements.\n\nFor example, given:\n\n    value arr = Array({\"hello\"});\n    value context = serialization();\n    value refs = context.references(arr);\n    assert(is Element elementRef = refs.find((element) => element is Element));\n    assert(elementRef.referred(arr) == \"hello\");\n    assert(elementRef.index == 0);"]},nm:"Element"},UninitializedLateValue:{super:{pk:"$",nm:"Basic"},pa:257,mt:"c",of:[{pk:".",nm:"uninitializedLateValue"}],an:{doc:["The type of [[uninitializedLateValue]]."]},nm:"UninitializedLateValue"},Outer:{pa:17,sts:[{pk:".",nm:"ReachableReference"}],mt:"i",$m:{referred:{$t:{pk:"$",nm:"Object"},pa:7,ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"instance"}]],mt:"m",an:{doc:["The outer instance of the given member [[instance]]."]},nm:"referred"}},an:{doc:["A member instance referring to its outer instance."]},nm:"Outer"},DeserializationException:{super:{pk:"$",nm:"Exception"},pa:1,ps:[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"message"},{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:"$",nm:"Throwable"}]},def:1,mt:"prm",nm:"cause"}],mt:"c",$at:{message$r756zb:{$t:{pk:"$",nm:"String"},mt:"a",nm:"message"},cause$o52r23:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:"$",nm:"Throwable"}]},mt:"a",nm:"cause"}},an:{doc:["Thrown to indicate an exception event during deserialization"]},nm:"DeserializationException"},NativeDeque:{super:{pk:"$",nm:"Basic"},pa:64,mt:"c",$at:{string:{$t:{pk:"$",nm:"String"},pa:67,mt:"a",nm:"string"},empty:{$t:{pk:"$",nm:"Boolean"},pa:65,mt:"a",nm:"empty"}},$m:{pushFront:{$t:{pk:"$",nm:"Anything"},pa:65,ps:[[{$t:{pk:"$",nm:"Anything"},mt:"prm",nm:"element"}]],$ff:1,mt:"m",nm:"pushFront"},pushBack:{$t:{pk:"$",nm:"Anything"},pa:65,ps:[[{$t:{pk:"$",nm:"Anything"},mt:"prm",nm:"element"}]],$ff:1,mt:"m",nm:"pushBack"},popFront:{$t:{pk:"$",nm:"Anything"},pa:65,mt:"m",nm:"popFront"}},an:{doc:["A queue with a native implementation"]},nm:"NativeDeque"},serialization:{$t:{pk:".",nm:"SerializationContext"},pa:1,mt:"m",an:{doc:["A new [[SerializationContext]]."]},nm:"serialization"},Partial:{super:{pk:"$",nm:"Basic"},pa:256,ps:[{$t:{pk:"$",nm:"Object"},pa:1,mt:"prm",an:{doc:["The id"]},nm:"id",$hdn:1}],mt:"c",$at:{container:{$t:{pk:"$",nm:"Anything"},pa:1025,mt:"a",an:{doc:["The containing instance (a partial for it, or the instance itself).\nnull if this partial is not a member or we don't know the container yet."]},nm:"container"},refersTo:{$t:{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Object"},{mt:"tp",pk:"$",nm:"Null"}],nm:"Iterable"},pa:1,mt:"g",an:{doc:["The ids of the instances that this instance refers to"]},nm:"refersTo"},instance_:{$t:{pk:"$",nm:"Anything"},pa:1025,mt:"a",an:{doc:["The (partially initialized) instance, if it has been [[instantiated|instantiate]], or null."]},nm:"instance_"},instantiated:{$t:{pk:"$",nm:"Boolean"},pa:1,mt:"g",an:{doc:["Whether the partial has been instantiated"]},nm:"instantiated"},member:{$t:{pk:"$",nm:"Boolean"},pa:1,mt:"g",an:{doc:["Whether the partial is for an instance of a member class"]},nm:"member"},initialized:{$t:{pk:"$",nm:"Boolean"},pa:1,mt:"g",an:{doc:["Whether the partial has been initialized"]},nm:"initialized"},id:{$t:{pk:"$",nm:"Object"},pa:1,mt:"a",an:{doc:["The id"]},nm:"id"},state:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",tp:[{mt:"tp",pk:".",nm:"ReachableReference"},{mt:"tp",pk:"$",nm:"Object"}],nm:"NativeMap"}]},pa:1025,mt:"a",an:{doc:["The state, mapping references to the \n**id** of the corresponding value in the [[DeserializationContext]].\nnullified by a successful call to [[initialize]]."]},nm:"state"},clazz:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Anything"},{mt:"tp",pk:"ceylon.language.meta.model",nm:"Nothing"}],nm:"ClassModel"}]},pa:1025,mt:"a",an:{doc:["The class, if we know it yet"]},nm:"clazz"}},$m:{instance:{$t:{pk:"$",nm:"Anything"},pa:1,mt:"m",an:{doc:["Gets the fully initialized instance, or throws"]},nm:"instance"},initialize:{$t:{pk:"$",nm:"Anything"},pa:5,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Id"}],nm:"DeserializationContextImpl"},mt:"prm",nm:"context"}]],$ff:1,mt:"m",tp:[{sts:[{pk:"$",nm:"Object"}],nm:"Id"}],an:{doc:["Initializes the [[instance_]] using backend-specific reflection.\nAfter normal completion of this method state will be null."],throws:["DeserializationException","the partial contains insufficient state"]},nm:"initialize"},addState:{$t:{pk:"$",nm:"Anything"},pa:1,ps:[[{$t:{pk:".",nm:"ReachableReference"},mt:"prm",nm:"attrOrIndex"},{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"partialOrComplete"}]],$ff:1,mt:"m",an:{doc:["Add some state."]},nm:"addState"},instantiate:{$t:{pk:"$",nm:"Anything"},pa:5,$ff:1,mt:"m",an:{doc:["Creates (but does not initialize) the [[instance_]] using backend-specific reflection.\nAfter normal completion of this method instance_ will be non-null."],throws:["DeserializationException","* the class of the instance has already been specified\n* instance is a member instance and the container has not been specified"]},nm:"instantiate"}},an:{doc:["A partially reconstructed instance: \nHolds state for reconstructing an instance which is built up \nprogressively by calls to the [[DeserializationContext]]."]},nm:"Partial"},SerializationContextImpl:{super:{pk:"$",nm:"Basic"},sts:[{pk:".",nm:"SerializationContext"}],mt:"c",$m:{references:{$t:{pk:".",nm:"References"},pa:3,ps:[[{$t:{pk:"$",nm:"Anything"},mt:"prm",nm:"instance"}]],mt:"m",nm:"references"}},nm:"SerializationContextImpl"},References:{pa:17,sts:[{pk:"$",tp:[{mt:"tp",pk:"$",tp:[{mt:"tp",pk:".",nm:"ReachableReference"},{mt:"tp",pk:"$",nm:"Anything"}],nm:"Entry"},{mt:"tp",pk:"$",nm:"Null"}],nm:"Iterable"}],mt:"i",$at:{instance:{$t:{pk:"$",nm:"Anything"},pa:5,mt:"a",an:{doc:["The instance"]},nm:"instance"},references:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"ReachableReference"},{mt:"tp",pk:"$",nm:"Null"}],nm:"Iterable"},pa:5,mt:"a",an:{doc:["The references that are reachable from the [[instance]]."]},nm:"references"}},an:{doc:["Exposes the instances directly reachable from a given instance."]},nm:"References"},PartialImpl:{super:{pk:".",nm:"Partial"},pa:64,ps:[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"id"}],mt:"c",$at:{id$qh77bu:{$t:{pk:"$",nm:"Object"},mt:"a",nm:"id"}},$m:{initialize:{$t:{pk:"$",nm:"Anything"},pa:67,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Id"}],nm:"DeserializationContextImpl"},mt:"prm",nm:"context"}]],$ff:1,mt:"m",tp:[{sts:[{pk:"$",nm:"Object"}],nm:"Id"}],nm:"initialize"},instantiate:{$t:{pk:"$",nm:"Anything"},pa:67,$ff:1,mt:"m",nm:"instantiate"}},nm:"PartialImpl"},deserialization:{$t:{pk:".",tp:[{mt:"tp",nm:"Id"}],nm:"DeserializationContext"},pa:1,mt:"m",tp:[{sts:[{pk:"$",nm:"Object"}],nm:"Id"}],an:{doc:["A new [[DeserializationContext]]."]},nm:"deserialization"},DeserializationContext:{pa:17,mt:"i",$m:{instance:{$t:{pk:"$",nm:"Anything"},pa:5,ps:[[{$t:{nm:"Id"},mt:"prm",nm:"instanceId"},{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Anything"},{mt:"tp",pk:"ceylon.language.meta.model",nm:"Nothing"}],nm:"ClassModel"},mt:"prm",nm:"clazz"}]],$ff:1,mt:"m",an:{doc:["The given [[instanceId]] refers to an instance of the given class."],throws:["DeserializationException","the given instance was specified by [[instanceValue]] or has already been reconstructed."]},nm:"instance"},reconstruct:{$t:{nm:"Instance"},pa:5,ps:[[{$t:{nm:"Id"},mt:"prm",nm:"instanceId"}]],mt:"m",tp:[{nm:"Instance"}],an:{doc:["Get the instance with the given [[instanceId]] reconstructing it \nif necessary."],throws:["DeserializationException","the instance, or an instance reachable from it, \ncould not be reconstructed"]},nm:"reconstruct"},memberInstance:{$t:{pk:"$",nm:"Anything"},pa:5,ps:[[{$t:{nm:"Id"},mt:"prm",nm:"containerId"},{$t:{nm:"Id"},mt:"prm",nm:"instanceId"}]],$ff:1,mt:"m",an:{doc:["The given [[instanceId]] is a member of the instance with the given [[containerId]].\n\nThis is used for member class instances."],throws:["DeserializationException","the given instance was specified by [[instanceValue]] or has already been reconstructed."]},nm:"memberInstance"},attribute:{$t:{pk:"$",nm:"Anything"},pa:5,ps:[[{$t:{nm:"Id"},mt:"prm",nm:"instanceId"},{$t:{pk:"ceylon.language.meta.declaration",nm:"ValueDeclaration"},mt:"prm",nm:"attribute"},{$t:{nm:"Id"},mt:"prm",nm:"attributeValueId"}]],$ff:1,mt:"m",an:{doc:["The value of the given [[attribute]] of the instance with \nthe given [[instanceId]] has given [[attributeValueId]]."],throws:["DeserializationException","the given instance was specified by [[instanceValue]] or has already been reconstructed."]},nm:"attribute"},instanceValue:{$t:{pk:"$",nm:"Anything"},pa:5,ps:[[{$t:{nm:"Id"},mt:"prm",nm:"instanceId"},{$t:{pk:"$",nm:"Anything"},mt:"prm",nm:"instanceValue"}]],$ff:1,mt:"m",an:{doc:["The instance with the given [[instanceId]] has the given value.\n\nThis can used to register non-serializable instances with the context, \nfor example object declarations."]},nm:"instanceValue"},element:{$t:{pk:"$",nm:"Anything"},pa:5,ps:[[{$t:{nm:"Id"},mt:"prm",nm:"instanceId"},{$t:{pk:"$",nm:"Integer"},mt:"prm",nm:"index"},{$t:{nm:"Id"},mt:"prm",nm:"elementValueId"}]],$ff:1,mt:"m",an:{doc:["The value at the given [[index]] of the [[Array]] instance with \nthe given [[instanceId]] has given [[elementValueId]]."],throws:["DeserializationException","the given instance was specified by [[instanceValue]] or has already been reconstructed."]},nm:"element"}},tp:[{nm:"Id"}],an:{doc:["A contract for identifying instances, specifying their classes, attributes, \nelements and values, and ultimately reconstructing those instances.\n\nInstances are identified using the [[Id]]'s semantics for equality. The \nmethods of this interface can be called in any order; the id serves to \nassociate each method invocation with the instance(s) to pertains to. \nThe only constraint is that [[reconstruct]] will throw if the context \nlacks enough information to fully initialize the requested instance \n_or any instance reachable from it_. Reference cycles are supported.\n\nFor example, given\n\n    serializable class Person(name, employer) {\n        shared String name;\n        shared Company employer;\n    }\n    serializable class Company(name) {\n        shared String name;\n        shared late Person owner;\n    }\n  \nAnd an instance graph corresponding to:\n\n    value wonkaInc = Company(\"Wonka Inc.\");\n    value willy = Person(\"Willy Wonka\", wonkaInc);\n    value umpaLumpa = Person(\"Umpa lumpa\", wonkaInc);\n    wonkaInc.owner = willy;\n\nThen we could reconstruct that instance graph like so:\n\n    value dc = deserialization<String>();\n    \n    dc.attribute(\"ww\", `value Person.name`, \"wwn\");\n    dc.attribute(\"ww\", `value Person.employer`, \"wi\");\n    dc.attribute(\"ul\", `value Person.name`, \"uln\");\n    dc.attribute(\"ul\", `value Person.employer`, \"wi\");\n    dc.attribute(\"wi\", `value Company.name`, \"win\");\n    dc.attribute(\"wi\", `value Company.owner`, \"ww\");\n    \n    dc.instanceValue(\"win\", \"Wonka Inc.\");\n    dc.instanceValue(\"wwn\", \"Willy Wonka\");\n    dc.instanceValue(\"uln\", \"Umpa lumpa\");\n    \n    dc.instance(\"wi\", `Company`);\n    dc.instance(\"ww\", `Person`);\n    dc.instance(\"ul\", `Person`);\n    \n    value wonkaInc2 = dc.reconstruct<Company>(\"wi\");\n    value willy2 = dc.reconstruct<Person>(\"ww\");\n    value umpaLumpa2 = dc.reconstruct<Person>(\"ul\");\n    \n    assert(wonkaInc2.owner === willy2);\n    assert(willy2.employer === wonkaInc2);\n    assert(umpaLumpa2.employer === wonkaInc2);\n    \nThe calls to [[attribute]], [[instanceValue]] and [[instance]] could be \nin any order."]},nm:"DeserializationContext"},NativeMap:{super:{pk:"$",nm:"Basic"},pa:64,mt:"c",$at:{size:{$t:{pk:"$",nm:"Integer"},pa:65,mt:"a",nm:"size"},string:{$t:{pk:"$",nm:"String"},pa:67,mt:"a",nm:"string"},keys:{$t:{pk:"$",tp:[{mt:"tp",nm:"Key"},{mt:"tp",pk:"$",nm:"Null"}],nm:"Iterable"},pa:65,mt:"a",nm:"keys"},items:{$t:{pk:"$",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:"$",nm:"Null"}],nm:"Iterable"},pa:65,mt:"a",nm:"items"}},$m:{contains:{$t:{pk:"$",nm:"Boolean"},pa:65,ps:[[{$t:{nm:"Key"},mt:"prm",nm:"id"}]],mt:"m",nm:"contains"},get:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{nm:"Element"}]},pa:65,ps:[[{$t:{nm:"Key"},mt:"prm",nm:"id"}]],mt:"m",nm:"get"},put:{$t:{pk:"$",nm:"Anything"},pa:65,ps:[[{$t:{nm:"Key"},mt:"prm",nm:"id"},{$t:{nm:"Element"},mt:"prm",nm:"instanceOrPartial"}]],$ff:1,mt:"m",nm:"put"}},tp:[{nm:"Key"},{nm:"Element"}],an:{doc:["Need a map-like thing, but can't use java.util.HashMap directly, not ceylon.collection::HashMap"]},nm:"NativeMap"},Member:{pa:17,sts:[{pk:".",nm:"ReachableReference"}],mt:"i",$at:{attribute:{$t:{pk:"ceylon.language.meta.declaration",nm:"ValueDeclaration"},pa:5,mt:"a",an:{doc:["The attribute making the reference."]},nm:"attribute"}},$m:{referred:{$t:{pk:"$",nm:"Anything"},pa:7,ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"instance"}]],mt:"m",an:{doc:["The [[referred]] instance reachable from the given [[instance]].\n\nNote: If this member refers to a `late` declaration and the \nattribute of the given instance has not been initialized this \nmethod will return [[uninitializedLateValue]]."]},nm:"referred"}},an:{doc:["An instance referring to another instance via a reference attribute."]},nm:"Member"},"$pkg-anns":{tagged:["Serialization"],by:["Gavin","Tom"],doc:["The Ceylon serialization infrastructure.\n\nThis package provides an API for *serialization libraries* to\nprovide their own serialization APIs to client code. It does not \nprovide a serialization service itself.\n\nThis API:\n\n* provides a way to walk the graph of instances added for serialization, \n  including those reachable via non-\\`shared\\` attributes,\n* copes with shared references and cyclic references in object graphs,\n* prevents access to uninitialized and partially initialized instances \n  during deserialization.  \n  (this includes instances reachable from other instances, transitively).\n  \nThe API cannot prevent serialization libraries from obtaining access to \nnon-\\`shared\\` state of instances (loss of encapsulation is \nan inevitable part of serialization).\n\nA serialization library will implement some kind of \nserializer and\/or deserializer (frequently both) using the facilities \nof this API.\n\n## Serializers\n\nA *serializer* takes one or many Ceylon instances and serialize them \n(and the instances reachable from them) to \nsome external representation, usually bytes or text in some specific format. \n\nA serializer provided by a serialization library:\n\n* obtains a [[SerializationContext]] by \n  calling [[serialization]],\n* uses [[SerializationContext.references]] to find the references that \n  an instance holds,\n* proceeds to traverse the graph of instances according to \n  library-specific rules\n\n## Deserializers\n\nA *deserializer* constructs a graph of \nCeylon instances according to some external representation.\n  \nA deserializer provided by a serialization library:\n\n* obtains a [[DeserializationContext]] by \n  calling [[deserialization]]\n* progressively provides information about instances:\n\n    * associates an instance with its \n      [[class|DeserializationContext.instance]],\n    * associates a member instance with its [[containing instance|DeserializationContext.memberInstance]],\n    * associates a referred instance with its [[referring instance and attribute|DeserializationContext.attribute]],\n    * associates a referred instance with its [[referring array index|DeserializationContext.element]],\n    * associates an instance with a [[given other instance|DeserializationContext.instanceValue]]. \n      This is useful for instances which refer to singletons \n      (on deserialization the singleton value has to be provided, since it \n      cannot be instantiated by the serialization API).\n         \n* once the context has complete information about the instance \n  and every instance reachable from it\n  the instance can be \n  [[reconstructed|DeserializationContext.reconstruct]].\n \n## Serializability\n\n*Serializability* is whether or not a particular serialization library can \nserialize a particular instance. \n\nInstances of classes which are annotated [[serializable]] are able to \nenumerate their state during serialization, \nand initialize their state during deserialization.\nHowever, that does not imply that every serialization library \ncan necessarily serialize instances of every `serializable` class.\n  \nThe serializability of an instance can depend on:\n\n* the class of the instance, and its super classes,\n* the serializability of the outer instance(s), if the object is an \n  instance of a member class. ,\n* the serialization library's support for serializing generic classes, \n  and member classes,\n* the serialization library's support for serializing anonymous objects\n  (such as `true`, `null` or `smaller`),\n* the underlying serialization format the serialization library supports\n   \nThe deserializability of an instance can depend on:\n\n* The runtime availability and compatibility of the class of the instances, \n  and its super classes, for each instance in the object graph. "]},uninitializedLateValue:{super:{pk:".",nm:"UninitializedLateValue"},pa:1,mt:"o",an:{doc:["A singleton used to indicate that a `late` [[Member]] of a particular \ninstance has not been initialized.\n\nFor example, given\n\n    class Example() {\n        shared late Example parent;\n    }\n    \nThen\n    \n    value ex = Example();\/\/ uninitialized parent\n    value context = serialization();\n    value refs = context.references(ex);\n    assert(is Member parentRef = refs.find((element) => element is Member));\n    assert(parentRef.referred(ex) == uninitializedLateValue);\n    \nThus, *if a serialization library supports it*, it is \npossible to serialize uninitialized `late` values."]},nm:"uninitializedLateValue"},ReachableReference:{pa:1,mt:"i",of:[{pk:".",nm:"Member"},{pk:".",nm:"Element"},{pk:".",nm:"Outer"}],$m:{referred:{$t:{pk:"$",nm:"Anything"},pa:5,ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"instance"}]],mt:"m",an:{doc:["The [[referred]] instance reachable from the given [[instance]]."]},nm:"referred"}},an:{doc:["A means via which one instance can refer to another."]},nm:"ReachableReference"}},"ceylon.language.meta":{optionalAnnotation:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{nm:"Value"}]},pa:1,ps:[[{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",tp:[{mt:"tp",nm:"Value"},{mt:"tp",nm:"ProgramElement"},{mt:"tp",pk:"$",nm:"Anything"}],nm:"OptionalAnnotation"},{mt:"tp",pk:"ceylon.language.meta.model",nm:"Nothing"}],nm:"Class"},mt:"prm",nm:"annotationType"},{$t:{nm:"ProgramElement"},mt:"prm",nm:"programElement"}]],mt:"m",tp:[{sts:[{pk:"$",tp:[{mt:"tp",nm:"Value"},{mt:"tp",nm:"ProgramElement"},{mt:"tp",pk:"$",nm:"Anything"}],nm:"OptionalAnnotation"}],nm:"Value"},{dv:"in",sts:[{pk:"$",nm:"Annotated"}],nm:"ProgramElement"}],an:{doc:["The value of given optional annotation type on the given program element, \nor null if the program element was not annotated with that annotation type.\nFor example:\n\n    \/\/ Does the process declaration have the Shared annotation?\n    value isShared = optionalAnnotation(`SharedAnnotation`, `value process`) exists;\n"]},nm:"optionalAnnotation"},typeLiteral:{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",nm:"Type"}],nm:"Type"},pa:65,mt:"m",tp:[{dv:"out",sts:[{pk:"$",nm:"Anything"}],nm:"Type"}],an:{doc:["Functional equivalent to type literals. Allows you to get a closed type instance\nfor a given type argument.\n\nFor example:\n\n    assert(is Interface<List<Integer>> listOfIntegers = typeLiteral<List<Integer>>());\n"]},nm:"typeLiteral"},"$pkg-pa":1,sequencedAnnotations:{$t:{pk:"$",tp:[{mt:"tp",nm:"Value"}],nm:"Sequential"},pa:1,ps:[[{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",tp:[{mt:"tp",nm:"Value"},{mt:"tp",nm:"ProgramElement"},{mt:"tp",pk:"$",nm:"Anything"}],nm:"SequencedAnnotation"},{mt:"tp",pk:"ceylon.language.meta.model",nm:"Nothing"}],nm:"Class"},mt:"prm",nm:"annotationType"},{$t:{nm:"ProgramElement"},mt:"prm",nm:"programElement"}]],mt:"m",tp:[{sts:[{pk:"$",tp:[{mt:"tp",nm:"Value"},{mt:"tp",nm:"ProgramElement"},{mt:"tp",pk:"$",nm:"Anything"}],nm:"SequencedAnnotation"}],nm:"Value"},{dv:"in",sts:[{pk:"$",nm:"Annotated"}],nm:"ProgramElement"}],an:{doc:["The values of given sequenced annotation type on the given program element, \nor empty if the program element was not annotated with that annotation type.\nFor example:\n\n    \/\/ Does the sum declaration have any ThrownException annotations?\n    value throwsSomething = sequencedAnnotation(`ThrownException`, `function sum`) nonempty;\n\nThe annotations may be returned in any order.\n"]},nm:"sequencedAnnotations"},annotations:{$t:{nm:"Values"},pa:65,ps:[[{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",tp:[{mt:"tp",nm:"Value"},{mt:"tp",nm:"Values"},{mt:"tp",nm:"ProgramElement"},{mt:"tp",pk:"$",nm:"Anything"}],nm:"ConstrainedAnnotation"},{mt:"tp",pk:"ceylon.language.meta.model",nm:"Nothing"}],nm:"Class"},mt:"prm",nm:"annotationType"},{$t:{nm:"ProgramElement"},mt:"prm",nm:"programElement"}]],mt:"m",tp:[{sts:[{pk:"$",tp:[{mt:"tp",nm:"Value"},{mt:"tp",nm:"Values"},{mt:"tp",nm:"ProgramElement"},{mt:"tp",pk:"$",nm:"Anything"}],nm:"ConstrainedAnnotation"}],nm:"Value"},{nm:"Values"},{dv:"in",sts:[{pk:"$",nm:"Annotated"}],nm:"ProgramElement"}],an:{doc:["The annotations of the [[given type|annotationType]] \napplied to the [[given program element|programElement]]. \nFor example:\n\n    \/\/ Does the process declaration have any annotations\n    \/\/ of type SharedAnnotation?\n    value isShared = annotations(`SharedAnnotation`, `value process`) exists;\n\nThe annotations may be returned in any order."]},nm:"annotations"},type:{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",nm:"Type"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"ClassModel"},pa:65,ps:[[{$t:{nm:"Type"},mt:"prm",nm:"instance"}]],mt:"m",tp:[{dv:"out",sts:[{pk:"$",nm:"Anything"}],nm:"Type"}],an:{see:["classDeclaration"],doc:["Returns the closed type and model of a given instance. Since only classes\ncan be instantiated, this will always be a [[ClassModel]] model."]},nm:"type"},"$pkg-anns":{tagged:["Metamodel"],by:["Gavin King","Stephane Epardaud","Tom Bentley"],doc:["The Ceylon metamodel base package.\n\nThe Ceylon metamodel allows you to: \n\n* dynamically inspect modules, packages, functions, values and types, \n* invoke functions, constructors and class initialisers, \n* read and write values, and\n* inspect the annotations on program elements.\n\n### A little bit of terminology\n\nThere are a few concepts and terms in the Ceylon metamodel API that you should be familiar with:\n\n- A _declaration_ is the definition of a Ceylon construct, such as a module, package, value, function\n  or class. Declarations are singletons: there is only a single instance of a given class declaration,\n  for example. You can inspect declarations to get information about how they were defined by their\n  author. You cannot directly invoke function or class declarations, but you can _apply_ them to get\n  a _model_ that you can invoke.\n- A _model_ is a Ceylon definition that represents a declaration where all the type variables have\n  been bound to _closed type_ values. You can query models for their member models and you can directly\n  invoke models.\n- A _closed type_ is a type which does not contain any unbound type variables.\n- An _open type_ is a type which may contain unbound type variables.\n\nFor example, given the following Ceylon program:\n\n    shared abstract class MyList<T>() satisfies List<T>{}\n\nThe declaration of `MyList` represents the class declaration and contains the information that it is\n`abstract` and that it satisfies the `List<T>` open type. That type is open because it contains an\nunbound type variable `T`, which is not bound when we inspect the `MyList` class declaration.\n\nGiven an particular instance of `MyList`, we can query its (closed) type with the [[type]] function,\nand we obtain a closed type representing (for example) `MyList<Integer>`. Object instances necessarily\nhave a closed type at runtime, since in order to instantiate an object, all type arguments must be\nprovided and known during instantiation, so the type of an object instance at runtime is necessarily\na closed type: they cannot contain unbound type variables.\n\nClosed types that represent class or interfaces are also models. For example, the closed type of our\n`MyList<Integer>` instance is both a closed type and a class model: you can query its satisfied types\nand find that it satisfies `List<Integer>` closed type and model (as opposed to the class declaration\nof `MyList` which satisfies the `List<T>` open type). You can also invoke that model to obtain a new\ninstance of `MyList<Integer>`.\n\n### Model and declaration literals\n\nCeylon supports getting declaration values using either the declaration API or using declaration\nliterals:\n\n- <code>\\`module ceylon.file\\`<\/code> returns the [[Module|ceylon.language.meta.declaration::Module]] \n  declaration which corresponds to the `ceylon.file` module you imported in your module descriptor, or\n  to the current module if it is `ceylon.file`. You can also obtain a reference to the current module\n  with <code>\\`module\\`<\/code>.\n- <code>\\`package ceylon.language.meta\\`<\/code> returns the [[Package|ceylon.language.meta.declaration::Package]]\n  declaration from your current module or its imports. You can also obtain a reference to the current package\n  with <code>\\`package\\`<\/code>.\n- <code>\\`interface List\\`<\/code> returns the [[InterfaceDeclaration|ceylon.language.meta.declaration::InterfaceDeclaration]] \n  for the [[List|ceylon.language::List]] type. You can also obtain a reference to the current interface\n  with <code>\\`interface\\`<\/code>.\n- <code>\\`class Integer\\`<\/code> returns the [[ClassDeclaration|ceylon.language.meta.declaration::ClassDeclaration]] \n  for the [[Integer|ceylon.language::Integer]] type. You can also obtain a reference to the current class\n  with <code>\\`class\\`<\/code>.\n- <code>\\`new Array.ofSize\\`<\/code> returns the \n  [[CallableConstructorDeclaration|ceylon.language.meta.declaration::CallableConstructorDeclaration]] \n  for the [[Array.ofSize]] constructor. Similarly <code>\\`new Color.black\\`<\/code> for \n  [[value constructors|ceylon.language.meta.declaration::ValueConstructorDeclaration]].\n- <code>\\`function type\\`<\/code> returns the [[FunctionDeclaration|ceylon.language.meta.declaration::FunctionDeclaration]] \n  for the [[type]] function. Similarly <code>\\`function List.shorterThan\\`<\/code> for methods.\n- <code>\\`value modules\\`<\/code> returns the [[ValueDeclaration|ceylon.language.meta.declaration::ValueDeclaration]] \n  for the [[modules]] value. Similarly <code>\\`function List.size\\`<\/code> for attributes.\n- <code>\\`alias AliasName\\`<\/code> returns the [[AliasDeclaration|ceylon.language.meta.declaration::AliasDeclaration]]\n  for the `AliasName` type alias. \n- <code>\\`given T\\`<\/code> returns the [[TypeParameter|ceylon.language.meta.declaration::TypeParameter]] \n  for the `T` type parameter.\n\nNote that declaration literals cannot have type arguments specified on types or methods, as declarations are not types.\n\nYou can also get access to closed types and model using either the model API or using literals: \n\n- <code>\\`List&lt;Integer>\\`<\/code> returns the [[Interface|ceylon.language.meta.model::Interface]] model and \n  closed type for the [[List|ceylon.language::List]] type applied with the [[Integer|ceylon.language::Integer]] type argument.\n- <code>\\`Integer\\`<\/code> returns the [[Class|ceylon.language.meta.model::Class]] model and closed type \n  for the [[Integer|ceylon.language::Integer]] type.\n- <code>\\`Array<Integer>.ofSize\\`<\/code> returns the \n  [[CallableConstructor|ceylon.language.meta.model::CallableConstructor]] model \n  for the [[Array<Integer>.ofSize|Array.ofSize]] constructor.\n  Similarly <code>\\`Color.black\\`<\/code> for \n  [[value constructor models|ceylon.language.meta.model::ValueConstructor]].\n- <code>\\`type&lt;Integer>\\`<\/code> returns the [[Function|ceylon.language.meta.model::Function]] model \n  for the [[type]] function applied with the [[Integer|ceylon.language::Integer]] type argument.\n  Similarly <code>\\`List&lt;Integer>.shorterThan\\`<\/code> for \n  [[method models|ceylon.language.meta.model::Method]].\n- <code>\\`modules\\`<\/code> returns the [[Value|ceylon.language.meta.model::Value]] model \n  for the [[modules]] value. Similarly <code>\\`List&lt;Integer>.size\\`<\/code> for \n  [[attribute models|ceylon.language.meta.model::Attribute]].\n- <code>\\`A & B\\`<\/code> returns a [[IntersectionType|ceylon.language.meta.model::IntersectionType]]\n  for the `A & B` intersection type.\n- <code>\\`A | B\\`<\/code> returns a [[UnionType|ceylon.language.meta.model::UnionType]]\n  for the `A | B` union type.\n- <code>\\`T\\`<\/code> returns a [[Type|ceylon.language.meta.model::Type]] representing the runtime type \n  argument value for the `T` type parameter.\n\nNotice that all model and close type literals must be applied with all required type arguments.\n\n### Accessing the metamodel using the API\n\nAside from declaration and model literals there are several ways you can start using the metamodel API:\n\n- The [[modules]] object contains a list of all currently loaded [[Module|ceylon.language.meta.declaration::Module]]\n  declarations. Note that these contain even modules you did not import as it contains all transitive\n  dependencies, and may contain multiple different versions of the same module.\n- The [[classDeclaration]] function will return the \n  [[ceylon.language.meta.declaration::ClassDeclaration]] of the given instance.\n- The [[type]] function will return the closed type of the given instance, which can only be a\n  [[ClassModel|ceylon.language.meta.model::ClassModel]] since only classes can be instantiated.\n- The [[typeLiteral]] function is the functional equivalent to closed type literals: it turns a type argument\n  value into a metamodel closed type.\n- The [declaration](declaration\/index.html) package contains all the declaration and open types.\n- The [model](model\/index.html) package contains all the model and closed types.\n\n### Inspecting annotations\n\nConstrained annotations can be inspected using the [[annotations]] \nfunction, like this:\n\n    \/\/ Does the process declaration have the Shared annotation?\n    value isShared = annotations(`SharedAnnotation`, `value process`) exists;\n\nor the related [[optionalAnnotation]] and [[sequencedAnnotations]] functions.\n\nNote that annotations are queried for via their \n[[ceylon.language::Annotation]] type, \nnot by the annotation constructor which was used to annotate \nthe program element.\n"]},modules:{super:{pk:"$",nm:"Basic"},pa:65,mt:"o",$at:{default:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:"ceylon.language.meta.declaration",nm:"Module"}]},pa:65,mt:"a",an:{doc:["Returns the default module, if there is one. This is only the case when\nyou are running the default module."]},nm:"default"},list:{$t:{pk:"$",tp:[{mt:"tp",pk:"ceylon.language.meta.declaration",nm:"Module"}],nm:"Sequential"},pa:65,mt:"a",an:{doc:["Returns the list of all currently loaded modules. This may include modules that\nwere not imported directly but your module, and multiple versions of the same\nmodule."]},nm:"list"}},$m:{find:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:"ceylon.language.meta.declaration",nm:"Module"}]},pa:65,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"},{$t:{pk:"$",nm:"String"},mt:"prm",nm:"version"}]],mt:"m",an:{doc:["Finds a module by name and version, returns `null` if not found."]},nm:"find"}},an:{doc:["Represents the list of Ceylon modules currently loaded at runtime.\n\nNote that this contains all loaded modules, including those that are\nnot imported by your module.\n\nSince Ceylon supports module isolation at runtime, it is possible that\nthere are more than one version of a given module loaded at the same time.\n\n### Usage example\n\nHere's how you would iterate all the loaded modules and print their name and version:\n\n    import ceylon.language.meta { modules }\n\n    for(mod in modules.list){\n        print(\"Module: ``mod.name``\/``mod.version``\");\n    }\n"]},nm:"modules"},classDeclaration:{$t:{pk:"ceylon.language.meta.declaration",nm:"ClassDeclaration"},pa:65,ps:[[{$t:{pk:"$",nm:"Anything"},mt:"prm",nm:"instance"}]],mt:"m",an:{doc:["Returns the class declaration for a given instance. Since only classes\ncan be instantiated, this will always be a [[ClassDeclaration]] model.\n\nUsing `declaration` can be more efficient than using [[type]] and \nobtaining the ClassDeclaration from the returned ClassModel."]},nm:"classDeclaration"}},"ceylon.language.meta.declaration":{OpenType:{pa:17,mt:"i",of:[{pk:".",nm:"nothingType"},{pk:".",nm:"OpenClassOrInterfaceType"},{pk:".",nm:"OpenTypeVariable"},{pk:".",nm:"OpenUnion"},{pk:".",nm:"OpenIntersection"}],an:{doc:["An open type.\n\nAn open type is a type which may contain unbound type variables, such as `List<T>`."]},nm:"OpenType"},SetterDeclaration:{pa:17,sts:[{pk:".",nm:"NestableDeclaration"}],mt:"i",$at:{formal:{$t:{pk:"$",nm:"Boolean"},pa:3,mt:"g",nm:"formal"},container:{$t:{comp:"u",l:[{pk:".",nm:"NestableDeclaration"},{pk:".",nm:"Package"}]},pa:3,mt:"g",nm:"container"},actual:{$t:{pk:"$",nm:"Boolean"},pa:3,mt:"g",nm:"actual"},shared:{$t:{pk:"$",nm:"Boolean"},pa:3,mt:"g",nm:"shared"},default:{$t:{pk:"$",nm:"Boolean"},pa:3,mt:"g",nm:"default"},containingModule:{$t:{pk:".",nm:"Module"},pa:3,mt:"g",nm:"containingModule"},toplevel:{$t:{pk:"$",nm:"Boolean"},pa:3,mt:"g",nm:"toplevel"},containingPackage:{$t:{pk:".",nm:"Package"},pa:3,mt:"g",nm:"containingPackage"},variable:{$t:{pk:".",nm:"ValueDeclaration"},pa:5,mt:"a",an:{doc:["The variable value this setter is for."]},nm:"variable"}},an:{doc:["A setter declaration represents the assign block of a [[ValueDeclaration]]."]},nm:"SetterDeclaration"},TypeParameter:{pa:17,sts:[{pk:".",nm:"Declaration"}],mt:"i",$at:{container:{$t:{pk:".",nm:"NestableDeclaration"},pa:5,mt:"a",an:{doc:["The declaration that declared this type parameter. This is either a [[ClassOrInterfaceDeclaration]] or a\n[[FunctionDeclaration]]."]},nm:"container"},satisfiedTypes:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"OpenType"}],nm:"Sequential"},pa:5,mt:"a",an:{doc:["The `satisfies` upper bounds for this type parameter."]},nm:"satisfiedTypes"},variance:{$t:{pk:".",nm:"Variance"},pa:5,mt:"a",an:{doc:["This type parameter's variance, as defined by `in` or `out` keywords."]},nm:"variance"},defaulted:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this type parameter has a default type argument and can be omitted."]},nm:"defaulted"},defaultTypeArgument:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"OpenType"}]},pa:5,mt:"a",an:{doc:["This type parameter's default type argument, if it has one."]},nm:"defaultTypeArgument"},caseTypes:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"OpenType"}],nm:"Sequential"},pa:5,mt:"a",an:{doc:["The `of` enumerated bounds for this type parameter."]},nm:"caseTypes"}},an:{doc:["A type parameter declaration."]},nm:"TypeParameter"},Import:{pa:17,sts:[{pk:"$",nm:"Identifiable"},{pk:"$",nm:"Annotated"}],mt:"i",$at:{container:{$t:{pk:".",nm:"Module"},pa:5,mt:"a",an:{doc:["The containing module."]},nm:"container"},shared:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this imported module is shared."]},nm:"shared"},name:{$t:{pk:"$",nm:"String"},pa:5,mt:"a",an:{doc:["The name of the imported module."]},nm:"name"},optional:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this imported module is optional."]},nm:"optional"},version:{$t:{pk:"$",nm:"String"},pa:5,mt:"a",an:{doc:["The compile-time version of the imported module."]},nm:"version"}},an:{doc:["Model of an `import` declaration \nwithin a module declaration."]},nm:"Import"},ValueConstructorDeclaration:{pa:17,sts:[{pk:".",nm:"GettableDeclaration"},{pk:".",nm:"ConstructorDeclaration"}],mt:"i",$at:{container:{$t:{pk:".",nm:"ClassDeclaration"},pa:7,mt:"a",an:{doc:["The class this constructor constructs"]},nm:"container"}},$m:{memberApply:{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Result"}],nm:"MemberClassValueConstructor"},pa:5,ps:[[{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Object"}],nm:"Type"},mt:"prm",nm:"containerType"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Result"}],nm:"memberApply"},apply:{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",nm:"Result"}],nm:"ValueConstructor"},pa:5,mt:"m",tp:[{def:{pk:"$",nm:"Anything"},nm:"Result"}],nm:"apply"},get:{$t:{pk:"$",nm:"Object"},pa:11,mt:"m",an:{doc:["Reads the current value of this toplevel value."]},nm:"get"},memberGet:{$t:{pk:"$",nm:"Object"},pa:11,ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"container"}]],mt:"m",an:{doc:["Reads the current value of this attribute on the given container instance."],throws:["StorageException","If this attribute is not stored at runtime, for example if it is \nneither shared nor captured."]},nm:"memberGet"}},an:{see:["CallableConstructorDeclaration"],doc:["Declaration model for value constructors, for example\n\n    class Currency {\n        \"The US Dollar\"\n        shared new usd {}\n        \/\/ ...\n    }\n    \n    ValueConstructorDeclaration dollars = `new Currency.usd`;\n"]},nm:"ValueConstructorDeclaration"},ClassOrInterfaceDeclaration:{pa:17,sts:[{pk:".",nm:"NestableDeclaration"},{pk:".",nm:"GenericDeclaration"}],mt:"i",of:[{pk:".",nm:"ClassDeclaration"},{pk:".",nm:"InterfaceDeclaration"}],$at:{satisfiedTypes:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"OpenInterfaceType"}],nm:"Sequential"},pa:5,mt:"a",an:{doc:["The list of types satisfied by this type."]},nm:"satisfiedTypes"},isAlias:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this type is an alias type, in which case the [[extendedType]] will \ncontain the substituted type."]},nm:"isAlias"},extendedType:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"OpenClassType"}]},pa:5,mt:"a",an:{doc:["This type's extended type, unless this is the class for \n[[Anything|ceylon.language::Anything]], whichis the root \nof the type hierarchy and thus does not have any extended type."]},nm:"extendedType"},caseTypes:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"OpenType"}],nm:"Sequential"},pa:5,mt:"a",an:{doc:["If this type has an `of` clause, this is the list of case types for the current type."]},nm:"caseTypes"}},$m:{memberApply:{$t:{comp:"i",l:[{pk:"ceylon.language.meta.model",tp:[{mt:"tp",nm:"Container"},{mt:"tp",pk:"ceylon.language.meta.model",tp:[{mt:"tp",nm:"Type"}],nm:"ClassOrInterface"}],nm:"Member"},{pk:"ceylon.language.meta.model",tp:[{mt:"tp",nm:"Type"}],nm:"ClassOrInterface"}]},pa:5,ps:[[{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Object"}],nm:"Type"},mt:"prm",nm:"containerType"},{$t:{pk:"$",tp:[{mt:"tp",pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"typeArguments"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"}],an:{doc:["Applies the given closed container type and type arguments to this member class or interface declaration in order to obtain a \nmember class or interface model. See [this code sample](#member-sample) for an example on how to use this."],throws:["TypeApplicationException","If the specified closed container type or type argument values \nare not compatible with the actual result's container type or \ntype parameters."]},nm:"memberApply"},annotatedMemberDeclarations:{$t:{pk:"$",tp:[{mt:"tp",nm:"Kind"}],nm:"Sequential"},pa:5,mt:"m",tp:[{sts:[{pk:".",nm:"NestableDeclaration"}],nm:"Kind"},{sts:[{pk:"$",nm:"Annotation"}],nm:"Annotation"}],an:{doc:["Returns the list of shared member declarations that satisfy the given `Kind` type argument and\nthat are annotated with the given `Annotation` type argument. This includes inherited\ndeclarations but not unshared declarations."]},nm:"annotatedMemberDeclarations"},apply:{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",nm:"Type"}],nm:"ClassOrInterface"},pa:5,ps:[[{$t:{pk:"$",tp:[{mt:"tp",pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"typeArguments"}]],mt:"m",tp:[{def:{pk:"$",nm:"Anything"},nm:"Type"}],an:{doc:["Applies the given closed type arguments to this toplevel class or interface declaration in order to obtain a class or interface model. \nSee [this code sample](#toplevel-sample) for an example on how to use this."],throws:["TypeApplicationException","If the specified closed type argument values are not compatible \nwith the actual result's type parameters."]},nm:"apply"},annotatedDeclaredMemberDeclarations:{$t:{pk:"$",tp:[{mt:"tp",nm:"Kind"}],nm:"Sequential"},pa:5,mt:"m",tp:[{sts:[{pk:".",nm:"NestableDeclaration"}],nm:"Kind"},{sts:[{pk:"$",nm:"Annotation"}],nm:"Annotation"}],an:{doc:["Returns the list of member declarations directly declared on this class or interface, which satisfy the given \n`Kind` type argument and that are annotated with the given `Annotation` type argument.\nThis includes unshared declarations but not inherited declarations."]},nm:"annotatedDeclaredMemberDeclarations"},memberDeclarations:{$t:{pk:"$",tp:[{mt:"tp",nm:"Kind"}],nm:"Sequential"},pa:5,mt:"m",tp:[{sts:[{pk:".",nm:"NestableDeclaration"}],nm:"Kind"}],an:{doc:["Returns the list of shared member declarations that satisfy the \ngiven `Kind` type argument. \nThis includes inherited declarations but not unshared declarations."]},nm:"memberDeclarations"},declaredMemberDeclarations:{$t:{pk:"$",tp:[{mt:"tp",nm:"Kind"}],nm:"Sequential"},pa:5,mt:"m",tp:[{sts:[{pk:".",nm:"NestableDeclaration"}],nm:"Kind"}],an:{doc:["Returns the list of member declarations directly declared on this class or interface, \nwhich satisfy the given `Kind` type argument. \nThis includes unshared declarations but not inherited declarations."]},nm:"declaredMemberDeclarations"},getDeclaredMemberDeclaration:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{nm:"Kind"}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],mt:"m",tp:[{sts:[{pk:".",nm:"NestableDeclaration"}],nm:"Kind"}],an:{doc:["Looks up a member declaration directly declared on this class or interface, by name, \nprovided it satisfies the given `Kind` type argument. \nReturns `null` if no such member matches. \nThis includes unshared declarations but not inherited declarations."]},nm:"getDeclaredMemberDeclaration"},getMemberDeclaration:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{nm:"Kind"}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],mt:"m",tp:[{sts:[{pk:".",nm:"NestableDeclaration"}],nm:"Kind"}],an:{doc:["Looks up a shared member declaration by name, \nprovided it satisfies the given `Kind` type argument. \nReturns `null` if no such member matches. \nThis includes inherited declarations but not unshared declarations"]},nm:"getMemberDeclaration"}},an:{doc:["A class or interface declaration.\n\n<a name=\"toplevel-sample\"><\/a>\n### Usage sample for toplevel classes\n\nBecause some classes have type parameters, getting a model requires applying type arguments to the\nclass declaration with [[apply]] in order to be able to instantiate that class. For example, here is how you would\nobtain a class or interface model that you can instantiate from a toplevel class declaration:\n\n    class Foo<T>() {\n        string => \"Hello, our T is: ``typeLiteral<T>()``\";\n    }\n    \n    void test(){\n        \/\/ We need to apply the Integer closed type to the Foo declaration in order to get the Foo<Integer> closed type\n        ClassOrInterface<Foo<Integer>> classOrInterfaceModel = `class Foo`.apply<Foo<Integer>>(`Integer`);\n        assert(is Class<Foo<Integer>,[]> classOrInterfaceModel);\n        \/\/ This will print: Hello, our T is: ceylon.language::Integer\n        print(classOrInterfaceModel());\n    }\n\nNote that there are more specialised versions of [[apply]] in [[ClassDeclaration.classApply]] and \n[[InterfaceDeclaration.interfaceApply]].\n\n<a name=\"member-sample\"><\/a>\n### Usage sample for member classes\n\nFor member classes or interfaces it is a bit longer, because member types need to be applied not only their type arguments but also\nthe containing type, so you should use [[memberApply]] and start by giving the containing closed type:\n\n    class Outer(){\n        shared class Inner(){\n            string => \"Hello\";\n        }\n    }\n\n    void test(){\n        \/\/ apply the containing closed type `Outer` to the member class declaration `Outer.Inner`\n        value memberClassModel = `class Outer.Inner`.memberApply<Outer,Outer.Inner>(`Outer`);\n        assert(is MemberClass<Outer,Outer.Inner,[]> memberClassModel);\n        \/\/ We now have a MemberClass, which needs to be applied to a containing instance in order to become an\n        \/\/ invokable class model:\n        Class<Outer.Inner,[]> boundMemberClassModel = memberClassModel(Outer());\n        \/\/ This will print: Hello\n        print(boundMemberClassModel());\n    }\n\nNote that there are more specialised versions of [[memberApply]] in [[ClassDeclaration.memberClassApply]] and \n[[InterfaceDeclaration.memberInterfaceApply]].\n"]},nm:"ClassOrInterfaceDeclaration"},OpenClassType:{pa:17,sts:[{pk:".",nm:"OpenClassOrInterfaceType"}],mt:"i",$at:{declaration:{$t:{pk:".",nm:"ClassDeclaration"},pa:7,mt:"a",an:{doc:["This class declaration."]},nm:"declaration"}},an:{doc:["An open class type."]},nm:"OpenClassType"},ValueDeclaration:{pa:17,sts:[{pk:".",nm:"FunctionOrValueDeclaration"},{pk:".",nm:"NestableDeclaration"},{pk:".",nm:"GettableDeclaration"}],mt:"i",$at:{late:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this declaration is annotated with [[late|ceylon.language::late]]."]},nm:"late"},variable:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this declaration is annotated with [[variable|ceylon.language::variable]]."]},nm:"variable"},objectClass:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"ClassDeclaration"}]},pa:5,mt:"a",an:{doc:["This value's anonymous class declaration if this value is an object declaration. `null` otherwise."]},nm:"objectClass"},objectValue:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this declaration is an `object` declaration, whose type is an anonymous class."]},nm:"objectValue"},setter:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"SetterDeclaration"}]},pa:5,mt:"a",an:{doc:["Returns the setter declaration for this variable if there is one, `null` otherwise."]},nm:"setter"}},$m:{memberApply:{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Get"},{mt:"tp",nm:"Set"}],nm:"Attribute"},pa:5,ps:[[{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Object"}],nm:"Type"},mt:"prm",nm:"containerType"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Get"},{def:{pk:".",nm:"Nothing"},nm:"Set"}],an:{doc:["Applies the given closed container type to this attribute declaration in order to obtain an attribute model. \nSee [this code sample](#member-sample) for an example on how to use this."],throws:["IncompatibleTypeException","If the specified `Container`, `Get` or `Set` type arguments are not compatible with the actual result."]},nm:"memberApply"},set:{$t:{pk:"$",nm:"Anything"},pa:9,ps:[[{$t:{pk:"$",nm:"Anything"},mt:"prm",nm:"newValue"}]],$ff:1,mt:"m",an:{doc:["Sets the current value of this toplevel value."]},nm:"set"},apply:{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",nm:"Get"},{mt:"tp",nm:"Set"}],nm:"Value"},pa:5,mt:"m",tp:[{def:{pk:"$",nm:"Anything"},nm:"Get"},{def:{pk:".",nm:"Nothing"},nm:"Set"}],an:{doc:["Applies this value declaration in order to obtain a value model. \nSee [this code sample](#toplevel-sample) for an example on how to use this."],throws:["IncompatibleTypeException","If the specified `Get` or `Set` type arguments are not compatible with the actual result."]},nm:"apply"},get:{$t:{pk:"$",nm:"Anything"},pa:11,mt:"m",an:{doc:["Reads the current value of this toplevel value."]},nm:"get"},memberSet:{$t:{pk:"$",nm:"Anything"},pa:5,ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"container"},{$t:{pk:"$",nm:"Anything"},mt:"prm",nm:"newValue"}]],$ff:1,mt:"m",an:{doc:["Sets the current value of this attribute on the given container instance."],throws:["StorageException","If this attribute is not stored at runtime, for example if it is neither shared nor captured."]},nm:"memberSet"},memberGet:{$t:{pk:"$",nm:"Anything"},pa:11,ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"container"}]],mt:"m",an:{doc:["Reads the current value of this attribute on the given container instance."],throws:["StorageException","If this attribute is not stored at runtime, for example if it is neither shared nor captured."]},nm:"memberGet"}},an:{doc:["A value declaration.\n\n<a name=\"toplevel-sample\"><\/a>\n### Usage sample for toplevel value\n\nGetting a model requires applying type arguments to the\nvalue declaration with [[apply]] in order to be able to read that value. For example, here is how you would\nobtain a value model that you can read from a toplevel attribute declaration:\n\n    String foo = \"Hello\";\n    \n    void test(){\n        \/\/ We need to apply the the foo declaration in order to get the foo value model\n        Value<String> valueModel = `value foo`.apply<String>();\n        \/\/ This will print: Hello\n        print(valueModel.get());\n    }\n\n<a name=\"member-sample\"><\/a>\n### Usage sample for attributes\n\nFor attributes it is a bit longer, because attributes need to be applied the containing type, so you should \nuse [[memberApply]] and start by giving the containing closed type:\n\n    class Outer(){\n        shared String foo => \"Hello\";\n    }\n\n    void test(){\n        \/\/ Apply the containing closed type `Outer` to the attribute declaration `Outer.foo`\n        Attribute<Outer,String> valueModel = `value Outer.foo`.memberApply<Outer,String>(`Outer`);\n        \/\/ We now have an Attribute, which needs to be applied to a containing instance in order to become a\n        \/\/ readable value:\n        Value<String> boundValueModel = valueModel(Outer());\n        \/\/ This will print: Hello\n        print(boundValueModel.get());\n    }\n"]},nm:"ValueDeclaration"},OpenUnion:{pa:17,sts:[{pk:".",nm:"OpenType"}],mt:"i",$at:{caseTypes:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"OpenType"}],nm:"List"},pa:5,mt:"a",an:{doc:["The list of case types for this open union type."]},nm:"caseTypes"}},an:{doc:["An open union type."]},nm:"OpenUnion"},InterfaceDeclaration:{pa:17,sts:[{pk:".",nm:"ClassOrInterfaceDeclaration"}],mt:"i",$m:{interfaceApply:{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",nm:"Type"}],nm:"Interface"},pa:5,ps:[[{$t:{pk:"$",tp:[{mt:"tp",pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"typeArguments"}]],mt:"m",tp:[{def:{pk:"$",nm:"Anything"},nm:"Type"}],an:{doc:["Applies the given closed type arguments to this toplevel interface \ndeclaration in order to obtain an interface model. \nSee [this code sample](#toplevel-sample) for an example on how to use this."],throws:["TypeApplicationException","If the specified closed type argument values are not compatible \nwith the actual result's type parameters."]},nm:"interfaceApply"},memberInterfaceApply:{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"}],nm:"MemberInterface"},pa:5,ps:[[{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Object"}],nm:"Type"},mt:"prm",nm:"containerType"},{$t:{pk:"$",tp:[{mt:"tp",pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"typeArguments"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"}],an:{doc:["Applies the given closed container type and type arguments to this member \ninterface declaration in order to obtain a member interface model. \nSee [this code sample](#member-sample) for an example on how to use this."],throws:["TypeApplicationException","If the specified closed container type or type argument values \nare not compatible with the actual result's container type or \ntype parameters."]},nm:"memberInterfaceApply"}},an:{doc:["An interface declaration.\n\n<a name=\"toplevel-sample\"><\/a>\n### Usage sample for toplevel interfaces\n\nBecause some interfaces have type parameters, getting a model requires applying type arguments to the\ninterface declaration with [[interfaceApply]] in order to be able to get a closed type. For example, here is how you would\nobtain an interface model from a toplevel interface declaration:\n\n    interface Foo<T> satisfies List<T> {\n    }\n    \n    void test(){\n        \/\/ We need to apply the Integer closed type to the Foo declaration in order to get the Foo<Integer> closed type\n        Interface<Foo<Integer>> interfaceModel = `interface Foo`.interfaceApply<Foo<Integer>>(`Integer`);\n        \/\/ This will print: ceylon.language::List<ceylon.language::Integer>\n        for(satisfiedType in interfaceModel.satisfiedTypes){\n            print(satisfiedType);\n        }\n    }\n\n<a name=\"member-sample\"><\/a>\n### Usage sample for member interfaces\n\nFor member interfaces it is a bit longer, because member interfaces need to be applied not only their type arguments but also\nthe containing type, so you should use [[memberInterfaceApply]] and start by giving the containing closed type:\n\n    class Outer(){\n        shared interface Inner<T> satisfies List<T> {\n        }\n    }\n\n    void test(){\n        \/\/ apply the containing closed type `Outer` to the member class declaration `Outer.Inner`\n        MemberInterface<Outer,Outer.Inner<Integer>> memberInterfaceModel = `interface Outer.Inner`.memberInterfaceApply<Outer,Outer.Inner<Integer>>(`Outer`, `Integer`);\n        \/\/ This will print: ceylon.language::List<ceylon.language::Integer>\n        for(satisfiedType in memberInterfaceModel.satisfiedTypes){\n            print(satisfiedType);\n        }\n    }\n"]},nm:"InterfaceDeclaration"},GettableDeclaration:{pa:17,mt:"i",$m:{get:{$t:{pk:"$",nm:"Anything"},pa:5,mt:"m",an:{doc:["Reads the current value of this toplevel value."]},nm:"get"},memberGet:{$t:{pk:"$",nm:"Anything"},pa:5,ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"container"}]],mt:"m",an:{doc:["Reads the current value of this attribute on the given container instance."],throws:["StorageException","If this attribute is not stored at runtime, for example if it is neither shared nor captured."]},nm:"memberGet"}},an:{doc:["Abstraction over declarations from which a value can be obtained, namely\n\n* [[ValueDeclaration]] which abstracts over values and attributes \n* [[ValueConstructorDeclaration]] which represents value constructors"]},nm:"GettableDeclaration"},FunctionOrValueDeclaration:{pa:17,sts:[{pk:".",nm:"NestableDeclaration"}],mt:"i",of:[{pk:".",nm:"FunctionDeclaration"},{pk:".",nm:"ValueDeclaration"}],$at:{parameter:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this function or value is a parameter to a [[FunctionalDeclaration]]."]},nm:"parameter"},defaulted:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this function or value is a parameter and has a default value."]},nm:"defaulted"},variadic:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this function or value is a parameter and is variadic (accepts a list of values)."]},nm:"variadic"}},an:{doc:["A function or value declaration."]},nm:"FunctionOrValueDeclaration"},OpenTypeArgument:{pa:1,$alias:{pk:"$",l:[{pk:".",nm:"OpenType"},{pk:".",nm:"Variance"}],nm:"Tuple"},mt:"als",an:{doc:["A tuple representing an open type argument and its use-site variance."]},nm:"OpenTypeArgument"},Variance:{pa:1,mt:"i",of:[{pk:".",nm:"invariant"},{pk:".",nm:"covariant"},{pk:".",nm:"contravariant"}],an:{doc:["Variance information."]},nm:"Variance"},NestableDeclaration:{pa:17,sts:[{pk:".",nm:"AnnotatedDeclaration"},{pk:".",nm:"TypedDeclaration"}],mt:"i",of:[{pk:".",nm:"FunctionOrValueDeclaration"},{pk:".",nm:"ClassOrInterfaceDeclaration"},{pk:".",nm:"ConstructorDeclaration"},{pk:".",nm:"SetterDeclaration"},{pk:".",nm:"AliasDeclaration"}],$at:{formal:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this declaration is annotated with [[formal|ceylon.language::formal]]."]},nm:"formal"},container:{$t:{comp:"u",l:[{pk:".",nm:"NestableDeclaration"},{pk:".",nm:"Package"}]},pa:5,mt:"a",an:{doc:["This declaration's immediate container, which can be either a [[NestableDeclaration]]\nor a [[Package]]."]},nm:"container"},actual:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this declaration is annotated with [[actual|ceylon.language::actual]]."]},nm:"actual"},shared:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this declaration is annotated with [[shared|ceylon.language::shared]]."]},nm:"shared"},default:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this declaration is annotated with [[default|ceylon.language::default]]."]},nm:"default"},containingModule:{$t:{pk:".",nm:"Module"},pa:5,mt:"a",an:{doc:["This declaration's module container."]},nm:"containingModule"},toplevel:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this declaration is a toplevel declaration."]},nm:"toplevel"},containingPackage:{$t:{pk:".",nm:"Package"},pa:5,mt:"a",an:{doc:["This declaration's package container."]},nm:"containingPackage"}},an:{doc:["A declaration which can be contained in a [[Package]] or in another [[NestableDeclaration]].\n\nFunctions, values, classes, interfaces and aliases are such declarations."]},nm:"NestableDeclaration"},FunctionDeclaration:{pa:17,sts:[{pk:".",nm:"FunctionOrValueDeclaration"},{pk:".",nm:"FunctionalDeclaration"}],mt:"i",$m:{memberApply:{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Return"},{mt:"tp",nm:"Arguments"}],nm:"Method"},pa:7,ps:[[{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Object"}],nm:"Type"},mt:"prm",nm:"containerType"},{$t:{pk:"$",tp:[{mt:"tp",pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"typeArguments"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Return"},{sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],nm:"memberApply"},apply:{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",nm:"Return"},{mt:"tp",nm:"Arguments"}],nm:"Function"},pa:7,ps:[[{$t:{pk:"$",tp:[{mt:"tp",pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"typeArguments"}]],mt:"m",tp:[{def:{pk:"$",nm:"Anything"},nm:"Return"},{sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],nm:"apply"}},an:{doc:["Abstraction over declarations which can be invoked, namely functions, methods and constructors "]},nm:"FunctionDeclaration"},OpenTypeVariable:{pa:17,sts:[{pk:".",nm:"OpenType"}],mt:"i",$at:{declaration:{$t:{pk:".",nm:"TypeParameter"},pa:5,mt:"a",an:{doc:["This type variable's type parameter declaration."]},nm:"declaration"}},an:{doc:["An open type variable."]},nm:"OpenTypeVariable"},AnnotatedDeclaration:{pa:17,sts:[{pk:".",nm:"Declaration"},{pk:"$",nm:"Annotated"}],mt:"i",of:[{pk:".",nm:"NestableDeclaration"},{pk:".",nm:"Module"},{pk:".",nm:"Package"}],$m:{annotations:{$t:{pk:"$",tp:[{mt:"tp",nm:"Annotation"}],nm:"Sequential"},pa:5,mt:"m",tp:[{dv:"out",sts:[{pk:"$",nm:"Annotation"}],nm:"Annotation"}],an:{doc:["The annotation instances of the given \nannotation type on this declaration.\n\nFor example, you can list all the [[SeeAnnotations|ceylon.language::SeeAnnotation]] \nannotations on [[List|ceylon.language::List]]\nwith the following code:\n\n    for(annot in `interface List`.annotations<SeeAnnotation>()){\n        for(elems in annot.programElements){\n            print(\"See: ``elems``\");\n        }\n    }\n\nAlternatively, you can use the [[ceylon.language.meta::annotations]] \nfunction.\n"]},nm:"annotations"}},an:{doc:["Declaration which can be annotated, such as:\n\n- [[NestableDeclaration]]\n- [[Module]]\n- [[Package]]\n\nYou can query annotations that are placed on a given annotated declaration with:\n\n"]},nm:"AnnotatedDeclaration"},ConstructorDeclaration:{pa:1,sts:[{pk:".",nm:"NestableDeclaration"}],mt:"i",of:[{pk:".",nm:"CallableConstructorDeclaration"},{pk:".",nm:"ValueConstructorDeclaration"}],an:{doc:["Abstraction over [[callable constructors|CallableConstructorDeclaration]]\nand [[value constructors|ValueConstructorDeclaration]]"]},nm:"ConstructorDeclaration"},ClassWithInitializerDeclaration:{pa:17,sts:[{pk:".",nm:"ClassDeclaration"}],mt:"i",$at:{defaultConstructor:{$t:{pk:".",nm:"CallableConstructorDeclaration"},pa:7,mt:"a",an:{doc:["A CallableConstructorDeclaration representing the class initializer."]},nm:"defaultConstructor"},parameterDeclarations:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"FunctionOrValueDeclaration"}],nm:"Sequential"},pa:7,mt:"a",an:{doc:["The list of parameter declarations for this class."]},nm:"parameterDeclarations"}},$m:{annotatedConstructorDeclarations:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"CallableConstructorDeclaration"}],nm:"Sequential"},pa:7,mt:"m",tp:[{sts:[{pk:"$",nm:"Annotation"}],nm:"Annotation"}],nm:"annotatedConstructorDeclarations"},constructorDeclarations:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"CallableConstructorDeclaration"}],nm:"Sequence"},pa:11,mt:"m",an:{doc:["A singleton sequence containing the [[defaultConstructor]]."]},nm:"constructorDeclarations"},getConstructorDeclaration:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"CallableConstructorDeclaration"}]},pa:11,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],mt:"m",nm:"getConstructorDeclaration"}},an:{see:["ClassWithConstructorsDeclaration"],doc:["The declaration model of a class that has a parameter list rather than\nexplicit constructors. For example:\n\n    class Color(Integer rgba) {\n    }\n\nSuch classes have a meaningful parameter list and for abstraction purposes\nhave a single [[defaultConstructor]] representing the\nclass' parameter list and the class initializer code.\nThis \"constructor\" will have the same \n[[SharedAnnotation]], [[DeprecationAnnotation]] \nand [[ThrownExceptionAnnotation]]\nannotations as the class, but will have no \nother annotations.\n"]},nm:"ClassWithInitializerDeclaration"},Declaration:{pa:17,mt:"i",of:[{pk:".",nm:"AnnotatedDeclaration"},{pk:".",nm:"TypeParameter"}],$at:{qualifiedName:{$t:{pk:"$",nm:"String"},pa:5,mt:"a",an:{doc:["The qualified name of this declaration. This includes the container qualified name. For\nexample, the [[Declaration]] class' qualified name is \"ceylon.language.meta.declaration::Declaration\"."]},nm:"qualifiedName"},name:{$t:{pk:"$",nm:"String"},pa:5,mt:"a",an:{doc:["The name of this declaration. For example, the [[Declaration]] class is named \"Declaration\"."]},nm:"name"}},an:{doc:["A declaration.\n\nThere are only two types of declarations:\n\n- [[AnnotatedDeclaration]]s such as modules, packages, classes or functions, and\n- [[TypeParameter]] declarations."]},nm:"Declaration"},TypedDeclaration:{pa:17,mt:"i",$at:{openType:{$t:{pk:".",nm:"OpenType"},pa:5,mt:"a",an:{doc:["The open type for this declaration. For example, the open type for `List<T> f<T>()` is `List<T>`."]},nm:"openType"}},an:{doc:["Declaration which has an open type."]},nm:"TypedDeclaration"},contravariant:{super:{pk:"$",nm:"Basic"},pa:1,sts:[{pk:".",nm:"Variance"}],mt:"o",$at:{string:{$t:{pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"}},an:{doc:["Contravariant means that supertypes of the given type may be accepted."]},nm:"contravariant"},"$pkg-pa":1,CallableConstructorDeclaration:{pa:17,sts:[{pk:".",nm:"FunctionalDeclaration"},{pk:".",nm:"ConstructorDeclaration"}],mt:"i",$at:{container:{$t:{pk:".",nm:"ClassDeclaration"},pa:7,mt:"a",an:{doc:["The class this constructor constructs"]},nm:"container"},defaultConstructor:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["Whether this is the default constructor. The default constructor of a class is the constructor with no name."]},nm:"defaultConstructor"},abstract:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if the constructor has an [[abstract|ceylon.language::abstract]] annotation."]},nm:"abstract"}},$m:{memberApply:{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Result"},{mt:"tp",nm:"Arguments"}],nm:"MemberClassCallableConstructor"},pa:7,ps:[[{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Object"}],nm:"Type"},mt:"prm",nm:"containerType"},{$t:{pk:"$",tp:[{mt:"tp",pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"typeArguments"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Object"},nm:"Result"},{sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{doc:["Applies the given closed type arguments to the declaration of the member class \nenclosing this constructor declaration, returning a method model \nfor the constructor"]},nm:"memberApply"},apply:{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",nm:"Result"},{mt:"tp",nm:"Arguments"}],nm:"CallableConstructor"},pa:7,ps:[[{$t:{pk:"$",tp:[{mt:"tp",pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"typeArguments"}]],mt:"m",tp:[{def:{pk:"$",nm:"Object"},nm:"Result"},{sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{doc:["Applies the given closed type arguments to the declaration of the class \nenclosing this constructor declaration, returning a function model \nfor the constructor"]},nm:"apply"},invoke:{$t:{pk:"$",nm:"Object"},pa:7,ps:[[{$t:{pk:"$",tp:[{mt:"tp",pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},def:1,mt:"prm",nm:"typeArguments"},{$t:{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"},mt:"prm",seq:1,nm:"arguments"}]],mt:"m",nm:"invoke"},memberInvoke:{$t:{pk:"$",nm:"Object"},pa:7,ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"container"},{$t:{pk:"$",tp:[{mt:"tp",pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},def:1,mt:"prm",nm:"typeArguments"},{$t:{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"},mt:"prm",seq:1,nm:"arguments"}]],mt:"m",nm:"memberInvoke"}},an:{see:["ValueConstructorDeclaration"],doc:["Declaration model for callable constructors, for example\n\n    class WithConstructors {\n        shared new () {}\n        shared new clone(WithConstructors other) {}\n    \n    \/\/ ...\n    \n    CallableConstructorDeclaration default = `new WithConstructors`;\n    CallableConstructorDeclaration clone = `new WithConstructors.clone`;\n    \nThe initializer of a class with a parameter list can also be \n[[represented|ClassWithInitializerDeclaration.defaultConstructor]] \nas a `CallableConstructorDeclaration`."]},nm:"CallableConstructorDeclaration"},FunctionalDeclaration:{pa:17,sts:[{pk:".",nm:"GenericDeclaration"}],mt:"i",$at:{annotation:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if the current declaration is an annotation class or function."]},nm:"annotation"},parameterDeclarations:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"FunctionOrValueDeclaration"}],nm:"Sequential"},pa:5,mt:"a",an:{doc:["The list of parameter declarations for this functional declaration."]},nm:"parameterDeclarations"}},$m:{getParameterDeclaration:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"FunctionOrValueDeclaration"}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],mt:"m",an:{doc:["Gets a parameter declaration by name. Returns `null` if no such parameter exists."]},nm:"getParameterDeclaration"},memberApply:{$t:{comp:"i",l:[{pk:"ceylon.language.meta.model",tp:[{mt:"tp",nm:"Return"},{mt:"tp",nm:"Arguments"}],nm:"FunctionModel"},{pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"ceylon.language.meta.model",tp:[{mt:"tp",nm:"Return"},{mt:"tp",nm:"Arguments"}],nm:"FunctionModel"},{mt:"tp",nm:"Container"}],nm:"Qualified"}]},pa:5,ps:[[{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Object"}],nm:"Type"},mt:"prm",nm:"containerType"},{$t:{pk:"$",tp:[{mt:"tp",pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"typeArguments"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Return"},{sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{doc:["Applies the given closed container type and type arguments to this method declaration in order to obtain a method model. \nSee [this code sample](#member-sample) for an example on how to use this."],throws:["TypeApplicationException","If the specified closed container type or type argument values are not compatible with the actual result's container type or type parameters."]},nm:"memberApply"},apply:{$t:{comp:"i",l:[{pk:"ceylon.language.meta.model",tp:[{mt:"tp",nm:"Return"},{mt:"tp",nm:"Arguments"}],nm:"FunctionModel"},{pk:"ceylon.language.meta.model",tp:[{mt:"tp",nm:"Return"},{mt:"tp",nm:"Arguments"}],nm:"Applicable"}]},pa:5,ps:[[{$t:{pk:"$",tp:[{mt:"tp",pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"typeArguments"}]],mt:"m",tp:[{def:{pk:"$",nm:"Anything"},nm:"Return"},{sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{doc:["Applies the given closed type arguments to this function declaration in order to obtain a function model. \nSee [this code sample](#toplevel-sample) for an example on how to use this."],throws:["TypeApplicationException","If the specified closed type argument values are not compatible with the actual result's type parameters."]},nm:"apply"},invoke:{$t:{pk:"$",nm:"Anything"},pa:9,ps:[[{$t:{pk:"$",tp:[{mt:"tp",pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},def:1,mt:"prm",nm:"typeArguments"},{$t:{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"},mt:"prm",seq:1,nm:"arguments"}]],mt:"m",an:{doc:["Invokes the underlying toplevel function, by applying the specified type arguments and value arguments."],throws:["IncompatibleTypeException","If the specified type or value arguments are not compatible with this toplevel function."]},nm:"invoke"},memberInvoke:{$t:{pk:"$",nm:"Anything"},pa:5,ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"container"},{$t:{pk:"$",tp:[{mt:"tp",pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},def:1,mt:"prm",nm:"typeArguments"},{$t:{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"},mt:"prm",seq:1,nm:"arguments"}]],mt:"m",an:{doc:["Invokes the underlying method, by applying the specified type arguments and value arguments."],throws:["IncompatibleTypeException","If the specified container, type or value arguments are not compatible with this method."]},nm:"memberInvoke"}},an:{doc:["A function declaration.\n\n<a name=\"toplevel-sample\"><\/a>\n### Usage sample for toplevel function\n\nBecause some functions have type parameters, getting a model requires applying type arguments to the\nfunction declaration with [[apply]] in order to be able to invoke that function. For example, here is how you would\nobtain a function model that you can invoke from a toplevel function declaration:\n\n    String foo<T>(){\n        return \"Hello, our T is: ``typeLiteral<T>()``\";\n    }\n    \n    void test(){\n        \/\/ We need to apply the Integer closed type to the foo declaration in order to get the foo<Integer> function model\n        Function<String,[]> functionModel = `function foo`.apply<String,[]>(`Integer`);\n        \/\/ This will print: Hello, our T is: ceylon.language::Integer\n        print(functionModel());\n    }\n\n<a name=\"member-sample\"><\/a>\n### Usage sample for methods\n\nFor methods it is a bit longer, because methods need to be applied not only their type arguments but also\nthe containing type, so you should use [[memberApply]] and start by giving the containing closed type:\n\n    class Outer(){\n        shared String hello() => \"Hello\";\n    }\n\n    void test(){\n        \/\/ apply the containing closed type `Outer` to the method declaration `Outer.hello`\n        Method<Outer,String,[]> methodModel = `function Outer.hello`.memberApply<Outer,String,[]>(`Outer`);\n        \/\/ We now have a Method, which needs to be applied to a containing instance in order to become an\n        \/\/ invokable function:\n        Function<String,[]> boundMethodModel = methodModel(Outer());\n        \/\/ This will print: Hello\n        print(boundMethodModel());\n    }\n"]},nm:"FunctionalDeclaration"},OpenIntersection:{pa:17,sts:[{pk:".",nm:"OpenType"}],mt:"i",$at:{satisfiedTypes:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"OpenType"}],nm:"List"},pa:5,mt:"a",an:{doc:["This intersection's list of satisfied open types."]},nm:"satisfiedTypes"}},an:{doc:["An open intersection type."]},nm:"OpenIntersection"},GenericDeclaration:{pa:17,mt:"i",$at:{typeParameterDeclarations:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"TypeParameter"}],nm:"Sequential"},pa:5,mt:"a",an:{doc:["The list of type parameters declared on this generic declaration."]},nm:"typeParameterDeclarations"}},$m:{getTypeParameterDeclaration:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"TypeParameter"}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],mt:"m",an:{doc:["Finds a type parameter by name. Returns `null` if not found."]},nm:"getTypeParameterDeclaration"}},an:{doc:["A declaration that can have type parameters."]},nm:"GenericDeclaration"},AliasDeclaration:{pa:17,sts:[{pk:".",nm:"NestableDeclaration"},{pk:".",nm:"GenericDeclaration"}],mt:"i",$at:{extendedType:{$t:{pk:".",nm:"OpenType"},pa:5,mt:"a",an:{doc:["The open type that is substituted by this type alias."]},nm:"extendedType"}},an:{doc:["Type alias declaration. While type aliases are erased (substituted for what they alias is a better term) from every \ndeclaration that uses them during compile-time, the declaration of the type alias is still visible at run-time."]},nm:"AliasDeclaration"},invariant:{super:{pk:"$",nm:"Basic"},pa:1,sts:[{pk:".",nm:"Variance"}],mt:"o",$at:{string:{$t:{pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"}},an:{doc:["Invariant means that neither subtype nor supertype can be accepted, the\ntype has to be exactly that which is declared."]},nm:"invariant"},covariant:{super:{pk:"$",nm:"Basic"},pa:1,sts:[{pk:".",nm:"Variance"}],mt:"o",$at:{string:{$t:{pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"}},an:{doc:["Covariant means that subtypes of the given type may be returned."]},nm:"covariant"},OpenInterfaceType:{pa:17,sts:[{pk:".",nm:"OpenClassOrInterfaceType"}],mt:"i",$at:{declaration:{$t:{pk:".",nm:"InterfaceDeclaration"},pa:7,mt:"a",an:{doc:["This declaration's package container."]},nm:"declaration"}},an:{doc:["An open interface type."]},nm:"OpenInterfaceType"},ClassDeclaration:{pa:17,sts:[{pk:".",nm:"ClassOrInterfaceDeclaration"}],mt:"i",of:[{pk:".",nm:"ClassWithInitializerDeclaration"},{pk:".",nm:"ClassWithConstructorsDeclaration"}],$at:{annotation:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if the current declaration is an annotation class or function."]},nm:"annotation"},defaultConstructor:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"CallableConstructorDeclaration"}]},pa:5,mt:"a",an:{doc:["A constructor declaration representing the class initializer \n(for a class with a parameter list) or\nthe default constructor, or null if the class lacks \nboth a parameter list and a default constructor."]},nm:"defaultConstructor"},final:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if the class has a [[final|ceylon.language::final]] annotation."]},nm:"final"},anonymous:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if the class is an anonymous class, as is the case for the class of object value declarations."]},nm:"anonymous"},objectValue:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"ValueDeclaration"}]},pa:5,mt:"a",an:{doc:["This anonymous class' object value declaration if this class is an anonymous class. `null` otherwise."]},nm:"objectValue"},abstract:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if the class has an [[abstract|ceylon.language::abstract]] annotation."]},nm:"abstract"},serializable:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if the class is serializable class."]},nm:"serializable"},parameterDeclarations:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:"$",tp:[{mt:"tp",pk:".",nm:"FunctionOrValueDeclaration"}],nm:"Sequential"}]},pa:5,mt:"a",an:{doc:["The list of parameter declarations for this class. \nReturns `null` if the class lacks both a parameter list and a \ndefault constructor."]},nm:"parameterDeclarations"}},$m:{getParameterDeclaration:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"FunctionOrValueDeclaration"}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],mt:"m",an:{doc:["Gets a parameter declaration by name. \nReturns `null` if this class lacks both a parameter list and a \ndefault constructor, \nor if no such parameter exists in the parameter list."]},nm:"getParameterDeclaration"},memberInstantiate:{$t:{pk:"$",nm:"Object"},pa:9,ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"container"},{$t:{pk:"$",tp:[{mt:"tp",pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},def:1,mt:"prm",nm:"typeArguments"},{$t:{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"},mt:"prm",seq:1,nm:"arguments"}]],mt:"m",an:{doc:["Creates a new instance of this member class, by applying the specified \ntype arguments and value arguments."],throws:["IncompatibleTypeException","If the specified container, type or value arguments are not \ncompatible with this method, or if the class lacks both a parameter list\nand a default constructor."]},nm:"memberInstantiate"},annotatedConstructorDeclarations:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"ConstructorDeclaration"}],nm:"Sequential"},pa:5,mt:"m",tp:[{sts:[{pk:"$",nm:"Annotation"}],nm:"Annotation"}],an:{doc:["Returns the list of constructors declared on this class that are annotated with the \ngiven `Annotation` type argument. This includes unshared constructors."]},nm:"annotatedConstructorDeclarations"},classApply:{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"Class"},pa:5,ps:[[{$t:{pk:"$",tp:[{mt:"tp",pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"typeArguments"}]],mt:"m",tp:[{def:{pk:"$",nm:"Anything"},nm:"Type"},{sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{doc:["Applies the given closed type arguments to this toplevel class declaration in order to obtain a class model. \nSee [this code sample](#toplevel-sample) for an example on how to use this."],throws:["TypeApplicationException","If the specified closed type argument values are not compatible \nwith the actual result's type parameters."]},nm:"classApply"},constructorDeclarations:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"ConstructorDeclaration"}],nm:"Sequential"},pa:5,mt:"m",an:{doc:["Returns the list of constructors declared on this class. This includes unshared constructors."]},nm:"constructorDeclarations"},memberClassApply:{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"MemberClass"},pa:5,ps:[[{$t:{pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Object"}],nm:"Type"},mt:"prm",nm:"containerType"},{$t:{pk:"$",tp:[{mt:"tp",pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"typeArguments"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"},{sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{doc:["Applies the given closed container type and type arguments to this member class declaration in order to obtain a member class model. \nSee [this code sample](#member-sample) for an example on how to use this."],throws:["TypeApplicationException","If the specified closed container type or type argument values \nare not compatible with the actual result's container type or \ntype parameters."]},nm:"memberClassApply"},instantiate:{$t:{pk:"$",nm:"Object"},pa:9,ps:[[{$t:{pk:"$",tp:[{mt:"tp",pk:"ceylon.language.meta.model",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},def:1,mt:"prm",nm:"typeArguments"},{$t:{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"},mt:"prm",seq:1,nm:"arguments"}]],mt:"m",an:{doc:["Creates a new instance of this toplevel class, \nby applying the specified type arguments and value arguments."],throws:["IncompatibleTypeException","If the specified type or value arguments are not compatible with \nthis toplevel class, or if the class lacks both a parameter list\nand a default constructor."]},nm:"instantiate"},getConstructorDeclaration:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{comp:"u",l:[{pk:".",nm:"CallableConstructorDeclaration"},{pk:".",nm:"ValueConstructorDeclaration"}]}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],mt:"m",an:{doc:["Looks up a constructor declaration directly declared on this class, by name. \nReturns `null` if no such constructor matches. \nThis includes unshared constructors but not inherited constructors \n(since constructors are not members)."]},nm:"getConstructorDeclaration"}},an:{doc:["Class declaration.\n\n### Callable classes\n\nSince Ceylon 1.2 classes are not always directly invokable\n(if the class has constructors, but not a default constructor). Thus\nmembers of `ClassDeclaration` which depend on the class parameter \nlist typically have optional type, but are refined on \n[[ClassWithInitializerDeclaration]] to be non-optional. The exceptions to \nthis are [[instantiate]] and [[memberInstantiate]], \nwhich throw exceptions.\n\n<a name=\"toplevel-sample\"><\/a>\n### Usage sample for toplevel classes\n\nBecause some classes have type parameters, getting a model requires applying type arguments to the\nclass declaration with [[classApply]] in order to be able to instantiate that class. For example, here is how you would\nobtain a class model that you can instantiate from a toplevel class declaration:\n\n    class Foo<T>(){\n        string => \"Hello, our T is: ``typeLiteral<T>()``\";\n    }\n    \n    void test(){\n        \/\/ We need to apply the Integer closed type to the Foo declaration in order to get the Foo<Integer> closed type\n        Class<Foo<Integer>,[]> classModel = `class Foo`.classApply<Foo<Integer>,[]>(`Integer`);\n        \/\/ This will print: Hello, our T is: ceylon.language::Integer\n        print(classModel());\n    }\n\n<a name=\"member-sample\"><\/a>\n### Usage sample for member classes\n\nFor member classes it is a bit longer, because member classes need to be applied not only their type arguments but also\nthe containing type, so you should use [[memberClassApply]] and start by giving the containing closed type:\n\n    class Outer(){\n        shared class Inner(){\n            string => \"Hello\";\n        }\n    }\n\n    void test(){\n        \/\/ apply the containing closed type `Outer` to the member class declaration `Outer.Inner`\n        MemberClass<Outer,Outer.Inner,[]> memberClassModel = `class Outer.Inner`.memberClassApply<Outer,Outer.Inner,[]>(`Outer`);\n        \/\/ We now have a MemberClass, which needs to be applied to a containing instance in order to become an\n        \/\/ invokable class model:\n        Class<Outer.Inner,[]> boundMemberClassModel = memberClassModel(Outer());\n        \/\/ This will print: Hello\n        print(boundMemberClassModel());\n    }\n"]},nm:"ClassDeclaration"},nothingType:{super:{pk:"$",nm:"Basic"},pa:1,sts:[{pk:".",nm:"OpenType"}],mt:"o",$at:{string:{$t:{pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"}},an:{doc:["The singleton open type for [[Nothing|ceylon.language::nothing]]."]},nm:"nothingType"},ClassWithConstructorsDeclaration:{pa:17,sts:[{pk:".",nm:"ClassDeclaration"}],mt:"i",an:{see:["ClassWithInitializerDeclaration"],doc:["The declaration model of a class that has constructors. For example:\n\n    class Point {\n        shared new(Float x, Float y) {\n            \/\/ ...\n        }\n        shared new polar(Float r, Float theta) {\n            \/\/ ...\n        }\n        shared new origin {\n            \/\/ ...\n        }\n    }\n    \nSuch classes may not have a default (unnamed) constructor,\nso [[defaultConstructor|ClassDeclaration.defaultConstructor]] \nhas optional type.\n"]},nm:"ClassWithConstructorsDeclaration"},Package:{pa:17,sts:[{pk:"$",nm:"Identifiable"},{pk:".",nm:"AnnotatedDeclaration"}],mt:"i",$at:{container:{$t:{pk:".",nm:"Module"},pa:5,mt:"a",an:{doc:["The module this package belongs to."]},nm:"container"},shared:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this package is shared."]},nm:"shared"}},$m:{getValue:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"ValueDeclaration"}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],mt:"m",an:{doc:["The value with the given name. Returns `null` if not found."]},nm:"getValue"},annotatedMembers:{$t:{pk:"$",tp:[{mt:"tp",nm:"Kind"}],nm:"Sequential"},pa:5,mt:"m",tp:[{sts:[{pk:".",nm:"NestableDeclaration"}],nm:"Kind"},{sts:[{pk:"$",nm:"Annotation"}],nm:"Annotation"}],an:{doc:["Returns the list of member declarations that satisfy the given `Kind` type argument and\nthat are annotated with the given `Annotation` type argument"]},nm:"annotatedMembers"},members:{$t:{pk:"$",tp:[{mt:"tp",nm:"Kind"}],nm:"Sequential"},pa:5,mt:"m",tp:[{sts:[{pk:".",nm:"NestableDeclaration"}],nm:"Kind"}],an:{doc:["Returns the list of member declarations that satisfy the given `Kind` type argument."]},nm:"members"},getClassOrInterface:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"ClassOrInterfaceDeclaration"}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],mt:"m",an:{doc:["The class or interface with the given name. Returns `null` if not found."]},nm:"getClassOrInterface"},getFunction:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"FunctionDeclaration"}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],mt:"m",an:{doc:["The function with the given name. Returns `null` if not found."]},nm:"getFunction"},getMember:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{nm:"Kind"}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],mt:"m",tp:[{sts:[{pk:".",nm:"NestableDeclaration"}],nm:"Kind"}],an:{doc:["Looks up a member declaration by name, provided it satisfies the given `Kind` type\nargument. Returns `null` if no such member matches."]},nm:"getMember"},getAlias:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"AliasDeclaration"}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],mt:"m",an:{doc:["The type alias with the given name. Returns `null` if not found."]},nm:"getAlias"}},an:{doc:["Model of a `package` declaration \nfrom a `package.ceylon` compilation unit"]},nm:"Package"},Module:{pa:17,sts:[{pk:"$",nm:"Identifiable"},{pk:".",nm:"AnnotatedDeclaration"}],mt:"i",$at:{members:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"Package"}],nm:"Sequential"},pa:5,mt:"a",an:{doc:["The package members of the module."]},nm:"members"},version:{$t:{pk:"$",nm:"String"},pa:5,mt:"a",an:{doc:["The module version."]},nm:"version"},dependencies:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"Import"}],nm:"Sequential"},pa:5,mt:"a",an:{doc:["The modules this module depends on."]},nm:"dependencies"}},$m:{findPackage:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"Package"}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],mt:"m",an:{doc:["Finds a package by name. Returns `null` if not found."]},nm:"findPackage"},resourceByPath:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:"$",nm:"Resource"}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"path"}]],mt:"m",an:{doc:["Searches for a resource by its path inside the module."]},nm:"resourceByPath"},findImportedPackage:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"Package"}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],mt:"m",an:{doc:["Finds a package by name in this module or in its dependencies. Note that all transitive `shared`\ndependencies are searched. Returns `null` if not found."]},nm:"findImportedPackage"}},an:{doc:["A `module` declaration\nfrom a `module.ceylon` compilation unit"]},nm:"Module"},"$pkg-anns":{tagged:["Metamodel"],by:["Gavin King","Stephane Epardaud","Tom Bentley"],doc:["The Ceylon metamodel open type and declaration package.\n\nAs described in the [ceylon.language.meta](..\/index.html) documentation, this package contains all\nthe types that represent Ceylon declarations and open types.\n\n### Usage example\n\nThe following code will list all the classes in the `ceylon.language` package and print their\nextended type:\n\n    for(decl in `package ceylon.language`.members<ClassDeclaration>()){\n        if(exists extendedType = decl.extendedType){\n            print(\"Class ``decl.name`` extends: ``extendedType``\");\n        }else{\n            print(\"Class ``decl.name`` does not extend anything\");\n        }\n    }\n\nThe following code will iterate all the class declarations in the `ceylon.language` package that\nare not abstract, anonymous or annotations, and that have no type parameters nor initialiser\nparameters. For each matching class, we will apply it to get a class model which we can then\nuse to instantiate the class and display its instance:\n\n    for(decl in `package ceylon.language`.members<ClassDeclaration>()){\n        if(!decl.abstract \n                && !decl.anonymous \n                && !decl.annotation\n                && decl.parameterDeclarations.empty\n                && decl.typeParameterDeclarations.empty){\n            Class<Object,[]> classModel = decl.classApply<Object,[]>();\n            Object instance = classModel();\n            print(\"Instance of ``decl.name`` is: ``instance``\");\n        }\n    }\n"]},OpenClassOrInterfaceType:{pa:17,sts:[{pk:".",nm:"OpenType"}],mt:"i",of:[{pk:".",nm:"OpenClassType"},{pk:".",nm:"OpenInterfaceType"}],$at:{typeArguments:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"TypeParameter"},{mt:"tp",pk:".",nm:"OpenType"}],nm:"Map"},pa:5,mt:"a",an:{doc:["The map of open type arguments."]},nm:"typeArguments"},typeArgumentWithVariances:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"TypeParameter"},{mt:"tp",pk:".",nm:"OpenTypeArgument"}],nm:"Map"},pa:5,mt:"a",an:{doc:["The map of type parameter declaration to open type arguments and use-site variance."]},nm:"typeArgumentWithVariances"},typeArgumentWithVarianceList:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"OpenTypeArgument"}],nm:"Sequential"},pa:5,mt:"a",an:{doc:["The list of open type arguments with use-site variance."]},nm:"typeArgumentWithVarianceList"},satisfiedTypes:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"OpenInterfaceType"}],nm:"Sequential"},pa:5,mt:"a",an:{doc:["The satisfied types of this open type."]},nm:"satisfiedTypes"},extendedType:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"OpenClassType"}]},pa:5,mt:"a",an:{doc:["The extended type of this open type."]},nm:"extendedType"},typeArgumentList:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"OpenType"}],nm:"Sequential"},pa:5,mt:"a",an:{doc:["The list of open type arguments."]},nm:"typeArgumentList"},declaration:{$t:{pk:".",nm:"ClassOrInterfaceDeclaration"},pa:5,mt:"a",an:{doc:["The class or interface declaration for this open type."]},nm:"declaration"}},an:{doc:["An open class or interface, with open type arguments.\n\nFor example, `List<T>` is an open interface type, with a type argument which is the\n[[OpenTypeVariable]] `T`."]},nm:"OpenClassOrInterfaceType"}},"ceylon.language.meta.model":{ValueConstructor:{pa:17,sts:[{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"ValueModel"},{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Gettable"}],mt:"i",$at:{container:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Class"}]},pa:7,mt:"a",an:{doc:["The class containing this constructor; the type of instances produced \nby this constructor."]},nm:"container"},type:{$t:{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"Class"},pa:7,mt:"a",an:{doc:["This value's closed type."]},nm:"type"},declaration:{$t:{pk:"ceylon.language.meta.declaration",nm:"ValueConstructorDeclaration"},pa:7,mt:"a",an:{doc:["This value's declaration."]},nm:"declaration"}},tp:[{dv:"out",def:{pk:"$",nm:"Object"},nm:"Type"}],an:{doc:["A callable constructor model represents the model of a Ceylon class \nvalue constructor that you can get and inspect\n\n## Gettablity\n\nAs with [[Value]] you can also get the value of a `ValueConstructor`, \ndoing so obtains instance:\n\n     shared class Color {\n         shared String hex;\n         shared new black {\n             this.hex=\"#000000\";\n         }\n         shared new white {\n             this.hex=\"#ffffff\";\n         }\n     }\n     \n     void test() {\n     ValueConstructor<Color> ctor = `Color.black`;\n     \/\/ This will print: #000000\n     print(ctor.get());\n     \n"]},nm:"ValueConstructor"},ClassOrInterface:{pa:17,sts:[{pk:".",nm:"Model"},{pk:".",nm:"Generic"},{pk:".",tp:[{mt:"tp",nm:"Type"}],nm:"Type"}],mt:"i",of:[{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"ClassModel"},{pk:".",tp:[{mt:"tp",nm:"Type"}],nm:"InterfaceModel"}],$at:{satisfiedTypes:{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"InterfaceModel"}],nm:"Sequential"},pa:5,mt:"a",an:{doc:["The list of closed types that this class or interface satisfies."]},nm:"satisfiedTypes"},extendedType:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"ClassModel"}]},pa:5,mt:"a",an:{doc:["The extended closed type for this class or interface. \nNote that the [[Anything|ceylon.language::Anything]] type\nhas no extended type since it is the top of the type hierarchy."]},nm:"extendedType"},caseValues:{$t:{pk:"$",tp:[{mt:"tp",nm:"Type"}],nm:"Sequential"},pa:5,mt:"a",an:{doc:["The list of case values for this type. This omits any case type to \nonly contain case values."]},nm:"caseValues"},declaration:{$t:{pk:"ceylon.language.meta.declaration",nm:"ClassOrInterfaceDeclaration"},pa:7,mt:"a",an:{doc:["The declaration for this class or interface."]},nm:"declaration"}},$m:{getDeclaredAttribute:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Get"},{mt:"tp",nm:"Set"}],nm:"Attribute"}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Get"},{def:{pk:".",nm:"Nothing"},nm:"Set"}],an:{doc:["Gets an attribute by name. Returns `null` if not found.\n\nSee [[getDeclaredClassOrInterface]] for how the [[Container]] type parameter works."],throws:["IncompatibleTypeException","If the specified `Container`, `Get` or `Set` type arguments are not compatible with the actual result."]},nm:"getDeclaredAttribute"},getClass:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"MemberClass"}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"},{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"types"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"},{sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{doc:["Gets a member class by name. Returns `null` if not found.\n\nSee [[getClassOrInterface]] for how the [[Container]] type parameter works."],throws:["TypeApplicationException","If the specified closed type argument values are not compatible with the actual result's type parameters."]},nm:"getClass"},getInterface:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"}],nm:"MemberInterface"}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"},{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"types"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"}],an:{doc:["Gets a member interface by name. Returns `null` if not found.\n\nSee [[getClassOrInterface]] for how the [[Container]] type parameter works."],throws:["TypeApplicationException","If the specified closed type argument values are not compatible with the actual result's type parameters."]},nm:"getInterface"},getDeclaredAttributes:{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Get"},{mt:"tp",nm:"Set"}],nm:"Attribute"}],nm:"Sequential"},pa:5,ps:[[{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Annotation"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"annotationTypes"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Get"},{def:{pk:".",nm:"Nothing"},nm:"Set"}],an:{doc:["Gets a list of attributes matching the given container and attribute type, annotated with all the\nspecified annotations, which are directly declared on this type."]},nm:"getDeclaredAttributes"},getAttributes:{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Get"},{mt:"tp",nm:"Set"}],nm:"Attribute"}],nm:"Sequential"},pa:5,ps:[[{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Annotation"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"annotationTypes"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Get"},{def:{pk:".",nm:"Nothing"},nm:"Set"}],an:{doc:["Gets a list of attributes matching the given container and attribute type, annotated with all the\nspecified annotations, which are declared on this type or inherited."]},nm:"getAttributes"},getDeclaredInterfaces:{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"}],nm:"MemberInterface"}],nm:"Sequential"},pa:5,ps:[[{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Annotation"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"annotationTypes"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"}],an:{doc:["Returns the list of member interfaces directly declared on this class or interface \nand annotated with all the specified annotations.\nThis includes unshared member interfaces but not inherited member interfaces."]},nm:"getDeclaredInterfaces"},getClassOrInterface:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Kind"}],nm:"Member"}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"},{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"types"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{sts:[{pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"ClassOrInterface"}],def:{pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"ClassOrInterface"},nm:"Kind"}],an:{doc:["Gets a member class or interface by name. Returns `null` if not found.\n\nThe [[Container]] type parameter acts as a selector for the container of the member:\n\n- If it is the current type or a subtype, and the attribute exists in this type, then the attribute\n  of the current type is returned. For example, looking up 'unit' in [[Integer]] with [[Integer]] as [[Container]]\n  will return [[Integer.unit]].\n- If it is a supertype of this type, and that supertype defines this attribyte, then that supertype's\n  attribute is returned. For example, looking up 'hash' in [[Integer]] with [[Object]] as [[Container]] will return [[Object.hash]].\n- If it is a type that is disjoint from this type, the attribute will be looked up in the common supertype\n  between that type and this type. For example, looking up 'hash' in [[Integer]] with [[String]] as [[Container]] \n  will return [[Object.hash]].\n- If the common supertype between this type and the [[Container]] type has no such member, `null` is returned.\n"],throws:["TypeApplicationException","If the specified closed type argument values are not compatible with the actual result's type parameters."]},nm:"getClassOrInterface"},getInterfaces:{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"}],nm:"MemberInterface"}],nm:"Sequential"},pa:5,ps:[[{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Annotation"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"annotationTypes"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"}],an:{doc:["Returns the list of shared member interfaces on this class or interface\nand annotated with all the specified annotations. \nThis includes inherited member interfaces but not unshared member interfaces."]},nm:"getInterfaces"},getDeclaredMethod:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"Method"}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"},{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"types"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"},{sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{doc:["Gets a method by name. Returns `null` if not found.\n\nSee [[getDeclaredClassOrInterface]] for how the [[Container]] type parameter works."],throws:["TypeApplicationException","If the specified closed type argument values are not compatible with the actual result's type parameters."]},nm:"getDeclaredMethod"},getDeclaredClass:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"MemberClass"}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"},{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"types"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"},{sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{doc:["Gets a member class by name. Returns `null` if not found.\n\nSee [[getDeclaredClassOrInterface]] for how the [[Container]] type parameter works."],throws:["TypeApplicationException","If the specified closed type argument values are not compatible with the actual result's type parameters."]},nm:"getDeclaredClass"},getMethod:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"Method"}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"},{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"types"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"},{sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{doc:["Gets a method by name. Returns `null` if not found.\n\nSee [[getClassOrInterface]] for how the [[Container]] type parameter works."],throws:["TypeApplicationException","If the specified closed type argument values are not compatible with the actual result's type parameters."]},nm:"getMethod"},getDeclaredMethods:{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"Method"}],nm:"Sequential"},pa:5,ps:[[{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Annotation"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"annotationTypes"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"},{sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{doc:["Gets a list of methods matching the given container, return and parameter types, annotated with all the\nspecified annotations, which are directly declared on this type."]},nm:"getDeclaredMethods"},getDeclaredInterface:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"}],nm:"MemberInterface"}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"},{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"types"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"}],an:{doc:["Gets a member interface by name. Returns `null` if not found.\n\nSee [[getDeclaredClassOrInterface]] for how the [[Container]] type parameter works."],throws:["TypeApplicationException","If the specified closed type argument values are not compatible with the actual result's type parameters."]},nm:"getDeclaredInterface"},getAttribute:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Get"},{mt:"tp",nm:"Set"}],nm:"Attribute"}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Get"},{def:{pk:".",nm:"Nothing"},nm:"Set"}],an:{doc:["Gets an attribute by name. Returns `null` if not found.\n\nSee [[getClassOrInterface]] for how the [[Container]] type parameter works."],throws:["IncompatibleTypeException","If the specified `Get` or `Set` type arguments are not compatible with the actual result."]},nm:"getAttribute"},getDeclaredClasses:{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"MemberClass"}],nm:"Sequential"},pa:5,ps:[[{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Annotation"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"annotationTypes"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"},{sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{doc:["Gets a list of member classes matching the given container, return and parameter types, annotated with all the\nspecified annotations, which are directly declared on this type."]},nm:"getDeclaredClasses"},getDeclaredClassOrInterface:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Kind"}],nm:"Member"}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"},{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"types"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{sts:[{pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"ClassOrInterface"}],def:{pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"ClassOrInterface"},nm:"Kind"}],an:{doc:["Gets a member class or interface by name. Returns `null` if not found.\n\nThe [[Container]] type parameter acts as a selector for the container of the member:\n\n- If it is the current type or a subtype, and the attribute exists in this type, then the attribute\n  of the current type is returned. For example, looking up 'unit' in [[Integer]] with [[Integer]] as [[Container]]\n  will return [[Integer.unit]].\n- If it is a supertype of this type, or a type that is disjoint from this type, an [[IncompatibleTypeException]] will\n  be thrown.\n- If this type has no such member, `null` is returned.\n"],throws:["TypeApplicationException","If the specified closed type argument values are not compatible with the actual result's type parameters."]},nm:"getDeclaredClassOrInterface"},getMethods:{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"Method"}],nm:"Sequential"},pa:5,ps:[[{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Annotation"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"annotationTypes"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"},{sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{doc:["Gets a list of methods matching the given container, return and parameter types, annotated with all the\nspecified annotations, which are declared on this type or inherited."]},nm:"getMethods"},getClasses:{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"MemberClass"}],nm:"Sequential"},pa:5,ps:[[{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Annotation"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"annotationTypes"}]],mt:"m",tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"},{sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{doc:["Returns the list of shared member classes on this class or interface\nand annotated with all the specified annotations. \nThis includes inherited member classes but not unshared member classes."]},nm:"getClasses"}},tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"}],an:{doc:["Model of a class or interface that you can inspect.\n\nThe models of classes and interfaces are also closed types."]},nm:"ClassOrInterface"},MemberClassValueConstructor:{pa:17,sts:[{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"ValueModel"},{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Type"}],nm:"ValueConstructor"},{mt:"tp",nm:"Container"}],nm:"Qualified"}],mt:"i",$at:{container:{$t:{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"ClassModel"},pa:7,mt:"a",an:{doc:["The class containing this constructor; the type of instances produced \nby this constructor."]},nm:"container"},type:{$t:{pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"MemberClass"},pa:7,mt:"a",an:{doc:["This value's closed type."]},nm:"type"},declaration:{$t:{pk:"ceylon.language.meta.declaration",nm:"ValueConstructorDeclaration"},pa:7,mt:"a",an:{doc:["This value's declaration."]},nm:"declaration"}},$m:{bind:{$t:{pk:".",tp:[{mt:"tp",nm:"Type"}],nm:"ValueConstructor"},pa:7,ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"container"}]],mt:"m",an:{doc:["Binds this attribute to the given container instance. The instance type is checked at runtime."],throws:["StorageException","If this attribute is not stored at runtime, for example if it is neither shared nor captured."]},nm:"bind"}},tp:[{dv:"in",def:{pk:".",nm:"Nothing"},nm:"Container"},{dv:"out",def:{pk:"$",nm:"Object"},nm:"Type"}],an:{doc:["A model for a value constructor of a member class."]},nm:"MemberClassValueConstructor"},UnionType:{pa:17,sts:[{pk:".",tp:[{mt:"tp",nm:"Union"}],nm:"Type"}],mt:"i",$at:{caseTypes:{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"List"},pa:5,mt:"a",an:{doc:["The list of closed case types of this union."]},nm:"caseTypes"}},tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Union"}],an:{doc:["A closed union type."]},nm:"UnionType"},TypeApplicationException:{super:{pk:"$",nm:"Exception"},pa:1,ps:[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"message"}],mt:"c",$at:{message$9tu43y:{$t:{pk:"$",nm:"String"},mt:"a",nm:"message"}},an:{doc:["Thrown when declarations are applied with invalid or incompatible type arguments.\nAlso throw when trying to apply member declarations with no containers, or toplevel\ndeclarations with a container.\n\nFor example if you try to apply `Foo` with `String`, hoping to get a `Foo<String>`\nbut the type parameter for `Foo` only accepts types that satisfy `Numeric`.\n"]},nm:"TypeApplicationException"},MemberClass:{pa:17,sts:[{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"ClassModel"},{pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"Class"}],nm:"Member"}],mt:"i",$at:{defaultConstructor:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"MemberClassCallableConstructor"}]},pa:7,mt:"a",nm:"defaultConstructor"}},$m:{bind:{$t:{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"Class"},pa:7,ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"container"}]],mt:"m",nm:"bind"},getConstructor:{$t:{comp:"u",l:[{pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"MemberClassCallableConstructor"},{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"}],nm:"MemberClassValueConstructor"}]}]},pa:7,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],mt:"m",tp:[{sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],nm:"Arguments"}],an:{doc:["The constructor with the given name, or null if this class lacks \na constructor of the given name"]},nm:"getConstructor"}},tp:[{dv:"in",def:{pk:".",nm:"Nothing"},nm:"Container"},{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"},{dv:"in",sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{doc:["A class model represents the model of a Ceylon class that you can instantiate and inspect.\n\nA member class is is declared on classes or interfaces.\n\nThis is both a [[ClassModel]] and a [[Member]]: you can invoke it with an instance value\nto bind it to that instance and obtain a [[Class]]:\n\n    shared class Outer(String name){\n        shared class Inner(){\n            shared String hello => \"Hello \"+name;\n        }\n    }\n    \n    void test(){\n        MemberClass<Outer,Outer.Inner,[]> memberClass = `Outer.Inner`;\n        Class<Outer.Inner,[]> c = memberClass(Outer(\"Stef\"));\n        \/\/ This will print: Hello Stef\n        print(c().hello);\n    }\n"]},nm:"MemberClass"},ValueModel:{pa:17,sts:[{pk:".",nm:"Model"}],mt:"i",$at:{type:{$t:{pk:".",tp:[{mt:"tp",nm:"Get"}],nm:"Type"},pa:5,mt:"a",an:{doc:["This value's closed type."]},nm:"type"},declaration:{$t:{comp:"i",l:[{pk:"ceylon.language.meta.declaration",nm:"NestableDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"GettableDeclaration"}]},pa:7,mt:"a",an:{doc:["This value's declaration."]},nm:"declaration"}},tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Get"},{dv:"in",def:{pk:".",nm:"Nothing"},nm:"Set"}],an:{doc:["A value model represents the model of a Ceylon value that you can inspect.\n\nA value model can be either a toplevel [[Value]] or a member [[Attribute]].\n"]},nm:"ValueModel"},Attribute:{pa:17,sts:[{pk:".",tp:[{mt:"tp",nm:"Get"},{mt:"tp",nm:"Set"}],nm:"ValueModel"},{pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Get"},{mt:"tp",nm:"Set"}],nm:"Value"}],nm:"Member"}],mt:"i",$at:{declaration:{$t:{pk:"ceylon.language.meta.declaration",nm:"ValueDeclaration"},pa:7,mt:"a",an:{doc:["The declaration model of this attribute, \nwhich is necessarily a [[ValueDeclaration]]."]},nm:"declaration"}},$m:{bind:{$t:{pk:".",tp:[{mt:"tp",nm:"Get"},{mt:"tp",nm:"Set"}],nm:"Value"},pa:7,ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"container"}]],mt:"m",an:{doc:["Binds this attribute to the given container instance. The instance type is checked at runtime."],throws:["StorageException","If this attribute is not stored at runtime, for example if it is neither shared nor captured."]},nm:"bind"}},tp:[{dv:"in",def:{pk:".",nm:"Nothing"},nm:"Container"},{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Get"},{dv:"in",def:{pk:".",nm:"Nothing"},nm:"Set"}],an:{doc:["An attribute model represents the model of a Ceylon attribute that you can read and inspect.\n\nAn attribute is a member value: it is declared on classes or interfaces.\n\nThis is both a [[ValueModel]] and a [[Member]]: you can invoke it with an instance value\nto bind it to that instance and obtain a [[Value]]:\n\n    class Outer(){\n        shared String foo = \"Hello\";\n    }\n    \n    void test(){\n        Attribute<Outer,String> attribute = `Outer.foo`;\n        Value<String> boundAttribute = attribute(Outer());\n        \/\/ This will print: Hello\n        print(boundAttribute.get());\n    }\n"]},nm:"Attribute"},Generic:{pa:17,mt:"i",$at:{typeArguments:{$t:{pk:"$",tp:[{mt:"tp",pk:"ceylon.language.meta.declaration",nm:"TypeParameter"},{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Map"},pa:5,mt:"a",an:{doc:["The map of type parameter declaration to type arguments for this generic model."]},nm:"typeArguments"},typeArgumentWithVariances:{$t:{pk:"$",tp:[{mt:"tp",pk:"ceylon.language.meta.declaration",nm:"TypeParameter"},{mt:"tp",pk:".",nm:"TypeArgument"}],nm:"Map"},pa:5,mt:"a",an:{doc:["The map of type parameter declaration to type arguments and use-site variance for this generic model."]},nm:"typeArgumentWithVariances"},typeArgumentWithVarianceList:{$t:{pk:"$",tp:[{mt:"tp",pk:".",nm:"TypeArgument"}],nm:"Sequential"},pa:5,mt:"a",an:{doc:["The list of type arguments for this generic model."]},nm:"typeArgumentWithVarianceList"},typeArgumentList:{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},pa:5,mt:"a",an:{doc:["The list of type arguments for this generic model."]},nm:"typeArgumentList"}},an:{doc:["A generic model which has closed type arguments."]},nm:"Generic"},Function:{pa:17,sts:[{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"FunctionModel"},{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"Applicable"}],mt:"i",$at:{declaration:{$t:{pk:"ceylon.language.meta.declaration",nm:"FunctionDeclaration"},pa:7,mt:"a",an:{doc:["This function's declaration."]},nm:"declaration"}},tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"},{dv:"in",sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{doc:["A function model represents the model of a Ceylon function that you can invoke and inspect.\n\nA function is a toplevel binding, declared on a package.\n\nThis is a [[FunctionModel]] that you can also invoke:\n\n    shared String foo(String name) => \"Hello \"+name;\n    \n    void test(){\n        Function<String,[String]> f = `foo`;\n        \/\/ This will print: Hello Stef\n        print(f(\"Stef\"));\n    }\n"]},nm:"Function"},Gettable:{pa:17,mt:"i",$m:{set:{$t:{pk:"$",nm:"Anything"},pa:5,ps:[[{$t:{nm:"Set"},mt:"prm",nm:"newValue"}]],$ff:1,mt:"m",an:{doc:["Changes this variable's value to the given new value. Note that in the case of\nsetter attributes, this can throw if the setter throws."],throws:["StorageException","If this attribute is not stored at runtime, for example if it is neither shared nor captured."]},nm:"set"},get:{$t:{nm:"Get"},pa:5,mt:"m",an:{doc:["Reads the current value for this value binding. Note that in the case of getter\nvalues, this can throw if the getter throws."],throws:["StorageException","If this attribute is not stored at runtime, for example if it is neither shared nor captured."]},nm:"get"},setIfAssignable:{$t:{pk:"$",nm:"Anything"},pa:5,ps:[[{$t:{pk:"$",nm:"Anything"},mt:"prm",nm:"newValue"}]],$ff:1,mt:"m",an:{doc:["Non type-safe equivalent to [[Value.set]], to be used when you don't know the \nvariable type at compile-time. This only works if the underlying value is \nvariable. Note that if the underlying variable is a setter, this can throw \nexceptions thrown in the setter block."],throws:["StorageException","If this attribute is not stored at runtime, for example if it is neither shared nor captured."]},nm:"setIfAssignable"}},tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Get"},{dv:"in",def:{pk:".",nm:"Nothing"},nm:"Set"}],an:{doc:["An abstraction of things that have a value which be [[got|get]], \nand possibley set.  \n"]},nm:"Gettable"},FunctionModel:{pa:17,sts:[{pk:".",nm:"Model"},{pk:".",nm:"Generic"},{pk:".",nm:"Functional"}],mt:"i",$at:{type:{$t:{pk:".",tp:[{mt:"tp",nm:"Type"}],nm:"Type"},pa:5,mt:"a",an:{doc:["This function's return closed type."]},nm:"type"},declaration:{$t:{comp:"i",l:[{pk:"ceylon.language.meta.declaration",nm:"NestableDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"FunctionalDeclaration"}]},pa:7,mt:"a",an:{doc:["This function's declaration."]},nm:"declaration"}},tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"},{dv:"in",sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{doc:["A function model represents the model of a Ceylon function that you can inspect.\n\nA function model can be either a toplevel [[Function]], a \n[[CallableConstructor|callable constructor]] of a toplevel Class,\na member [[Method]] or [[CallableMemberConstructor|callable constructor]]\nof a member class.\n"]},nm:"FunctionModel"},InvocationException:{super:{pk:"$",nm:"Exception"},pa:1,ps:[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"message"}],mt:"c",$at:{message$g4ihko:{$t:{pk:"$",nm:"String"},mt:"a",nm:"message"}},an:{doc:["Thrown when attempting to invoke something which can't be invoked, like abstract class\ninitialisers."]},nm:"InvocationException"},IncompatibleTypeException:{super:{pk:"$",nm:"Exception"},pa:1,ps:[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"message"}],mt:"c",$at:{message$kubtzh:{$t:{pk:"$",nm:"String"},mt:"a",nm:"message"}},an:{doc:["Thrown when you invoke metamodel methods with invalid or incompatible type arguments.\n\nFor example if you try to get an attribute from a class and expect an attribute of `String`\ntype but it is an attribute of `Integer` type.\n"]},nm:"IncompatibleTypeException"},Member:{pa:17,sts:[{pk:".",tp:[{mt:"tp",nm:"Kind"},{mt:"tp",nm:"Container"}],nm:"Qualified"}],mt:"i",$at:{declaringType:{$t:{pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"},pa:5,mt:"a",an:{doc:["The declaring closed type. This is the type that declared this member."]},nm:"declaringType"}},tp:[{dv:"in",def:{pk:".",nm:"Nothing"},nm:"Container"},{dv:"out",sts:[{pk:".",nm:"Model"}],def:{pk:".",nm:"Model"},nm:"Kind"}],an:{doc:["Model for members that can be bound to a containing instance to turn them into toplevel models.\n\nYou can bind a member to an instance by invoking that member with the instance as parameter:\n\n    shared class Outer(String name){\n        shared class Inner(){\n            shared String hello => \"Hello \"+name;\n        }\n    }\n    \n    void test(){\n        Member<Outer,Class<Outer.Inner,[]>> memberClass = `Outer.Inner`;\n        Class<Outer.Inner,[]> c = memberClass(Outer(\"Stef\"));\n        \/\/ This will print: Hello Stef\n        print(c().hello);\n    }\n"]},nm:"Member"},"$pkg-pa":1,TypeArgument:{pa:1,$alias:{pk:"$",l:[{pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"},{pk:"ceylon.language.meta.declaration",nm:"Variance"}],nm:"Tuple"},mt:"als",an:{doc:["A tuple representing a type argument and its use-site variance."]},nm:"TypeArgument"},Method:{pa:17,sts:[{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"FunctionModel"},{pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"Function"}],nm:"Member"}],mt:"i",$at:{declaration:{$t:{pk:"ceylon.language.meta.declaration",nm:"FunctionDeclaration"},pa:7,mt:"a",an:{doc:["This function's declaration."]},nm:"declaration"}},$m:{bind:{$t:{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"Function"},pa:7,ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"container"}]],mt:"m",nm:"bind"}},tp:[{dv:"in",def:{pk:".",nm:"Nothing"},nm:"Container"},{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"},{dv:"in",sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{doc:["A function model represents the model of a Ceylon function that you can invoke and inspect.\n\nA method is a member function: it is declared on classes or interfaces.\n\nThis is both a [[FunctionModel]] and a [[Member]]: you can invoke it with an instance value\nto bind it to that instance and obtain a [[Function]]:\n\n    class Outer(){\n        shared String foo(String name) => \"Hello \"+name;\n    }\n    \n    void test(){\n        Method<Outer,String,[String]> method = `Outer.foo`;\n        \/\/ Bind it to an instance value\n        Function<String,[String]> f = method(Outer());\n        \/\/ This will print: Hello Stef\n        print(f(\"Stef\"));\n    }\n"]},nm:"Method"},MutationException:{super:{pk:"$",nm:"Exception"},pa:1,ps:[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"message"}],mt:"c",$at:{message$l7zqwp:{$t:{pk:"$",nm:"String"},mt:"a",nm:"message"}},an:{doc:["Thrown when you try to change the value of a non-variable value"]},nm:"MutationException"},Qualified:{pa:17,sts:[{pk:"$",tp:[{mt:"tp",nm:"Kind"},{mt:"tp",pk:"$",tp:[{comp:"u",mt:"tp",l:[{nm:"Container"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Container"},{mt:"tp",pk:"$",nm:"Empty"}],nm:"Tuple"}],nm:"Callable"}],mt:"i",$m:{bind:{$t:{nm:"Kind"},pa:5,ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"container"}]],mt:"m",an:{doc:["Type-unsafe container binding, to be used when the container type is unknown until runtime.\n\nThis has the same behaviour as invoking this `Member` directly, but exchanges compile-time type\nsafety with runtime checks."],throws:["IncompatibleTypeException","If the container is not assignable to this member's container"]},nm:"bind"}},tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Kind"},{dv:"in",def:{pk:".",nm:"Nothing"},nm:"Container"}],an:{doc:["Abstraction for models of elements which must be qualified \nby an instance to order to be evaluated, including:\n\n* [[Attribute]]s (a Qualified `Value`), \n* [[Method]]s  (a Qualified `Function`), \n* [[MemberClass|member classes]]  (a Qualified `Class`) and,\n* [[MemberClassConstructor|member constructors]]  (a constructor of a Qualified `Class`).\n\nTo qualify a `Qualified` metamodel instance in a type-safe way you \nsimply invoke it. Alternatively use [[bind]] if the qualifying instance's \ntype is unknown until runtime."]},nm:"Qualified"},Declared:{pa:17,mt:"i",$at:{container:{$t:{comp:"u",l:[{pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"},{comp:"u",l:[{pk:"$",nm:"Null"},{pk:"ceylon.language.meta.declaration",nm:"Package"}]}]},pa:5,mt:"a",an:{doc:["The container type of this model, or `null` if this is a toplevel model."]},nm:"container"},declaration:{$t:{pk:"ceylon.language.meta.declaration",nm:"Declaration"},pa:5,mt:"a",an:{doc:["The declaration model of this model."]},nm:"declaration"}},an:{doc:["A model element that has a declaration."]},nm:"Declared"},Functional:{pa:17,mt:"i",$at:{parameterTypes:{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"Sequential"},pa:5,mt:"a",an:{doc:["The parameter types"]},nm:"parameterTypes"}},an:{doc:["Abstraction for models which have a parameter list."]},nm:"Functional"},InterfaceModel:{pa:17,sts:[{pk:".",tp:[{mt:"tp",nm:"Type"}],nm:"ClassOrInterface"}],mt:"i",$at:{declaration:{$t:{pk:"ceylon.language.meta.declaration",nm:"InterfaceDeclaration"},pa:7,mt:"a",an:{doc:["The declaration model of this class, \nwhich is necessarily an [[InterfaceDeclaration]]."]},nm:"declaration"}},tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"}],an:{doc:["An interface model represents the model of a Ceylon interface that you can inspect.\n\nAn interface model can be either a toplevel [[Interface]] or a member [[MemberInterface]].\n"]},nm:"InterfaceModel"},Type:{pa:17,mt:"i",$m:{supertypeOf:{$t:{pk:"$",nm:"Boolean"},pa:5,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"},mt:"prm",nm:"type"}]],mt:"m",an:{doc:["True if this type is a supertype of the given type, or if both types are the same."]},nm:"supertypeOf"},intersection:{$t:{pk:".",tp:[{comp:"i",mt:"tp",l:[{nm:"Target"},{nm:"Other"}]}],nm:"Type"},pa:5,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Type"},mt:"prm",nm:"other"}]],mt:"m",tp:[{nm:"Other"}],an:{doc:["The intersection of this type with the other type."]},nm:"intersection"},subtypeOf:{$t:{pk:"$",nm:"Boolean"},pa:9,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"},mt:"prm",nm:"type"}]],mt:"m",an:{doc:["True if this type is a subtype of the given type, or if both types are the same."]},nm:"subtypeOf"},union:{$t:{pk:".",tp:[{comp:"u",mt:"tp",l:[{nm:"Target"},{nm:"Other"}]}],nm:"Type"},pa:5,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Type"},mt:"prm",nm:"other"}]],mt:"m",tp:[{nm:"Other"}],an:{doc:["The union of this type with the other type."]},nm:"union"},exactly:{$t:{pk:"$",nm:"Boolean"},pa:5,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"},mt:"prm",nm:"type"}]],mt:"m",an:{doc:["True if the given type is a exactly this type."]},nm:"exactly"},typeOf:{$t:{pk:"$",nm:"Boolean"},pa:5,ps:[[{$t:{pk:"$",nm:"Anything"},mt:"prm",nm:"instance"}]],mt:"m",an:{doc:["True if the given instance is of this type, or is of a subtype of this type."]},nm:"typeOf"}},tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Target"}],an:{doc:["A closed type.\n\nA closed type is a type which is fully resolved and bound and contains no open type variables.\nAll instance types are closed at runtime.\n\nYou have only four sorts of types:\n\n- [[ClassOrInterface]]\n- [[UnionType]]\n- [[IntersectionType]]\n- [[nothingType]]"]},nm:"Type"},IntersectionType:{pa:17,sts:[{pk:".",tp:[{mt:"tp",nm:"Intersection"}],nm:"Type"}],mt:"i",$at:{satisfiedTypes:{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}],nm:"List"},pa:5,mt:"a",an:{doc:["The list of closed satisfied types of this intersection."]},nm:"satisfiedTypes"}},tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Intersection"}],an:{doc:["A closed intersection type."]},nm:"IntersectionType"},ClassModel:{pa:17,sts:[{pk:".",tp:[{mt:"tp",nm:"Type"}],nm:"ClassOrInterface"}],mt:"i",$at:{defaultConstructor:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"FunctionModel"}]},pa:5,mt:"a",an:{doc:["A function model for this class's initializer or default constructor,\nor null if this class has constructors but lacks a default constructor."]},nm:"defaultConstructor"},declaration:{$t:{pk:"ceylon.language.meta.declaration",nm:"ClassDeclaration"},pa:7,mt:"a",an:{doc:["The declaration model of this class, \nwhich is necessarily a [[ClassDeclaration]]."]},nm:"declaration"}},$m:{getDeclaredCallableConstructors:{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"FunctionModel"}],nm:"Sequential"},pa:5,ps:[[{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Annotation"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"annotationTypes"}]],mt:"m",tp:[{sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{doc:["Returns the list of callable constructors directly declared on this class \nand annotated with all the specified annotations.\nThis includes unshared callable constructors."]},nm:"getDeclaredCallableConstructors"},getDeclaredValueConstructors:{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"ValueModel"}],nm:"Sequential"},pa:5,ps:[[{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Annotation"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"annotationTypes"}]],mt:"m",an:{doc:["Returns the list of value constructors directly declared on this class \nand annotated with all the specified annotations.\nThis includes unshared constructors."]},nm:"getDeclaredValueConstructors"},getCallableConstructors:{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"FunctionModel"}],nm:"Sequential"},pa:5,ps:[[{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Annotation"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"annotationTypes"}]],mt:"m",tp:[{sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{doc:["Returns the list of shared callable constructors on this class\nand annotated with all the specified annotations. \nThis does not include unshared callable constructors."]},nm:"getCallableConstructors"},getDeclaredConstructor:{$t:{comp:"u",l:[{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"FunctionModel"},{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"ValueModel"}]}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],mt:"m",tp:[{sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],nm:"Arguments"}],an:{doc:["Looks up a constructor by name, \nReturns `null` if no such constructor matches. \nThis includes unshared constructors."],throws:["IncompatibleTypeException","If the specified type arguments are not \ncompatible with the actual result."]},nm:"getDeclaredConstructor"},getValueConstructors:{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"ValueModel"}],nm:"Sequential"},pa:5,ps:[[{$t:{pk:"$",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",pk:"$",nm:"Annotation"}],nm:"Type"}],nm:"Sequential"},mt:"prm",seq:1,nm:"annotationTypes"}]],mt:"m",an:{doc:["Returns the list of shared value constructors on this class\nand annotated with all the specified annotations. \nThis does not include unshared value constructors."]},nm:"getValueConstructors"},getConstructor:{$t:{comp:"u",l:[{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"FunctionModel"},{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"ValueModel"}]}]},pa:5,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],mt:"m",tp:[{sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],nm:"Arguments"}],an:{doc:["Looks up a constructor by name, \nReturns `null` if no such constructor matches. \nThis excludes unshared constructors."],throws:["IncompatibleTypeException","If the specified type arguments are not \ncompatible with the actual result."]},nm:"getConstructor"}},tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"},{dv:"in",sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{doc:["A class model represents the model of a Ceylon class that you can inspect.\n\nA class model can be either a toplevel [[Class]] or a member [[MemberClass]].\n"]},nm:"ClassModel"},Applicable:{pa:17,sts:[{pk:"$",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"Callable"}],mt:"i",$m:{apply:{$t:{nm:"Type"},pa:5,ps:[[{$t:{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"},mt:"prm",seq:1,nm:"arguments"}]],mt:"m",an:{doc:["Type-unsafe application, to be used when the argument types are unknown until runtime.\n\nThis has the same behaviour as invoking the applicable directly, but exchanges compile-time type\nsafety with runtime checks."],throws:["InvocationException","If there are not enough or too many provided arguments"]},nm:"apply"},namedApply:{$t:{nm:"Type"},pa:5,ps:[[{$t:{pk:"$",tp:[{mt:"tp",pk:"$",tp:[{mt:"tp",pk:"$",nm:"String"},{mt:"tp",pk:"$",nm:"Anything"}],nm:"Entry"},{mt:"tp",pk:"$",nm:"Null"}],nm:"Iterable"},mt:"prm",nm:"arguments"}]],mt:"m",an:{doc:["Type-unsafe application by name, to be used when the argument types are unknown until runtime.\n\nThis has the same behaviour as invoking the applicable directly, but exchanges compile-time type\nsafety with runtime checks."],throws:["InvocationException","If there are not enough or too many provided arguments, \nor if the target does not support named invocation"]},nm:"namedApply"}},tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"},{dv:"in",sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{doc:["Represents classes or functions that you can apply in a type-unsafe way.\n"]},nm:"Applicable"},CallableConstructor:{pa:17,sts:[{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"FunctionModel"},{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"Applicable"}],mt:"i",$at:{container:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"ClassModel"}]},pa:7,mt:"a",an:{doc:["The class containing this constructor; the type of instances produced \nby this constructor."]},nm:"container"},type:{$t:{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"ClassModel"},pa:7,mt:"a",nm:"type"},declaration:{$t:{pk:"ceylon.language.meta.declaration",nm:"CallableConstructorDeclaration"},pa:7,mt:"a",an:{doc:["This constructor's declaration."]},nm:"declaration"}},tp:[{dv:"out",def:{pk:"$",nm:"Object"},nm:"Type"},{dv:"in",sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{doc:["A callable constructor model represents the model of a Ceylon class \nconstructor that you can invoke and inspect\n\n## Callablity\n\nAs with [[Function]] you can also invoke a `CallableConstructor`, doing so \ninstantiates an instance:\n\n     shared class Foo {\n         shared String name;\n         shared new foo(String name) {\n             this.name = name;\n         }\n     }\n     \n     void test() {\n     Constructor<Foo,[String]> ctor = `Foo.foo`;\n     \/\/ This will print: Stef\n     print(ctor(\"Stef\").name);\n     \n## Genericity\n     \nThis class inherits [[Generic]] but a constructor in Ceylon cannot \nhave a type parameters. \nFor symmetry with [[CallableConstructorDeclaration.apply]] the \n[[typeArguments]] and [[typeArgumentList]] refer to the type arguments \nof the constructor's class.\n"]},nm:"CallableConstructor"},nothingType:{super:{pk:"$",nm:"Basic"},pa:1,sts:[{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"}],nm:"Type"}],mt:"o",$at:{string:{$t:{pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"}},$m:{supertypeOf:{$t:{pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"},mt:"prm",nm:"type"}]],mt:"m",nm:"supertypeOf"},intersection:{$t:{pk:".",tp:[{mt:"tp",pk:".",nm:"Nothing"}],nm:"Type"},pa:3,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Type"},mt:"prm",nm:"type"}]],mt:"m",tp:[{nm:"Other"}],nm:"intersection"},subtypeOf:{$t:{pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"},mt:"prm",nm:"type"}]],mt:"m",nm:"subtypeOf"},union:{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Type"},pa:3,ps:[[{$t:{pk:".",tp:[{mt:"tp",nm:"Other"}],nm:"Type"},mt:"prm",nm:"type"}]],mt:"m",tp:[{nm:"Other"}],nm:"union"},exactly:{$t:{pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"},mt:"prm",nm:"type"}]],mt:"m",nm:"exactly"},typeOf:{$t:{pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{pk:"$",nm:"Anything"},mt:"prm",nm:"instance"}]],mt:"m",nm:"typeOf"}},an:{doc:["The singleton closed type for [[Nothing|ceylon.language::nothing]]."]},nm:"nothingType"},Model:{pa:17,sts:[{pk:".",nm:"Declared"}],mt:"i",of:[{pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"ClassOrInterface"},{pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"FunctionModel"},{pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"ValueModel"}],$at:{container:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Type"}]},pa:7,mt:"a",an:{doc:["The container type of this model, or `null` if this is a toplevel model."]},nm:"container"},declaration:{$t:{pk:"ceylon.language.meta.declaration",nm:"NestableDeclaration"},pa:7,mt:"a",an:{doc:["The declaration for this model."]},nm:"declaration"}},an:{doc:["The root of all models. There are several types of models:\n\n- [[ClassOrInterface]]\n- [[FunctionModel]]\n- [[ValueModel]]\n"]},nm:"Model"},Value:{pa:17,sts:[{pk:".",tp:[{mt:"tp",nm:"Get"},{mt:"tp",nm:"Set"}],nm:"ValueModel"},{pk:".",tp:[{mt:"tp",nm:"Get"},{mt:"tp",nm:"Set"}],nm:"Gettable"}],mt:"i",$at:{declaration:{$t:{pk:"ceylon.language.meta.declaration",nm:"ValueDeclaration"},pa:7,mt:"a",an:{doc:["This value's declaration."]},nm:"declaration"}},tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Get"},{dv:"in",def:{pk:".",nm:"Nothing"},nm:"Set"}],an:{doc:["A value model represents the model of a Ceylon value that you can read and inspect.\n\nA value is a toplevel binding, declared on a package.\n\nThis is a [[ValueModel]] that you can query for a value declaration's current value:\n\n    shared String foo = \"Hello\";\n    \n    void test(){\n        Value<String> val = `foo`;\n        \/\/ This will print: Hello\n        print(val.get());\n    }\n"]},nm:"Value"},MemberClassCallableConstructor:{pa:17,sts:[{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"FunctionModel"},{pk:".",tp:[{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"CallableConstructor"},{mt:"tp",nm:"Container"}],nm:"Qualified"}],mt:"i",$at:{container:{$t:{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"ClassModel"},pa:7,mt:"a",an:{doc:["The class containing this constructor; the type of instances produced \nby this constructor."]},nm:"container"},type:{$t:{pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"},{mt:"tp",pk:".",nm:"Nothing"}],nm:"MemberClass"},pa:7,mt:"a",nm:"type"},declaration:{$t:{pk:"ceylon.language.meta.declaration",nm:"CallableConstructorDeclaration"},pa:7,mt:"a",an:{doc:["This constructor's declaration."]},nm:"declaration"}},$m:{bind:{$t:{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"CallableConstructor"},pa:7,ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"container"}]],mt:"m",nm:"bind"}},tp:[{dv:"in",def:{pk:".",nm:"Nothing"},nm:"Container"},{dv:"out",def:{pk:"$",nm:"Object"},nm:"Type"},{dv:"in",sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{see:["MemberClassValueConstructor"],doc:["A model for a callable constructor of a member class."]},nm:"MemberClassCallableConstructor"},Class:{pa:17,sts:[{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"ClassModel"},{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"Applicable"}],mt:"i",$at:{defaultConstructor:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"CallableConstructor"}]},pa:7,mt:"a",an:{doc:["A model of the default constructor (for a class with constructors) \nor class initializer (for a class with a parameter list), or null\nif the class has constructors, but lacks a default constructor."]},nm:"defaultConstructor"}},$m:{getConstructor:{$t:{comp:"u",l:[{pk:".",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],nm:"CallableConstructor"},{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",tp:[{mt:"tp",nm:"Type"}],nm:"ValueConstructor"}]}]},pa:7,ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],mt:"m",tp:[{sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],nm:"Arguments"}],an:{doc:["The constructor with the given name, or null if this class lacks \na constructor of the given name."]},nm:"getConstructor"}},tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"},{dv:"in",sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Anything"}],nm:"Sequential"}],def:{pk:".",nm:"Nothing"},nm:"Arguments"}],an:{doc:["A class model represents the model of a Ceylon class that you can instantiate and inspect.\n\nA class is a toplevel type, declared on a package.\n\nThis is a [[ClassModel]] that you can also invoke to instantiate new instances of the class:\n\n    shared class Foo(String name){\n        shared String hello => \"Hello \"+name;\n    }\n    \n    void test(){\n        Class<Foo,[String]> c = `Foo`;\n        \/\/ This will print: Hello Stef\n        print(c(\"Stef\").hello);\n    }\n"]},nm:"Class"},StorageException:{super:{pk:"$",nm:"Exception"},pa:1,ps:[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"message"}],mt:"c",$at:{message$hbm0f9:{$t:{pk:"$",nm:"String"},mt:"a",nm:"message"}},an:{doc:["Thrown when you try to read attributes that were not shared nor captured and had no\nphysical storage allocated, so do not exist at runtime.\n\nFor example if you try to read the attribute from this class:\n\n    shared class Foo(){\n        Integer x = 2;\n    }\n\nThis will not work because `x` is neither shared nor captured and so it is just not\nretained in the runtime instances of `Foo`.\n"]},nm:"StorageException"},"$pkg-anns":{tagged:["Metamodel"],by:["Gavin King","Stephane Epardaud","Tom Bentley"],doc:["The Ceylon metamodel closed type and model package.\n\nAs described in the [ceylon.language.meta](..\/index.html) documentation, this package contains all\nthe types that represent Ceylon closed types and models.\n\n### Usage example\n\nThe following code will list all the value declarations in the `ceylon.language` package and print their\ncurrent value:\n\n    Package languagePackage = `package ceylon.language`;\n    ValueDeclaration[] valueDeclarations = languagePackage.members<ValueDeclaration>();\n    Value<Anything>[] valueModels = valueDeclarations*.apply<Anything>();\n    for(val in valueModels){\n        \/\/ skip the nothing value which cannot be read\n        if(val.type != `Nothing`){\n            print(val.get());\n        }\n    }\n\nThe following code will iterate all the class declarations in the `ceylon.language` package that\nare not abstract, anonymous or annotations, and that have no type parameters nor initialiser\nparameters. For each matching class, we will apply it to get a class model which we can then\nuse to instantiate the class and display its instance:\n\n    for(decl in `package ceylon.language`.members<ClassDeclaration>()){\n        if(!decl.abstract \n                && !decl.anonymous \n                && !decl.annotation\n                && decl.parameterDeclarations.empty\n                && decl.typeParameterDeclarations.empty){\n            Class<Object,[]> classModel = decl.classApply<Object,[]>();\n            Object instance = classModel();\n            print(\"Instance of ``decl.name`` is: ``instance``\");\n        }\n    }\n"]},Interface:{pa:17,sts:[{pk:".",tp:[{mt:"tp",nm:"Type"}],nm:"InterfaceModel"}],mt:"i",tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"}],an:{doc:["An interface model that you can inspect."]},nm:"Interface"},MemberInterface:{pa:17,sts:[{pk:".",tp:[{mt:"tp",nm:"Type"}],nm:"InterfaceModel"},{pk:".",tp:[{mt:"tp",nm:"Container"},{mt:"tp",pk:".",tp:[{mt:"tp",nm:"Type"}],nm:"Interface"}],nm:"Member"}],mt:"i",$m:{bind:{$t:{pk:".",tp:[{mt:"tp",nm:"Type"}],nm:"Interface"},pa:7,ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"container"}]],mt:"m",nm:"bind"}},tp:[{dv:"in",def:{pk:".",nm:"Nothing"},nm:"Container"},{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"}],an:{doc:["A member interface model that you can inspect."]},nm:"MemberInterface"}},"$mod-bin":"8.0","$mod-anns":{license:["http:\/\/www.apache.org\/licenses\/LICENSE-2.0.html"],by:["Gavin King","Tom Bentley","Tako Schotanus","Stephane Epardaud","Enrique Zamudio"],doc:["The Ceylon language module containing the core definitions \nreferred to by the [language specification][spec], along \nwith some basic functionality of use to most programs:\n\n- The [[root package|package ceylon.language]] defines \n  general-purpose functionality including support for \n  [[numbers|Numeric]] and [[character strings|String]], \n  [[streams|Iterable]] and [[sequences|Sequential]], \n  [[exceptions|Throwable]], and [[null values|Null]].\n- The Ceylon _metamodel_ is defined in \n  [[package ceylon.language.meta]] and its subpackages \n  [[package ceylon.language.meta.model]] and \n  [[package ceylon.language.meta.declaration]], which\n  define interfaces for interacting with applied types and \n  unapplied type declarations respectively.\n\nThis module defines an abstraction over the basic \nfacilities of the Java or JavaScript virtual machine, \ncontaining only functionality that can be easily \nimplemented on both platforms. Thus, certain functionality, \nfor example, concurrency, for which there is no common\nvirtual machine-agnostic model, is not covered by the\nlanguage module.\n\nThe language module is an implicit dependency of every\nother Ceylon module, and may not be explicitly imported.\n\n[spec]: http:\/\/ceylon-lang.org\/documentation\/current\/spec"]},"ceylon.language.impl":{outerImpl:{super:{pk:"$",nm:"Basic"},pa:1,sts:[{pk:"ceylon.language.serialization",nm:"Outer"}],mt:"o",$at:{string:{$t:{pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"}},$m:{referred:{$t:{pk:"$",nm:"Object"},pa:3,ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"instance"}]],mt:"m",an:{doc:["The outer instance of the given member [[instance]]."]},nm:"referred"}},an:{doc:["Implementation of [[Outer]], in ceylon.language.impl because although \ncompiled user classes depend on it, it is not part of the public API."]},nm:"outerImpl"},rethrow:{$t:{pk:"$",nm:"Anything"},pa:1,ps:[[{$t:{pk:"$",nm:"Throwable"},mt:"prm",nm:"x"}]],$ff:1,mt:"m",an:{by:["Stephane Epardaud"],doc:["Rethrows an exception without declaring it. This is used as a cheap replacement for\nUnsafe.throwException() in our Java Util class, used by the metamodel."]},nm:"rethrow"},ElementImpl:{super:{pk:"$",nm:"Basic"},pa:1,sts:[{pk:"ceylon.language.serialization",nm:"Element"}],ps:[{$t:{pk:"$",nm:"Integer"},pa:3,mt:"prm",nm:"index",$hdn:1}],mt:"c",$at:{string:{$t:{pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"},index:{$t:{pk:"$",nm:"Integer"},pa:3,mt:"a",nm:"index"},hash:{$t:{pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"hash"}},$m:{equals:{$t:{pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],mt:"m",nm:"equals"},referred:{$t:{pk:"$",nm:"Anything"},pa:3,ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"instance"}]],mt:"m",nm:"referred"}},an:{doc:["Implementation of [[Element]], in ceylon.language.impl because although \ncompiled user classes depend on it, it is not part of the public API."]},nm:"ElementImpl"},BaseList:{super:{pk:"$",nm:"Object"},pa:2305,sts:[{pk:"$",tp:[{mt:"tp",nm:"Element"}],nm:"SearchableList"}],mt:"c",tp:[{nm:"Element"}],nm:"BaseList"},MemberImpl:{super:{pk:"$",nm:"Basic"},pa:1,sts:[{pk:"ceylon.language.serialization",nm:"Member"}],ps:[{$t:{pk:"ceylon.language.meta.declaration",nm:"FunctionOrValueDeclaration"},mt:"prm",nm:"attribute"}],mt:"c",$at:{string:{$t:{pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"},attribute:{$t:{pk:"ceylon.language.meta.declaration",nm:"ValueDeclaration"},pa:3,mt:"a",nm:"attribute"},hash:{$t:{pk:"$",nm:"Integer"},pa:3,mt:"g",nm:"hash"}},$m:{equals:{$t:{pk:"$",nm:"Boolean"},pa:3,ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"other"}]],mt:"m",nm:"equals"},referred:{$t:{comp:"u",l:[{pk:"$",nm:"Anything"},{pk:"ceylon.language.serialization",nm:"UninitializedLateValue"}]},pa:3,ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"instance"}]],mt:"m",nm:"referred"}},an:{doc:["Implementation of [[Member]], in ceylon.language.impl because although \ncompiled user classes depend on it, it is not part of the public API."]},nm:"MemberImpl",$cn:{$def:{pa:1,ps:[{$t:{pk:"ceylon.language.meta.declaration",nm:"FunctionOrValueDeclaration"},mt:"prm",nm:"attribute"}]}}},reach:{super:{pk:"$",nm:"Basic"},pa:65,mt:"o",$at:{string:{$t:{pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"}},$m:{getObject:{$t:{pk:"$",nm:"Object"},pa:65,ps:[[{$t:{pk:"$",nm:"Anything"},mt:"prm",nm:"instance"},{$t:{pk:"ceylon.language.serialization",nm:"ReachableReference"},mt:"prm",nm:"ref"}]],mt:"m",nm:"getObject"},references:{$t:{pk:"$",tp:[{mt:"tp",pk:"ceylon.language.serialization",nm:"ReachableReference"}],nm:"Iterator"},pa:65,ps:[[{$t:{pk:"$",nm:"Anything"},mt:"prm",nm:"instance"}]],mt:"m",nm:"references"},getAnything:{$t:{pk:"$",nm:"Anything"},pa:65,ps:[[{$t:{pk:"$",nm:"Anything"},mt:"prm",nm:"instance"},{$t:{pk:"ceylon.language.serialization",nm:"ReachableReference"},mt:"prm",nm:"ref"}]],mt:"m",nm:"getAnything"}},an:{doc:["A native way to find out about the references an instance holds\nand to get an instance."]},nm:"reach"},BaseIterator:{super:{pk:"$",nm:"Object"},pa:257,sts:[{pk:"$",tp:[{mt:"tp",nm:"Element"}],nm:"Iterator"}],mt:"c",tp:[{nm:"Element"}],nm:"BaseIterator"},BaseCharacterList:{super:{pk:"$",nm:"Object"},pa:257,sts:[{pk:"$",tp:[{mt:"tp",pk:"$",nm:"Character"}],nm:"SearchableList"}],mt:"c",nm:"BaseCharacterList"},BaseIterable:{super:{pk:"$",nm:"Object"},pa:257,sts:[{pk:"$",tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"Absent"}],nm:"Iterable"}],mt:"c",tp:[{nm:"Element"},{sts:[{pk:"$",nm:"Null"}],nm:"Absent"}],nm:"BaseIterable"},"$pkg-anns":{by:["Stephane Epardaud"],doc:["The Ceylon private implementation package.\n\nDo not make this package shared!\n\nHere we have a few private helpers implemented in Ceylon, because we can't put Ceylon\ncode in com.redhat.ceylon like we do for Java."]},BaseMap:{super:{pk:"$",nm:"Object"},pa:257,sts:[{pk:"$",tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"Item"}],nm:"Map"}],mt:"c",tp:[{sts:[{pk:"$",nm:"Object"}],nm:"Key"},{nm:"Item"}],nm:"BaseMap"},BaseSequence:{super:{pk:"$",nm:"Object"},pa:2305,sts:[{pk:"$",tp:[{mt:"tp",nm:"Element"}],nm:"Sequence"}],mt:"c",tp:[{nm:"Element"}],nm:"BaseSequence"}},"$mod-name":"ceylon.language"};
//This is quite a special case, since Nothing is not in the model, we need to insert it there
ex$.$CCMM$['ceylon.language']["Nothing"]={mt:"c",an:{"shared":[]},nm:"Nothing"};
});
}(typeof define==='function' && define.amd ? define : function (factory) {
if (typeof exports!=='undefined') { factory(require, exports, module);
} else { throw 'no module loader'; }
}));
