(function(define) { define(function(require, ex$, module) {
ex$.$CCMM$={"ceylon.language.impl":{rethrow:{$t:{pk:"$",nm:"Anything"},pa:1,mt:"m",an:{doc:["Rethrows an exception without declaring it. This is used as a cheap replacement for\nUnsafe.throwException() in our Java Util class, used by the metamodel."],by:["Stephane Epardaud"]},ps:[[{$t:{pk:"$",nm:"Throwable"},mt:"prm",nm:"x"}]],nm:"rethrow"},BaseIterable:{super:{pk:"$",nm:"Object"},pa:257,mt:"c",sts:[{tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"Absent"}],pk:"$",nm:"Iterable"}],tp:[{nm:"Element"},{sts:[{pk:"$",nm:"Null"}],nm:"Absent"}],nm:"BaseIterable"},BaseSequence:{super:{pk:"$",nm:"Object"},pa:257,mt:"c",an:{serializable:[]},sts:[{tp:[{mt:"tp",nm:"Element"}],pk:"$",nm:"Sequence"}],tp:[{nm:"Element"}],nm:"BaseSequence"},BaseCharacterList:{super:{pk:"$",nm:"Object"},pa:257,mt:"c",sts:[{tp:[{mt:"tp",pk:"$",nm:"Character"}],pk:"$",nm:"List"}],nm:"BaseCharacterList"},BaseList:{super:{pk:"$",nm:"Object"},pa:257,mt:"c",an:{serializable:[]},sts:[{tp:[{mt:"tp",nm:"Element"}],pk:"$",nm:"List"}],tp:[{nm:"Element"}],nm:"BaseList"},BaseMap:{super:{pk:"$",nm:"Object"},pa:257,mt:"c",sts:[{tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"Item"}],pk:"$",nm:"Map"}],tp:[{sts:[{pk:"$",nm:"Object"}],nm:"Key"},{sts:[{pk:"$",nm:"Object"}],nm:"Item"}],nm:"BaseMap"},"$pkg-anns":{doc:["The Ceylon private implementation package.\n\nDo not make this package shared!\n\nHere we have a few private helpers implemented in Ceylon, because we can't put Ceylon\ncode in com.redhat.ceylon like we do for Java."],by:["Stephane Epardaud"]},BaseIterator:{super:{pk:"$",nm:"Object"},pa:257,mt:"c",sts:[{tp:[{mt:"tp",nm:"Element"}],pk:"$",nm:"Iterator"}],tp:[{nm:"Element"}],nm:"BaseIterator"}},"$mod-name":"ceylon.language","ceylon.language.meta.declaration":{ClassWithInitializerDeclaration:{pa:17,mt:"i",sts:[{pk:".",nm:"ClassDeclaration"}],$m:{getConstructorDeclaration:{$t:{pk:"$",nm:"Null"},pa:11,mt:"m",ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],nm:"getConstructorDeclaration"},constructorDeclarations:{$t:{pk:"$",nm:"Empty"},pa:11,mt:"m",nm:"constructorDeclarations"},annotatedConstructorDeclarations:{$t:{pk:"$",nm:"Empty"},pa:11,mt:"m",tp:[{sts:[{pk:"$",nm:"Annotation"}],nm:"Annotation"}],nm:"annotatedConstructorDeclarations"}},$at:{defaultConstructorDeclaration:{$t:{pk:"$",nm:"Null"},pa:11,mt:"g",nm:"defaultConstructorDeclaration"}},nm:"ClassWithInitializerDeclaration"},Import:{pa:17,mt:"i",an:{doc:["Model of an `import` declaration \nwithin a module declaration."]},sts:[{pk:"$",nm:"Identifiable"},{pk:"$",nm:"Annotated"}],$at:{shared:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this imported module is shared."]},nm:"shared"},container:{$t:{pk:".",nm:"Module"},pa:5,mt:"a",an:{doc:["The containing module."]},nm:"container"},optional:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this imported module is optional."]},nm:"optional"},name:{$t:{pk:"$",nm:"String"},pa:5,mt:"a",an:{doc:["The name of the imported module."]},nm:"name"},version:{$t:{pk:"$",nm:"String"},pa:5,mt:"a",an:{doc:["The compile-time version of the imported module."]},nm:"version"}},nm:"Import"},Variance:{of:[{pk:".",nm:"invariant"},{pk:".",nm:"covariant"},{pk:".",nm:"contravariant"}],pa:1,mt:"i",an:{doc:["Variance information."]},nm:"Variance"},OpenTypeVariable:{pa:17,mt:"i",an:{doc:["An open type variable."]},sts:[{pk:".",nm:"OpenType"}],$at:{declaration:{$t:{pk:".",nm:"TypeParameter"},pa:5,mt:"a",an:{doc:["This type variable's type parameter declaration."]},nm:"declaration"}},nm:"OpenTypeVariable"},AnnotatedDeclaration:{of:[{pk:".",nm:"NestableDeclaration"},{pk:".",nm:"ConstructorDeclaration"},{pk:".",nm:"Module"},{pk:".",nm:"Package"}],pa:17,mt:"i",an:{doc:["Declaration which can be annotated, such as:\n\n- [[NestableDeclaration]]\n- [[Module]]\n- [[Package]]\n\nYou can query annotations that are placed on a given annotated declaration with:\n\n"]},sts:[{pk:".",nm:"Declaration"},{pk:"$",nm:"Annotated"}],$m:{annotations:{$t:{tp:[{mt:"tp",nm:"Annotation"}],pk:"$",nm:"Sequential"},pa:5,mt:"m",an:{doc:["The annotation instances of the given \nannotation type on this declaration.\n\nFor example, you can list all the [[SeeAnnotations|ceylon.language::SeeAnnotation]] \nannotations on [[List|ceylon.language::List]]\nwith the following code:\n\n    for(annot in `interface List`.annotations<SeeAnnotation>()){\n        for(elems in annot.programElements){\n            print(\"See: ``elems``\");\n        }\n    }\n\nAlternatively, you can use the [[ceylon.language.meta::annotations]] \nfunction.\n"]},tp:[{dv:"out",sts:[{pk:"$",nm:"Annotation"}],nm:"Annotation"}],nm:"annotations"}},nm:"AnnotatedDeclaration"},OpenIntersection:{pa:17,mt:"i",an:{doc:["An open intersection type."]},sts:[{pk:".",nm:"OpenType"}],$at:{satisfiedTypes:{$t:{tp:[{mt:"tp",pk:".",nm:"OpenType"}],pk:"$",nm:"List"},pa:5,mt:"a",an:{doc:["This intersection's list of satisfied open types."]},nm:"satisfiedTypes"}},nm:"OpenIntersection"},OpenType:{of:[{pk:".",nm:"nothingType"},{pk:".",nm:"OpenClassOrInterfaceType"},{pk:".",nm:"OpenTypeVariable"},{pk:".",nm:"OpenUnion"},{pk:".",nm:"OpenIntersection"}],pa:17,mt:"i",an:{doc:["An open type.\n\nAn open type is a type which may contain unbound type variables, such as `List<T>`."]},nm:"OpenType"},SetterDeclaration:{pa:17,mt:"i",an:{doc:["A setter declaration for a variable `ValueDeclaration`."]},sts:[{pk:".",nm:"NestableDeclaration"}],$at:{shared:{$t:{pk:"$",nm:"Boolean"},pa:3,mt:"g",nm:"shared"},containingModule:{$t:{pk:".",nm:"Module"},pa:3,mt:"g",nm:"containingModule"},toplevel:{$t:{pk:"$",nm:"Boolean"},pa:3,mt:"g",nm:"toplevel"},formal:{$t:{pk:"$",nm:"Boolean"},pa:3,mt:"g",nm:"formal"},default:{$t:{pk:"$",nm:"Boolean"},pa:3,mt:"g",nm:"default"},container:{$t:{comp:"u",l:[{pk:".",nm:"NestableDeclaration"},{pk:".",nm:"Package"}]},pa:3,mt:"g",nm:"container"},containingPackage:{$t:{pk:".",nm:"Package"},pa:3,mt:"g",nm:"containingPackage"},actual:{$t:{pk:"$",nm:"Boolean"},pa:3,mt:"g",nm:"actual"},variable:{$t:{pk:".",nm:"ValueDeclaration"},pa:5,mt:"a",an:{doc:["The variable value this setter is for."]},nm:"variable"}},nm:"SetterDeclaration"},InterfaceDeclaration:{pa:17,mt:"i",an:{doc:["An interface declaration.\n\n<a name=\"toplevel-sample\"><\/a>\n### Usage sample for toplevel interfaces\n\nBecause some interfaces have type parameters, getting a model requires applying type arguments to the\ninterface declaration with [[interfaceApply]] in order to be able to get a closed type. For example, here is how you would\nobtain an interface model from a toplevel interface declaration:\n\n    interface Foo<T> satisfies List<T> {\n    }\n    \n    void test(){\n        \/\/ We need to apply the Integer closed type to the Foo declaration in order to get the Foo<Integer> closed type\n        Interface<Foo<Integer>> interfaceModel = `interface Foo`.interfaceApply<Foo<Integer>>(`Integer`);\n        \/\/ This will print: ceylon.language::List<ceylon.language::Integer>\n        for(satisfiedType in interfaceModel.satisfiedTypes){\n            print(satisfiedType);\n        }\n    }\n\n<a name=\"member-sample\"><\/a>\n### Usage sample for member interfaces\n\nFor member interfaces it is a bit longer, because member interfaces need to be applied not only their type arguments but also\nthe containing type, so you should use [[memberInterfaceApply]] and start by giving the containing closed type:\n\n    class Outer(){\n        shared interface Inner<T> satisfies List<T> {\n        }\n    }\n\n    void test(){\n        \/\/ apply the containing closed type `Outer` to the member class declaration `Outer.Inner`\n        MemberInterface<Outer,Outer.Inner<Integer>> memberInterfaceModel = `interface Outer.Inner`.memberInterfaceApply<Outer,Outer.Inner<Integer>>(`Outer`, `Integer`);\n        \/\/ This will print: ceylon.language::List<ceylon.language::Integer>\n        for(satisfiedType in memberInterfaceModel.satisfiedTypes){\n            print(satisfiedType);\n        }\n    }\n"]},sts:[{pk:".",nm:"ClassOrInterfaceDeclaration"}],$m:{interfaceApply:{$t:{tp:[{mt:"tp",nm:"Type"}],pk:"ceylon.language.meta.model",nm:"Interface"},pa:5,mt:"m",an:{throws:["TypeApplicationException","If the specified closed type argument values are not compatible with the actual result's type parameters."],doc:["Applies the given closed type arguments to this toplevel interface declaration in order to obtain an interface model. \nSee [this code sample](#toplevel-sample) for an example on how to use this."]},tp:[{def:{pk:"$",nm:"Anything"},nm:"Type"}],ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"ceylon.language.meta.model",nm:"Type"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"typeArguments"}]],nm:"interfaceApply"},memberInterfaceApply:{$t:{tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"}],pk:"ceylon.language.meta.model",nm:"MemberInterface"},pa:5,mt:"m",an:{throws:["TypeApplicationException","If the specified closed container type or type argument values are not compatible with the actual result's container type or type parameters."],doc:["Applies the given closed container type and type arguments to this member interface declaration in order to obtain a member interface model. \nSee [this code sample](#member-sample) for an example on how to use this."]},tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"}],ps:[[{$t:{tp:[{mt:"tp",pk:"$",nm:"Object"}],pk:"ceylon.language.meta.model",nm:"Type"},mt:"prm",nm:"containerType"},{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"ceylon.language.meta.model",nm:"Type"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"typeArguments"}]],nm:"memberInterfaceApply"}},nm:"InterfaceDeclaration"},Module:{pa:17,mt:"i",an:{doc:["A `module` declaration\nfrom a `module.ceylon` compilation unit"]},sts:[{pk:"$",nm:"Identifiable"},{pk:".",nm:"AnnotatedDeclaration"}],$m:{resourceByPath:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:"$",nm:"Resource"}]},pa:5,mt:"m",an:{doc:["Searches for a resource by its path inside the module."]},ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"path"}]],nm:"resourceByPath"},findImportedPackage:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"Package"}]},pa:5,mt:"m",an:{doc:["Finds a package by name in this module or in its dependencies. Note that all transitive `shared`\ndependencies are searched. Returns `null` if not found."]},ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],nm:"findImportedPackage"},findPackage:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"Package"}]},pa:5,mt:"m",an:{doc:["Finds a package by name. Returns `null` if not found."]},ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],nm:"findPackage"}},$at:{dependencies:{$t:{tp:[{mt:"tp",pk:".",nm:"Import"}],pk:"$",nm:"Sequential"},pa:5,mt:"a",an:{doc:["The modules this module depends on."]},nm:"dependencies"},members:{$t:{tp:[{mt:"tp",pk:".",nm:"Package"}],pk:"$",nm:"Sequential"},pa:5,mt:"a",an:{doc:["The package members of the module."]},nm:"members"},version:{$t:{pk:"$",nm:"String"},pa:5,mt:"a",an:{doc:["The module version."]},nm:"version"}},nm:"Module"},TypeParameter:{pa:17,mt:"i",an:{doc:["A type parameter declaration."]},sts:[{pk:".",nm:"Declaration"}],$at:{caseTypes:{$t:{tp:[{mt:"tp",pk:".",nm:"OpenType"}],pk:"$",nm:"Sequential"},pa:5,mt:"a",an:{doc:["The `of` enumerated bounds for this type parameter."]},nm:"caseTypes"},defaultTypeArgument:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"OpenType"}]},pa:5,mt:"a",an:{doc:["This type parameter's default type argument, if it has one."]},nm:"defaultTypeArgument"},container:{$t:{pk:".",nm:"NestableDeclaration"},pa:5,mt:"a",an:{doc:["The declaration that declared this type parameter. This is either a [[ClassOrInterfaceDeclaration]] or a\n[[FunctionDeclaration]]."]},nm:"container"},variance:{$t:{pk:".",nm:"Variance"},pa:5,mt:"a",an:{doc:["This type parameter's variance, as defined by `in` or `out` keywords."]},nm:"variance"},satisfiedTypes:{$t:{tp:[{mt:"tp",pk:".",nm:"OpenType"}],pk:"$",nm:"Sequential"},pa:5,mt:"a",an:{doc:["The `satisfies` upper bounds for this type parameter."]},nm:"satisfiedTypes"},defaulted:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this type parameter has a default type argument and can be omitted."]},nm:"defaulted"}},nm:"TypeParameter"},FunctionalDeclaration:{pa:17,mt:"i",an:{doc:["Declaration which can be invoked, and may have parameters. Classes, \nconstructors and functions are functional declarations.\n\nNote that multiple-parameter lists are not reified at runtime, so if you\nhave a function declaration like this:\n\n    Integer add(Integer a)(Integer b) => a + b;\n\nIt will only have a single parameter list at runtime (the first), and its return\ntype will be `Callable<Integer,[Integer]>`.\n"]},$m:{getParameterDeclaration:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"FunctionOrValueDeclaration"}]},pa:5,mt:"m",an:{doc:["Gets a parameter declaration by name. Returns `null` if no such parameter exists."]},ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],nm:"getParameterDeclaration"}},$at:{annotation:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if the current declaration is an annotation class or function."]},nm:"annotation"},parameterDeclarations:{$t:{tp:[{mt:"tp",pk:".",nm:"FunctionOrValueDeclaration"}],pk:"$",nm:"Sequential"},pa:5,mt:"a",an:{doc:["The list of parameter declarations for this functional declaration."]},nm:"parameterDeclarations"}},nm:"FunctionalDeclaration"},GenericDeclaration:{pa:17,mt:"i",an:{doc:["A declaration that can have type parameters."]},$m:{getTypeParameterDeclaration:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"TypeParameter"}]},pa:5,mt:"m",an:{doc:["Finds a type parameter by name. Returns `null` if not found."]},ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],nm:"getTypeParameterDeclaration"}},$at:{typeParameterDeclarations:{$t:{tp:[{mt:"tp",pk:".",nm:"TypeParameter"}],pk:"$",nm:"Sequential"},pa:5,mt:"a",an:{doc:["The list of type parameters declared on this generic declaration."]},nm:"typeParameterDeclarations"}},nm:"GenericDeclaration"},invariant:{super:{pk:"$",nm:"Basic"},pa:1,mt:"o",an:{doc:["Invariant means that neither subtype nor supertype can be accepted, the\ntype has to be exactly that which is declared."]},sts:[{pk:".",nm:"Variance"}],$at:{string:{$t:{pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"}},nm:"invariant"},OpenInterfaceType:{pa:17,mt:"i",an:{doc:["An open interface type."]},sts:[{pk:".",nm:"OpenClassOrInterfaceType"}],$at:{declaration:{$t:{pk:".",nm:"InterfaceDeclaration"},pa:7,mt:"a",an:{doc:["This declaration's package container."]},nm:"declaration"}},nm:"OpenInterfaceType"},Package:{pa:17,mt:"i",an:{doc:["Model of a `package` declaration \nfrom a `package.ceylon` compilation unit"]},sts:[{pk:"$",nm:"Identifiable"},{pk:".",nm:"AnnotatedDeclaration"}],$m:{getValue:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"ValueDeclaration"}]},pa:5,mt:"m",an:{doc:["The value with the given name. Returns `null` if not found."]},ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],nm:"getValue"},getAlias:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"AliasDeclaration"}]},pa:5,mt:"m",an:{doc:["The type alias with the given name. Returns `null` if not found."]},ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],nm:"getAlias"},getMember:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{nm:"Kind"}]},pa:5,mt:"m",an:{doc:["Looks up a member declaration by name, provided it satisfies the given `Kind` type\nargument. Returns `null` if no such member matches."]},tp:[{sts:[{pk:".",nm:"NestableDeclaration"}],nm:"Kind"}],ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],nm:"getMember"},getFunction:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"FunctionDeclaration"}]},pa:5,mt:"m",an:{doc:["The function with the given name. Returns `null` if not found."]},ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],nm:"getFunction"},annotatedMembers:{$t:{tp:[{mt:"tp",nm:"Kind"}],pk:"$",nm:"Sequential"},pa:5,mt:"m",an:{doc:["Returns the list of member declarations that satisfy the given `Kind` type argument and\nthat are annotated with the given `Annotation` type argument"]},tp:[{sts:[{pk:".",nm:"NestableDeclaration"}],nm:"Kind"},{sts:[{pk:"$",nm:"Annotation"}],nm:"Annotation"}],nm:"annotatedMembers"},getClassOrInterface:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"ClassOrInterfaceDeclaration"}]},pa:5,mt:"m",an:{doc:["The class or interface with the given name. Returns `null` if not found."]},ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],nm:"getClassOrInterface"},members:{$t:{tp:[{mt:"tp",nm:"Kind"}],pk:"$",nm:"Sequential"},pa:5,mt:"m",an:{doc:["Returns the list of member declarations that satisfy the given `Kind` type argument."]},tp:[{sts:[{pk:".",nm:"NestableDeclaration"}],nm:"Kind"}],nm:"members"}},$at:{shared:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this package is shared."]},nm:"shared"},container:{$t:{pk:".",nm:"Module"},pa:5,mt:"a",an:{doc:["The module this package belongs to."]},nm:"container"}},nm:"Package"},ReferenceDeclaration:{pa:17,mt:"i",sts:[{pk:".",nm:"ValueDeclaration"}],nm:"ReferenceDeclaration"},OpenClassType:{pa:17,mt:"i",an:{doc:["An open class type."]},sts:[{pk:".",nm:"OpenClassOrInterfaceType"}],$at:{declaration:{$t:{pk:".",nm:"ClassDeclaration"},pa:7,mt:"a",an:{doc:["This class declaration."]},nm:"declaration"}},nm:"OpenClassType"},TypedDeclaration:{pa:17,mt:"i",an:{doc:["Declaration which has an open type."]},$at:{openType:{$t:{pk:".",nm:"OpenType"},pa:5,mt:"a",an:{doc:["The open type for this declaration. For example, the open type for `List<T> f<T>()` is `List<T>`."]},nm:"openType"}},nm:"TypedDeclaration"},"$pkg-pa":1,OpenUnion:{pa:17,mt:"i",an:{doc:["An open union type."]},sts:[{pk:".",nm:"OpenType"}],$at:{caseTypes:{$t:{tp:[{mt:"tp",pk:".",nm:"OpenType"}],pk:"$",nm:"List"},pa:5,mt:"a",an:{doc:["The list of case types for this open union type."]},nm:"caseTypes"}},nm:"OpenUnion"},FunctionDeclaration:{pa:17,mt:"i",an:{doc:["A function declaration.\n\n<a name=\"toplevel-sample\"><\/a>\n### Usage sample for toplevel function\n\nBecause some functions have type parameters, getting a model requires applying type arguments to the\nfunction declaration with [[apply]] in order to be able to invoke that function. For example, here is how you would\nobtain a function model that you can invoke from a toplevel function declaration:\n\n    String foo<T>(){\n        return \"Hello, our T is: ``typeLiteral<T>()``\";\n    }\n    \n    void test(){\n        \/\/ We need to apply the Integer closed type to the foo declaration in order to get the foo<Integer> function model\n        Function<String,[]> functionModel = `function foo`.apply<String,[]>(`Integer`);\n        \/\/ This will print: Hello, our T is: ceylon.language::Integer\n        print(functionModel());\n    }\n\n<a name=\"member-sample\"><\/a>\n### Usage sample for methods\n\nFor methods it is a bit longer, because methods need to be applied not only their type arguments but also\nthe containing type, so you should use [[memberApply]] and start by giving the containing closed type:\n\n    class Outer(){\n        shared String hello() => \"Hello\";\n    }\n\n    void test(){\n        \/\/ apply the containing closed type `Outer` to the method declaration `Outer.hello`\n        Method<Outer,String,[]> methodModel = `function Outer.hello`.memberApply<Outer,String,[]>(`Outer`);\n        \/\/ We now have a Method, which needs to be applied to a containing instance in order to become an\n        \/\/ invokable function:\n        Function<String,[]> boundMethodModel = methodModel(Outer());\n        \/\/ This will print: Hello\n        print(boundMethodModel());\n    }\n"]},sts:[{pk:".",nm:"FunctionOrValueDeclaration"},{pk:".",nm:"GenericDeclaration"},{pk:".",nm:"FunctionalDeclaration"}],$m:{apply:{$t:{tp:[{mt:"tp",nm:"Return"},{mt:"tp",nm:"Arguments"}],pk:"ceylon.language.meta.model",nm:"Function"},pa:5,mt:"m",an:{throws:["TypeApplicationException","If the specified closed type argument values are not compatible with the actual result's type parameters."],doc:["Applies the given closed type arguments to this function declaration in order to obtain a function model. \nSee [this code sample](#toplevel-sample) for an example on how to use this."]},tp:[{def:{pk:"$",nm:"Anything"},nm:"Return"},{def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"ceylon.language.meta.model",nm:"Type"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"typeArguments"}]],nm:"apply"},memberInvoke:{$t:{pk:"$",nm:"Anything"},pa:9,mt:"m",an:{throws:["IncompatibleTypeException","If the specified container, type or value arguments are not compatible with this method."],doc:["Invokes the underlying method, by applying the specified type arguments and value arguments."]},ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"container"},{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"ceylon.language.meta.model",nm:"Type"}],pk:"$",nm:"Sequential"},def:1,mt:"prm",nm:"typeArguments"},{$t:{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"arguments"}]],nm:"memberInvoke"},invoke:{$t:{pk:"$",nm:"Anything"},pa:9,mt:"m",an:{throws:["IncompatibleTypeException","If the specified type or value arguments are not compatible with this toplevel function."],doc:["Invokes the underlying toplevel function, by applying the specified type arguments and value arguments."]},ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"ceylon.language.meta.model",nm:"Type"}],pk:"$",nm:"Sequential"},def:1,mt:"prm",nm:"typeArguments"},{$t:{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"arguments"}]],nm:"invoke"},memberApply:{$t:{tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Return"},{mt:"tp",nm:"Arguments"}],pk:"ceylon.language.meta.model",nm:"Method"},pa:5,mt:"m",an:{throws:["TypeApplicationException","If the specified closed container type or type argument values are not compatible with the actual result's container type or type parameters."],doc:["Applies the given closed container type and type arguments to this method declaration in order to obtain a method model. \nSee [this code sample](#member-sample) for an example on how to use this."]},tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Return"},{def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],ps:[[{$t:{tp:[{mt:"tp",pk:"$",nm:"Object"}],pk:"ceylon.language.meta.model",nm:"Type"},mt:"prm",nm:"containerType"},{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"ceylon.language.meta.model",nm:"Type"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"typeArguments"}]],nm:"memberApply"}},nm:"FunctionDeclaration"},NestableDeclaration:{of:[{pk:".",nm:"FunctionOrValueDeclaration"},{pk:".",nm:"ClassOrInterfaceDeclaration"},{pk:".",nm:"SetterDeclaration"},{pk:".",nm:"AliasDeclaration"}],pa:17,mt:"i",an:{doc:["A declaration which can be contained in a [[Package]] or in another [[NestableDeclaration]].\n\nFunctions, values, classes, interfaces and aliases are such declarations."]},sts:[{pk:".",nm:"AnnotatedDeclaration"},{pk:".",nm:"TypedDeclaration"},{pk:".",nm:"Contained"}],$at:{shared:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this declaration is annotated with [[shared|ceylon.language::shared]]."]},nm:"shared"},formal:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this declaration is annotated with [[formal|ceylon.language::formal]]."]},nm:"formal"},default:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this declaration is annotated with [[default|ceylon.language::default]]."]},nm:"default"},actual:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this declaration is annotated with [[actual|ceylon.language::actual]]."]},nm:"actual"}},nm:"NestableDeclaration"},Declaration:{of:[{pk:".",nm:"AnnotatedDeclaration"},{pk:".",nm:"TypeParameter"}],pa:17,mt:"i",an:{doc:["A declaration.\n\nThere are only two types of declarations:\n\n- [[AnnotatedDeclaration]]s such as modules, packages, classes or functions, and\n- [[TypeParameter]] declarations."]},$at:{qualifiedName:{$t:{pk:"$",nm:"String"},pa:5,mt:"a",an:{doc:["The qualified name of this declaration. This includes the container qualified name. For\nexample, the [[Declaration]] class' qualified name is \"ceylon.language.meta.declaration::Declaration\"."]},nm:"qualifiedName"},name:{$t:{pk:"$",nm:"String"},pa:5,mt:"a",an:{doc:["The name of this declaration. For example, the [[Declaration]] class is named \"Declaration\"."]},nm:"name"}},nm:"Declaration"},ClassOrInterfaceDeclaration:{of:[{pk:".",nm:"ClassDeclaration"},{pk:".",nm:"InterfaceDeclaration"}],pa:17,mt:"i",an:{doc:["A class or interface declaration.\n\n<a name=\"toplevel-sample\"><\/a>\n### Usage sample for toplevel classes\n\nBecause some classes have type parameters, getting a model requires applying type arguments to the\nclass declaration with [[apply]] in order to be able to instantiate that class. For example, here is how you would\nobtain a class or interface model that you can instantiate from a toplevel class declaration:\n\n    class Foo<T>() {\n        string => \"Hello, our T is: ``typeLiteral<T>()``\";\n    }\n    \n    void test(){\n        \/\/ We need to apply the Integer closed type to the Foo declaration in order to get the Foo<Integer> closed type\n        ClassOrInterface<Foo<Integer>> classOrInterfaceModel = `class Foo`.apply<Foo<Integer>>(`Integer`);\n        assert(is Class<Foo<Integer>,[]> classOrInterfaceModel);\n        \/\/ This will print: Hello, our T is: ceylon.language::Integer\n        print(classOrInterfaceModel());\n    }\n\nNote that there are more specialised versions of [[apply]] in [[ClassDeclaration.classApply]] and \n[[InterfaceDeclaration.interfaceApply]].\n\n<a name=\"member-sample\"><\/a>\n### Usage sample for member classes\n\nFor member classes or interfaces it is a bit longer, because member types need to be applied not only their type arguments but also\nthe containing type, so you should use [[memberApply]] and start by giving the containing closed type:\n\n    class Outer(){\n        shared class Inner(){\n            string => \"Hello\";\n        }\n    }\n\n    void test(){\n        \/\/ apply the containing closed type `Outer` to the member class declaration `Outer.Inner`\n        value memberClassModel = `class Outer.Inner`.memberApply<Outer,Outer.Inner>(`Outer`);\n        assert(is MemberClass<Outer,Outer.Inner,[]> memberClassModel);\n        \/\/ We now have a MemberClass, which needs to be applied to a containing instance in order to become an\n        \/\/ invokable class model:\n        Class<Outer.Inner,[]> boundMemberClassModel = memberClassModel(Outer());\n        \/\/ This will print: Hello\n        print(boundMemberClassModel());\n    }\n\nNote that there are more specialised versions of [[memberApply]] in [[ClassDeclaration.memberClassApply]] and \n[[InterfaceDeclaration.memberInterfaceApply]].\n"]},sts:[{pk:".",nm:"NestableDeclaration"},{pk:".",nm:"GenericDeclaration"}],$m:{memberDeclarations:{$t:{tp:[{mt:"tp",nm:"Kind"}],pk:"$",nm:"Sequential"},pa:5,mt:"m",an:{doc:["Returns the list of shared member declarations that satisfy the given `Kind` type argument. This includes inherited\ndeclarations but not unshared declarations."]},tp:[{sts:[{pk:".",nm:"NestableDeclaration"}],nm:"Kind"}],nm:"memberDeclarations"},apply:{$t:{tp:[{mt:"tp",nm:"Type"}],pk:"ceylon.language.meta.model",nm:"ClassOrInterface"},pa:5,mt:"m",an:{throws:["TypeApplicationException","If the specified closed type argument values are not compatible with the actual result's type parameters."],doc:["Applies the given closed type arguments to this toplevel class or interface declaration in order to obtain a class or interface model. \nSee [this code sample](#toplevel-sample) for an example on how to use this."]},tp:[{def:{pk:"$",nm:"Anything"},nm:"Type"}],ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"ceylon.language.meta.model",nm:"Type"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"typeArguments"}]],nm:"apply"},getDeclaredMemberDeclaration:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{nm:"Kind"}]},pa:5,mt:"m",an:{doc:["Looks up a member declaration directly declared on this class or interface, by name, \nprovided it satisfies the given `Kind` type argument. Returns `null` if no such member matches. \nThis includes unshared declarations but not inherited declarations."]},tp:[{sts:[{pk:".",nm:"NestableDeclaration"}],nm:"Kind"}],ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],nm:"getDeclaredMemberDeclaration"},memberApply:{$t:{comp:"i",l:[{tp:[{mt:"tp",nm:"Container"},{mt:"tp",tp:[{mt:"tp",nm:"Type"}],pk:"ceylon.language.meta.model",nm:"ClassOrInterface"}],pk:"ceylon.language.meta.model",nm:"Member"},{tp:[{mt:"tp",nm:"Type"}],pk:"ceylon.language.meta.model",nm:"ClassOrInterface"}]},pa:5,mt:"m",an:{throws:["TypeApplicationException","If the specified closed container type or type argument values are not compatible with the actual result's container type or type parameters."],doc:["Applies the given closed container type and type arguments to this member class or interface declaration in order to obtain a \nmember class or interface model. See [this code sample](#member-sample) for an example on how to use this."]},tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"}],ps:[[{$t:{tp:[{mt:"tp",pk:"$",nm:"Object"}],pk:"ceylon.language.meta.model",nm:"Type"},mt:"prm",nm:"containerType"},{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"ceylon.language.meta.model",nm:"Type"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"typeArguments"}]],nm:"memberApply"},annotatedDeclaredMemberDeclarations:{$t:{tp:[{mt:"tp",nm:"Kind"}],pk:"$",nm:"Sequential"},pa:5,mt:"m",an:{doc:["Returns the list of member declarations directly declared on this class or interface, which satisfy the given \n`Kind` type argument and that are annotated with the given `Annotation` type argument.\nThis includes unshared declarations but not inherited declarations."]},tp:[{sts:[{pk:".",nm:"NestableDeclaration"}],nm:"Kind"},{sts:[{pk:"$",nm:"Annotation"}],nm:"Annotation"}],nm:"annotatedDeclaredMemberDeclarations"},annotatedMemberDeclarations:{$t:{tp:[{mt:"tp",nm:"Kind"}],pk:"$",nm:"Sequential"},pa:5,mt:"m",an:{doc:["Returns the list of shared member declarations that satisfy the given `Kind` type argument and\nthat are annotated with the given `Annotation` type argument. This includes inherited\ndeclarations but not unshared declarations."]},tp:[{sts:[{pk:".",nm:"NestableDeclaration"}],nm:"Kind"},{sts:[{pk:"$",nm:"Annotation"}],nm:"Annotation"}],nm:"annotatedMemberDeclarations"},getMemberDeclaration:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{nm:"Kind"}]},pa:5,mt:"m",an:{doc:["Looks up a shared member declaration by name, provided it satisfies the given `Kind` type\nargument. Returns `null` if no such member matches. This includes inherited\ndeclarations but not unshared declarations"]},tp:[{sts:[{pk:".",nm:"NestableDeclaration"}],nm:"Kind"}],ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],nm:"getMemberDeclaration"},declaredMemberDeclarations:{$t:{tp:[{mt:"tp",nm:"Kind"}],pk:"$",nm:"Sequential"},pa:5,mt:"m",an:{doc:["Returns the list of member declarations directly declared on this class or interface, which satisfy the given \n`Kind` type argument. This includes unshared declarations but not inherited declarations."]},tp:[{sts:[{pk:".",nm:"NestableDeclaration"}],nm:"Kind"}],nm:"declaredMemberDeclarations"}},$at:{extendedType:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"OpenClassType"}]},pa:5,mt:"a",an:{doc:["This type's extended type, unless this is the class for [[Anything|ceylon.language::Anything]], which\nis the root of the type hierarchy and thus does not have any extended type."]},nm:"extendedType"},caseTypes:{$t:{tp:[{mt:"tp",pk:".",nm:"OpenType"}],pk:"$",nm:"Sequential"},pa:5,mt:"a",an:{doc:["If this type has an `of` clause, this is the list of case types for the current type."]},nm:"caseTypes"},satisfiedTypes:{$t:{tp:[{mt:"tp",pk:".",nm:"OpenInterfaceType"}],pk:"$",nm:"Sequential"},pa:5,mt:"a",an:{doc:["The list of types satisfied by this type."]},nm:"satisfiedTypes"},isAlias:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this type is an alias type, in which case the [[extendedType]] will \ncontain the substituted type."]},nm:"isAlias"}},nm:"ClassOrInterfaceDeclaration"},ConstructorDeclaration:{pa:17,mt:"i",an:{doc:["A constructor declaration."]},sts:[{pk:".",nm:"FunctionalDeclaration"},{pk:".",nm:"AnnotatedDeclaration"},{pk:".",nm:"TypedDeclaration"},{pk:".",nm:"Contained"}],$at:{shared:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this declaration is annotated with [[shared|ceylon.language::shared]]."]},nm:"shared"},container:{$t:{pk:".",nm:"ClassDeclaration"},pa:7,mt:"a",an:{doc:["The class this constructor constructs"]},nm:"container"},defaultConstructor:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["Whether this constructor declaration is the default constructor"]},nm:"defaultConstructor"}},nm:"ConstructorDeclaration"},Contained:{pa:1,mt:"i",$at:{containingModule:{$t:{pk:".",nm:"Module"},pa:5,mt:"a",an:{doc:["This declaration's module container."]},nm:"containingModule"},toplevel:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this declaration is a toplevel declaration."]},nm:"toplevel"},container:{$t:{comp:"u",l:[{pk:".",nm:"NestableDeclaration"},{pk:".",nm:"Package"}]},pa:5,mt:"a",an:{doc:["This declaration's immediate container, which can be either a [[NestableDeclaration]]\nor a [[Package]]."]},nm:"container"},containingPackage:{$t:{pk:".",nm:"Package"},pa:5,mt:"a",an:{doc:["This declaration's package container."]},nm:"containingPackage"}},nm:"Contained"},OpenClassOrInterfaceType:{of:[{pk:".",nm:"OpenClassType"},{pk:".",nm:"OpenInterfaceType"}],pa:17,mt:"i",an:{doc:["An open class or interface, with open type arguments.\n\nFor example, `List<T>` is an open interface type, with a type argument which is the\n[[OpenTypeVariable]] `T`."]},sts:[{pk:".",nm:"OpenType"}],$at:{extendedType:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"OpenClassType"}]},pa:5,mt:"a",an:{doc:["The extended type of this open type."]},nm:"extendedType"},declaration:{$t:{pk:".",nm:"ClassOrInterfaceDeclaration"},pa:5,mt:"a",an:{doc:["The class or interface declaration for this open type."]},nm:"declaration"},typeArguments:{$t:{tp:[{mt:"tp",pk:".",nm:"TypeParameter"},{mt:"tp",pk:".",nm:"OpenType"}],pk:"$",nm:"Map"},pa:5,mt:"a",an:{doc:["The set of open type arguments."]},nm:"typeArguments"},satisfiedTypes:{$t:{tp:[{mt:"tp",pk:".",nm:"OpenInterfaceType"}],pk:"$",nm:"Sequential"},pa:5,mt:"a",an:{doc:["The satisfied types of this open type."]},nm:"satisfiedTypes"}},nm:"OpenClassOrInterfaceType"},covariant:{super:{pk:"$",nm:"Basic"},pa:1,mt:"o",an:{doc:["Covariant means that subtypes of the given type may be returned."]},sts:[{pk:".",nm:"Variance"}],$at:{string:{$t:{pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"}},nm:"covariant"},nothingType:{super:{pk:"$",nm:"Basic"},pa:1,mt:"o",an:{doc:["The singleton open type for [[Nothing|ceylon.language::nothing]]."]},sts:[{pk:".",nm:"OpenType"}],$at:{string:{$t:{pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"}},nm:"nothingType"},ValueDeclaration:{pa:17,mt:"i",an:{doc:["A value declaration.\n\n<a name=\"toplevel-sample\"><\/a>\n### Usage sample for toplevel value\n\nGetting a model requires applying type arguments to the\nvalue declaration with [[apply]] in order to be able to read that value. For example, here is how you would\nobtain a value model that you can read from a toplevel attribute declaration:\n\n    String foo = \"Hello\";\n    \n    void test(){\n        \/\/ We need to apply the the foo declaration in order to get the foo value model\n        Value<String> valueModel = `value foo`.apply<String>();\n        \/\/ This will print: Hello\n        print(valueModel.get());\n    }\n\n<a name=\"member-sample\"><\/a>\n### Usage sample for attributes\n\nFor attributes it is a bit longer, because attributes need to be applied the containing type, so you should \nuse [[memberApply]] and start by giving the containing closed type:\n\n    class Outer(){\n        shared String foo => \"Hello\";\n    }\n\n    void test(){\n        \/\/ Apply the containing closed type `Outer` to the attribute declaration `Outer.foo`\n        Attribute<Outer,String> valueModel = `value Outer.foo`.memberApply<Outer,String>(`Outer`);\n        \/\/ We now have an Attribute, which needs to be applied to a containing instance in order to become a\n        \/\/ readable value:\n        Value<String> boundValueModel = valueModel(Outer());\n        \/\/ This will print: Hello\n        print(boundValueModel.get());\n    }\n"]},sts:[{pk:".",nm:"FunctionOrValueDeclaration"}],$m:{apply:{$t:{tp:[{mt:"tp",nm:"Get"},{mt:"tp",nm:"Set"}],pk:"ceylon.language.meta.model",nm:"Value"},pa:5,mt:"m",an:{throws:["IncompatibleTypeException","If the specified `Get` or `Set` type arguments are not compatible with the actual result."],doc:["Applies this value declaration in order to obtain a value model. \nSee [this code sample](#toplevel-sample) for an example on how to use this."]},tp:[{def:{pk:"$",nm:"Anything"},nm:"Get"},{def:{pk:".",nm:"Nothing"},nm:"Set"}],nm:"apply"},get:{$t:{pk:"$",nm:"Anything"},pa:9,mt:"m",an:{doc:["Reads the current value of this toplevel value."]},nm:"get"},memberSet:{$t:{pk:"$",nm:"Anything"},pa:5,mt:"m",an:{throws:["IncompatibleTypeException","If the specified container or new value type is not compatible with this attribute."],doc:["Sets the current value of this attribute on the given container instance."]},ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"container"},{$t:{pk:"$",nm:"Anything"},mt:"prm",nm:"newValue"}]],nm:"memberSet"},set:{$t:{pk:"$",nm:"Anything"},pa:9,mt:"m",an:{doc:["Sets the current value of this toplevel value."]},ps:[[{$t:{pk:"$",nm:"Anything"},mt:"prm",nm:"newValue"}]],nm:"set"},memberApply:{$t:{tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Get"},{mt:"tp",nm:"Set"}],pk:"ceylon.language.meta.model",nm:"Attribute"},pa:5,mt:"m",an:{throws:["IncompatibleTypeException","If the specified `Container`, `Get` or `Set` type arguments are not compatible with the actual result."],doc:["Applies the given closed container type to this attribute declaration in order to obtain an attribute model. \nSee [this code sample](#member-sample) for an example on how to use this."]},tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Get"},{def:{pk:".",nm:"Nothing"},nm:"Set"}],ps:[[{$t:{tp:[{mt:"tp",pk:"$",nm:"Object"}],pk:"ceylon.language.meta.model",nm:"Type"},mt:"prm",nm:"containerType"}]],nm:"memberApply"},memberGet:{$t:{pk:"$",nm:"Anything"},pa:9,mt:"m",an:{throws:["IncompatibleTypeException","If the specified container is not compatible with this attribute."],doc:["Reads the current value of this attribute on the given container instance."]},ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"container"}]],nm:"memberGet"}},$at:{setter:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"SetterDeclaration"}]},pa:5,mt:"a",an:{doc:["Returns the setter declaration for this variable.\n\nFor modelling purposes `variable` reference \nvalues have a SetterDeclaration even though there is no \nsuch setter explicit in the source code."]},nm:"setter"},objectClass:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"ClassDeclaration"}]},pa:5,mt:"a",an:{doc:["This value's anonymous class declaration if this value is an object declaration. `null` otherwise."]},nm:"objectClass"},variable:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this declaration is annotated with [[variable|ceylon.language::variable]]."]},nm:"variable"},objectValue:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this declaration is an `object` declaration, whose type is an anonymous class."]},nm:"objectValue"}},nm:"ValueDeclaration"},ClassDeclaration:{of:[{pk:".",nm:"ClassWithInitializerDeclaration"},{pk:".",nm:"ClassWithConstructorsDeclaration"}],pa:17,mt:"i",an:{doc:["Class declaration.\n\n<a name=\"toplevel-sample\"><\/a>\n### Usage sample for toplevel classes\n\nBecause some classes have type parameters, getting a model requires applying type arguments to the\nclass declaration with [[classApply]] in order to be able to instantiate that class. For example, here is how you would\nobtain a class model that you can instantiate from a toplevel class declaration:\n\n    class Foo<T>(){\n        string => \"Hello, our T is: ``typeLiteral<T>()``\";\n    }\n    \n    void test(){\n        \/\/ We need to apply the Integer closed type to the Foo declaration in order to get the Foo<Integer> closed type\n        Class<Foo<Integer>,[]> classModel = `class Foo`.classApply<Foo<Integer>,[]>(`Integer`);\n        \/\/ This will print: Hello, our T is: ceylon.language::Integer\n        print(classModel());\n    }\n\n<a name=\"member-sample\"><\/a>\n### Usage sample for member classes\n\nFor member classes it is a bit longer, because member classes need to be applied not only their type arguments but also\nthe containing type, so you should use [[memberClassApply]] and start by giving the containing closed type:\n\n    class Outer(){\n        shared class Inner(){\n            string => \"Hello\";\n        }\n    }\n\n    void test(){\n        \/\/ apply the containing closed type `Outer` to the member class declaration `Outer.Inner`\n        MemberClass<Outer,Outer.Inner,[]> memberClassModel = `class Outer.Inner`.memberClassApply<Outer,Outer.Inner,[]>(`Outer`);\n        \/\/ We now have a MemberClass, which needs to be applied to a containing instance in order to become an\n        \/\/ invokable class model:\n        Class<Outer.Inner,[]> boundMemberClassModel = memberClassModel(Outer());\n        \/\/ This will print: Hello\n        print(boundMemberClassModel());\n    }\n"]},sts:[{pk:".",nm:"ClassOrInterfaceDeclaration"},{pk:".",nm:"FunctionalDeclaration"}],$m:{getConstructorDeclaration:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"ConstructorDeclaration"}]},pa:5,mt:"m",an:{doc:["Looks up a constructor declaration directly declared on this class, by name. \nReturns `null` if no such constructor matches. \nThis includes unshared constructors but not inherited constructors \n(since constructors are not members)."]},ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],nm:"getConstructorDeclaration"},instantiate:{$t:{pk:"$",nm:"Anything"},pa:9,mt:"m",an:{throws:["IncompatibleTypeException","If the specified type or value arguments are not compatible with this toplevel class."],doc:["Creates a new instance of this toplevel class, by applying the specified type arguments and value arguments."]},ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"ceylon.language.meta.model",nm:"Type"}],pk:"$",nm:"Sequential"},def:1,mt:"prm",nm:"typeArguments"},{$t:{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"arguments"}]],nm:"instantiate"},memberInstantiate:{$t:{pk:"$",nm:"Anything"},pa:9,mt:"m",an:{throws:["IncompatibleTypeException","If the specified container, type or value arguments are not compatible with this method."],doc:["Creates a new instance of this member class, by applying the specified type arguments and value arguments."]},ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"container"},{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"ceylon.language.meta.model",nm:"Type"}],pk:"$",nm:"Sequential"},def:1,mt:"prm",nm:"typeArguments"},{$t:{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"arguments"}]],nm:"memberInstantiate"},memberClassApply:{$t:{tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:"ceylon.language.meta.model",nm:"MemberClass"},pa:5,mt:"m",an:{throws:["TypeApplicationException","If the specified closed container type or type argument values are not compatible with the actual result's container type or type parameters."],doc:["Applies the given closed container type and type arguments to this member class declaration in order to obtain a member class model. \nSee [this code sample](#member-sample) for an example on how to use this."]},tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"},{def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],ps:[[{$t:{tp:[{mt:"tp",pk:"$",nm:"Object"}],pk:"ceylon.language.meta.model",nm:"Type"},mt:"prm",nm:"containerType"},{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"ceylon.language.meta.model",nm:"Type"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"typeArguments"}]],nm:"memberClassApply"},classApply:{$t:{tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:"ceylon.language.meta.model",nm:"Class"},pa:5,mt:"m",an:{throws:["TypeApplicationException","If the specified closed type argument values are not compatible with the actual result's type parameters."],doc:["Applies the given closed type arguments to this toplevel class declaration in order to obtain a class model. \nSee [this code sample](#toplevel-sample) for an example on how to use this."]},tp:[{def:{pk:"$",nm:"Anything"},nm:"Type"},{def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"ceylon.language.meta.model",nm:"Type"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"typeArguments"}]],nm:"classApply"},constructorDeclarations:{$t:{tp:[{mt:"tp",pk:".",nm:"ConstructorDeclaration"}],pk:"$",nm:"Sequential"},pa:5,mt:"m",an:{doc:["Returns the list of constructors declared on this class. This includes unshared constructors."]},nm:"constructorDeclarations"},annotatedConstructorDeclarations:{$t:{tp:[{mt:"tp",pk:".",nm:"ConstructorDeclaration"}],pk:"$",nm:"Sequential"},pa:5,mt:"m",an:{doc:["Returns the list of constructors declared on this class that are annotated with the \ngiven `Annotation` type argument. This includes unshared constructors."]},tp:[{sts:[{pk:"$",nm:"Annotation"}],nm:"Annotation"}],nm:"annotatedConstructorDeclarations"}},$at:{anonymous:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if the class is an anonymous class, as is the case for the class of object value declarations."]},nm:"anonymous"},abstract:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if the class has an [[abstract|ceylon.language::abstract]] annotation."]},nm:"abstract"},final:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if the class has a [[final|ceylon.language::final]] annotation."]},nm:"final"},defaultConstructorDeclaration:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"ConstructorDeclaration"}]},pa:5,mt:"a",an:{doc:["The default constructor declaration of this class. \nReturns null if this class lacks a default constructor.\nThe default constructor is the one with the same name as its \ncontaining class."]},nm:"defaultConstructorDeclaration"},objectValue:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:".",nm:"ValueDeclaration"}]},pa:5,mt:"a",an:{doc:["This anonymous class' object value declaration if this class is an anonymous class. `null` otherwise."]},nm:"objectValue"}},nm:"ClassDeclaration"},contravariant:{super:{pk:"$",nm:"Basic"},pa:1,mt:"o",an:{doc:["Contravariant means that supertypes of the given type may be accepted."]},sts:[{pk:".",nm:"Variance"}],$at:{string:{$t:{pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"}},nm:"contravariant"},ClassWithConstructorsDeclaration:{pa:17,mt:"i",sts:[{pk:".",nm:"ClassDeclaration"}],$m:{instantiate:{$t:{pk:".",nm:"Nothing"},pa:11,mt:"m",ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"ceylon.language.meta.model",nm:"Type"}],pk:"$",nm:"Sequential"},def:1,mt:"prm",nm:"typeArguments"},{$t:{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"arguments"}]],nm:"instantiate"},memberInstantiate:{$t:{pk:".",nm:"Nothing"},pa:11,mt:"m",ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"container"},{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"ceylon.language.meta.model",nm:"Type"}],pk:"$",nm:"Sequential"},def:1,mt:"prm",nm:"typeArguments"},{$t:{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"arguments"}]],nm:"memberInstantiate"}},nm:"ClassWithConstructorsDeclaration"},FunctionOrValueDeclaration:{of:[{pk:".",nm:"FunctionDeclaration"},{pk:".",nm:"ValueDeclaration"}],pa:17,mt:"i",an:{doc:["A function or value declaration."]},sts:[{pk:".",nm:"NestableDeclaration"}],$at:{parameter:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this function or value is a parameter to a [[FunctionalDeclaration]]."]},nm:"parameter"},variadic:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this function or value is a parameter and is variadic (accepts a list of values)."]},nm:"variadic"},defaulted:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"a",an:{doc:["True if this function or value is a parameter and has a default value."]},nm:"defaulted"}},nm:"FunctionOrValueDeclaration"},"$pkg-anns":{doc:["The Ceylon metamodel open type and declaration package.\n\nAs described in the [ceylon.language.meta](..\/index.html) documentation, this package contains all\nthe types that represent Ceylon declarations and open types.\n\n### Usage example\n\nThe following code will list all the classes in the `ceylon.language` package and print their\nextended type:\n\n    for(decl in `package ceylon.language`.members<ClassDeclaration>()){\n        if(exists extendedType = decl.extendedType){\n            print(\"Class ``decl.name`` extends: ``extendedType``\");\n        }else{\n            print(\"Class ``decl.name`` does not extend anything\");\n        }\n    }\n\nThe following code will iterate all the class declarations in the `ceylon.language` package that\nare not abstract, anonymous or annotations, and that have no type parameters nor initialiser\nparameters. For each matching class, we will apply it to get a class model which we can then\nuse to instantiate the class and display its instance:\n\n    for(decl in `package ceylon.language`.members<ClassDeclaration>()){\n        if(!decl.abstract \n                && !decl.anonymous \n                && !decl.annotation\n                && decl.parameterDeclarations.empty\n                && decl.typeParameterDeclarations.empty){\n            Class<Object,[]> classModel = decl.classApply<Object,[]>();\n            Object instance = classModel();\n            print(\"Instance of ``decl.name`` is: ``instance``\");\n        }\n    }\n"],by:["Gavin King","Stephane Epardaud"]},AliasDeclaration:{pa:17,mt:"i",an:{doc:["Type alias declaration. While type aliases are erased (substituted for what they alias is a better term) from every \ndeclaration that uses them during compile-time, the declaration of the type alias is still visible at run-time."]},sts:[{pk:".",nm:"NestableDeclaration"},{pk:".",nm:"GenericDeclaration"}],$at:{extendedType:{$t:{pk:".",nm:"OpenType"},pa:5,mt:"a",an:{doc:["The open type that is substituted by this type alias."]},nm:"extendedType"}},nm:"AliasDeclaration"}},"$mod-version":"1.1.1","ceylon.language.serialization":{RealizableReference:{pa:17,mt:"i",an:{doc:["A reference with sufficient state to realize an instance."]},sts:[{tp:[{mt:"tp",nm:"Instance"}],pk:".",nm:"Reference"}],tp:[{dv:"out",nm:"Instance"}],$m:{reconstruct:{$t:{pk:"$",nm:"Anything"},pa:5,mt:"m",an:{throws:["AssertionError","if there is a problem reconstructing the object\nor any object it references"],doc:["Force reconstruction of the instance."]},nm:"reconstruct"},instance:{$t:{nm:"Instance"},pa:5,mt:"m",an:{throws:["AssertionError","if there is a problem reconstructing the object\nor any object it references"],doc:["The reconstructed instance. This method can force \nreconstruction."]},nm:"instance"}},nm:"RealizableReference"},deserialization:{$t:{pk:".",nm:"DeserializationContext"},pa:65,mt:"m",an:{doc:["A new [[DeserializationContext]]."]},nm:"deserialization"},SerializableReference:{pa:17,mt:"i",an:{doc:["A reference with sufficient state to realize an instance."]},sts:[{tp:[{mt:"tp",nm:"Instance"}],pk:".",nm:"Reference"}],tp:[{dv:"out",nm:"Instance"}],$m:{serialize:{$t:{pk:"$",nm:"Anything"},pa:5,mt:"m",an:{doc:["Records the state of the instance in a deconstructor obtained \nfrom the given function."]},ps:[[{$t:{pk:".",nm:"Deconstructor"},mt:"prm",nm:"deconstructor"}]],nm:"serialize"},instance:{$t:{nm:"Instance"},pa:5,mt:"m",an:{doc:["The instance."]},nm:"instance"}},nm:"SerializableReference"},Deconstructed:{pa:1,mt:"i",an:{doc:["The flattened state of an instance of a class used during deserialization.\n\nThis interface is implemented by a serialization library."]},sts:[{tp:[{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{comp:"u",l:[{pk:"$",nm:"Integer"},{pk:"ceylon.language.meta.declaration",nm:"ValueDeclaration"}]},{comp:"u",l:[{pk:"$",nm:"Anything"},{pk:".",nm:"Nothing"}]}]},{comp:"u",mt:"tp",l:[{pk:"$",nm:"Integer"},{pk:"ceylon.language.meta.declaration",nm:"ValueDeclaration"}]},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{pk:"$",nm:"Anything"},{pk:".",nm:"Nothing"}]},{mt:"tp",pk:"$",nm:"Anything"},{mt:"tp",pk:"$",nm:"Empty"}],pk:"$",nm:"Tuple"}],pk:"$",nm:"Tuple"},{mt:"tp",pk:"$",nm:"Null"}],pk:"$",nm:"Iterable"}],$m:{getValue:{$t:{comp:"u",l:[{nm:"Instance"},{tp:[{mt:"tp",nm:"Instance"}],pk:".",nm:"Reference"}]},pa:5,mt:"m",an:{throws:["AssertionError","if the value is absent"],doc:["The value of the given attribute."]},tp:[{nm:"Instance"}],ps:[[{$t:{pk:"ceylon.language.meta.declaration",nm:"ValueDeclaration"},mt:"prm",nm:"attribute"}]],nm:"getValue"},getOuterInstance:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{tp:[{mt:"tp",nm:"Instance"}],pk:".",nm:"Reference"}]},pa:5,mt:"m",an:{doc:["The outer instance if the class of the instance is a \nmember class, otherwise null."]},tp:[{nm:"Instance"}],nm:"getOuterInstance"},getElement:{$t:{comp:"u",l:[{nm:"Instance"},{tp:[{mt:"tp",nm:"Instance"}],pk:".",nm:"Reference"}]},pa:5,mt:"m",an:{doc:["The array element at the given index."]},tp:[{nm:"Instance"}],ps:[[{$t:{pk:"$",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getElement"}},nm:"Deconstructed"},serialization:{$t:{pk:".",nm:"SerializationContext"},pa:65,mt:"m",an:{doc:["A new [[SerializationContext]]."]},nm:"serialization"},DeserializableReference:{pa:17,mt:"i",an:{doc:["A stateless reference to an instance that can be deserialized to \nproduce a [[RealizableReference]]."]},sts:[{tp:[{mt:"tp",nm:"Instance"}],pk:".",nm:"Reference"}],tp:[{dv:"out",nm:"Instance"}],$m:{deserialize:{$t:{tp:[{mt:"tp",nm:"Instance"}],pk:".",nm:"RealizableReference"},pa:5,mt:"m",an:{doc:["Associate the given [[state|deconstructed]] with the instance, \nreturning a [[RealizableReference]]."]},ps:[[{$t:{pk:".",nm:"Deconstructed"},mt:"prm",nm:"deconstructed"}]],nm:"deserialize"}},nm:"DeserializableReference"},Deconstructor:{pa:1,mt:"i",an:{doc:["Contract for flattening the state of an instance of a class when the \ninstance is being serialized.\n \nThis interface is implemented by a serialization library."]},$m:{putValue:{$t:{pk:"$",nm:"Anything"},pa:5,mt:"m",an:{throws:["AssertionError","if there is already a value for the given attribute"],doc:["Add the value of the given attribute to the flattened state."]},tp:[{nm:"Instance"}],ps:[[{$t:{pk:"ceylon.language.meta.declaration",nm:"ValueDeclaration"},mt:"prm",nm:"attribute"},{$t:{nm:"Instance"},mt:"prm",nm:"referenced"}]],nm:"putValue"},putElement:{$t:{pk:"$",nm:"Anything"},pa:5,mt:"m",an:{doc:["Add an array element to the flattened state."]},tp:[{nm:"Instance"}],ps:[[{$t:{pk:"$",nm:"Integer"},mt:"prm",nm:"index"},{$t:{nm:"Instance"},mt:"prm",nm:"referenced"}]],nm:"putElement"},putOuterInstance:{$t:{pk:"$",nm:"Anything"},pa:5,mt:"m",an:{doc:["Add the given `outer` instance (for an instance of a member class) \nto the flattened state."]},tp:[{nm:"Instance"}],ps:[[{$t:{nm:"Instance"},mt:"prm",nm:"outerInstance"}]],nm:"putOuterInstance"}},nm:"Deconstructor"},Reference:{pa:17,mt:"i",an:{doc:["A reference to an instance of a class, with a certain \n[[identifer|id]]."]},tp:[{dv:"out",nm:"Instance"}],$at:{id:{$t:{pk:"$",nm:"Object"},pa:5,mt:"a",an:{doc:["The unique identifier of the instance."]},nm:"id"},clazz:{$t:{tp:[{mt:"tp",nm:"Instance"},{mt:"tp",pk:"ceylon.language.meta.model",nm:"Nothing"}],pk:"ceylon.language.meta.model",nm:"ClassModel"},pa:5,mt:"a",an:{doc:["The class of the instance."]},nm:"clazz"}},nm:"Reference"},SerializationContext:{pa:17,mt:"i",an:{doc:["A context representing serialization of many objects to a \nsingle output stream. \n\nThe serialization library obtains an instance by calling \n[[serialization]] and then  \n[[registers|reference]] the objects to be serialized, \nassigning them each a unique identifier. Then, the \nserialization library is responsible for iterating the \ninstances registered with the context and persisting their \n[[deconstructed states|Deconstructed]] to the output \nstream.\n"]},sts:[{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"SerializableReference"},{mt:"tp",pk:"$",nm:"Null"}],pk:"$",nm:"Iterable"}],$m:{iterator:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"SerializableReference"}],pk:"$",nm:"Iterator"},pa:7,mt:"m",an:{doc:["An iterator over each of the objects which have \nbeen [[registered|reference]] with this context."]},nm:"iterator"},getReference:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{tp:[{mt:"tp",nm:"Instance"}],pk:".",nm:"SerializableReference"}]},pa:5,mt:"m",an:{doc:["The reference for the given (previously [[registered|reference]]) instance, \nor null if the given instance has not been [[registered|reference]]."]},tp:[{nm:"Instance"}],ps:[[{$t:{nm:"Instance"},mt:"prm",nm:"instance"}]],nm:"getReference"},reference:{$t:{tp:[{mt:"tp",nm:"Instance"}],pk:".",nm:"SerializableReference"},pa:5,mt:"m",an:{throws:["AssertionError","if there is already an instance with the given\nidentifier"],doc:["Create a reference to the given [[instance]], assigning it \nthe given [[identifer|id]]."]},tp:[{nm:"Instance"}],ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"id"},{$t:{nm:"Instance"},mt:"prm",nm:"instance"}]],nm:"reference"}},nm:"SerializationContext"},"$pkg-anns":{doc:["The Ceylon serialization infrastructure.\n\nThis package provides an API for *serialization libraries* to\nprovide their own serialization APIs to client code. It does not \nprovide a serialization service itself.\n\nA serialization library will typically implement some kind of \nserializer and deserializer pair using the facilities of this API. \nA *serializer* would take one or many Ceylon instances and serialize them \n(and the instances reachable from them) to \nsome external representation, usually bytes or text in some specific format. \nA *deserializer* would do the reverse, constructing a graph of \nCeylon instances from some external representation. \n \n## Responsibilities\n\nThis API:\n\n* provides a way to walk the graph of instances added for serialization, \n  including those reachable via non-`shared` attributes,\n* copes with shared references and cyclic references in object graphs,\n* prevents access to uninitialized and partially initialized instances \n  during deserialization.  \n  (this includes instances reachable from other instances, transitively).\n  \nThe API cannot prevent serialization libraries from obtaining access to \nnon-`shared` state of instances (loss of encapsulation is \nan inevitable part of serialization).\n  \nA serializer provided by a serialization library:\n\n* obtains a [[SerializationContext]] by \n  calling [[serialization]] ,\n* is responsible for [[SerializationContext.reference|adding]] instances to the \n  `SerializationContext`, including instances reachable from those \n  explicitly added by the client, according to library-specific rules\n* then iterates over the [[SerializableReferences]] in \n  the `SerializationContext` generating the external representation \n\nClient code will interact with the abstractions \nprovided by the serialization library in order to add instances to \nbe serialized.\n  \nA deserializer provided by a serialization library:\n\n* obtains a [[DeserializationContext]] by \n  calling [[deserialization]]\n* [[DeserializationContext.reference|registers]] all the \n  deconstructed instances required for complete deserialization\n  of an instance (including its reachable references) by inspecting \n  the information in external representation.\n* then [[DeserializableReference.deserialize|deserializes]] instances \n  by providing a [[Deconstructed]] which yields the \n  serialized state of each instance,\n* finally obtains a reference to the reconstructed instance using \n  [[RealizableReference.instance]].\n \n## Serializability\n\n*Serializability* is whether or not a particular serialization library can \nserialize and deserialized a particular instance. \n\nInstances of classes which are annotated [[serializable]] are able to record \ntheir state to a [[Deconstructor]] during serialization, \nand initialize their state from a [[Deconstructed]] during deserialization.\nHowever, that does not imply that every serialization library \ncan necessarily serialize instances of every `serializable` class.\n  \nThe serializability of an instance can depend on:\n\n* the class of the instance, and its super classes\n* the serializability of the outer instance(s), if the object is an \n  instance of a member class.  \n* the serialization library's support for serializing generic classes, \n  and member classes,\n* the serialization library's support for serializing anonymous objects\n  (such as `true`, `null` or `smaller`).\n  \nThe deserializability of an instance can depend on:\n\n* The runtime availability and compatibility of the class of the instances, \n  and its super classes, for each instance in the object graph. "],by:["Gavin","Tom"]},"$pkg-pa":1,DeserializationContext:{pa:17,mt:"i",an:{doc:["A context representing deserialization of many objects from\na given input stream. \n\nThe serialization library obtains an instance by calling \n[[deserialization]] and is then \nresponsible for processing the stream and registering the\n[[deconstructed instances|reference]] with the context.\nThe \n[[Deconstructed state|Deconstructed]] of each instance \ncan be [[supplied|ceylon.language.serialization::DeserializableReference.deserialize]]\nto its reference and finally a complete \n[[instance|ceylon.language.serialization::RealizableReference.instance]], can be obtained \nand returned to the client.\n"]},sts:[{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"Reference"},{mt:"tp",pk:"$",nm:"Null"}],pk:"$",nm:"Iterable"}],$m:{getReference:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{tp:[{mt:"tp",nm:"Instance"}],pk:".",nm:"Reference"}]},pa:5,mt:"m",an:{doc:["Obtain the reference previously registered with the given id, or null\nif the given id has not been registered."]},tp:[{nm:"Instance"}],ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"id"}]],nm:"getReference"},memberReference:{$t:{tp:[{mt:"tp",nm:"Instance"}],pk:".",nm:"Reference"},pa:5,mt:"m",an:{doc:["Obtain a reference to the instance of [[MemberClass]] with \nthe given [[identifer|id]] and outer instance reference."]},tp:[{nm:"Outer"},{nm:"Instance"}],ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",an:{doc:["The id of the instance."]},nm:"id"},{$t:{tp:[{mt:"tp",nm:"Outer"},{mt:"tp",nm:"Instance"},{mt:"tp",pk:"ceylon.language.meta.model",nm:"Nothing"}],pk:"ceylon.language.meta.model",nm:"MemberClass"},mt:"prm",an:{doc:["The class of the instance."]},nm:"clazz"},{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{tp:[{mt:"tp",nm:"Outer"}],pk:".",nm:"Reference"}]},mt:"prm",an:{doc:["A reference to the outer instance if the the \n[[clazz]]."]},nm:"outerReference"}]],nm:"memberReference"},reference:{$t:{tp:[{mt:"tp",nm:"Instance"}],pk:".",nm:"Reference"},pa:5,mt:"m",an:{doc:["Obtain a reference to the instance of toplevel [[Class]] with \nthe given [[identifer|id]]."]},tp:[{nm:"Instance"}],ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",an:{doc:["The id of the instance."]},nm:"id"},{$t:{tp:[{mt:"tp",nm:"Instance"},{mt:"tp",pk:"ceylon.language.meta.model",nm:"Nothing"}],pk:"ceylon.language.meta.model",nm:"Class"},mt:"prm",an:{doc:["The class of the instance."]},nm:"clazz"}]],nm:"reference"}},nm:"DeserializationContext"}},"$mod-anns":{doc:["The Ceylon language module containing the core definitions \nreferred to by the [language specification][spec], along \nwith some basic functionality of use to most programs:\n\n- The [[root package|package ceylon.language]] defines \n  general-purpose functionality including support for \n  [[numbers|Numeric]] and [[character strings|String]], \n  [[streams|Iterable]] and [[sequences|Sequential]], \n  [[exceptions|Throwable]], and [[null values|Null]].\n- The Ceylon _metamodel_ is defined in \n  [[package ceylon.language.meta]] and its subpackages \n  [[package ceylon.language.meta.model]] and \n  [[package ceylon.language.meta.declaration]], which\n  define interfaces for interacting with applied types and \n  unapplied type declarations respectively.\n\nThis module defines an abstraction over the basic \nfacilities of the Java or JavaScript virtual machine, \ncontaining only functionality that can be easily \nimplemented on both platforms. Thus, certain functionality, \nfor example, concurrency, for which there is no common\nvirtual machine-agnostic model, is not covered by the\nlanguage module.\n\nThe language module is an implicit dependency of every\nother Ceylon module, and may not be explicitly imported.\n\n[spec]: http:\/\/ceylon-lang.org\/documentation\/current\/spec"],by:["Gavin King","Tom Bentley","Tako Schotanus","Stephane Epardaud","Enrique Zamudio"],license:["http:\/\/www.apache.org\/licenses\/LICENSE-2.0.html"]},"ceylon.language.meta":{sequencedAnnotations:{$t:{tp:[{mt:"tp",nm:"Value"}],pk:"$",nm:"Sequential"},pa:1,mt:"m",an:{doc:["The values of given sequenced annotation type on the given program element, \nor empty if the program element was not annotated with that annotation type.\nFor example:\n\n    \/\/ Does the sum declaration have any ThrownException annotations?\n    value throwsSomething = sequencedAnnotation(`ThrownException`, `function sum`) nonempty;\n\nThe annotations may be returned in any order.\n"]},tp:[{sts:[{tp:[{mt:"tp",nm:"Value"},{mt:"tp",nm:"ProgramElement"},{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"SequencedAnnotation"}],nm:"Value"},{dv:"in",sts:[{pk:"$",nm:"Annotated"}],nm:"ProgramElement"}],ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Value"},{mt:"tp",nm:"ProgramElement"},{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"SequencedAnnotation"},{mt:"tp",pk:"ceylon.language.meta.model",nm:"Nothing"}],pk:"ceylon.language.meta.model",nm:"Class"},mt:"prm",nm:"annotationType"},{$t:{nm:"ProgramElement"},mt:"prm",nm:"programElement"}]],nm:"sequencedAnnotations"},optionalAnnotation:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{nm:"Value"}]},pa:1,mt:"m",an:{doc:["The value of given optional annotation type on the given program element, \nor null if the program element was not annotated with that annotation type.\nFor example:\n\n    \/\/ Does the process declaration have the Shared annotation?\n    value isShared = optionalAnnotation(`Shared`, `value process`) exists;\n"]},tp:[{sts:[{tp:[{mt:"tp",nm:"Value"},{mt:"tp",nm:"ProgramElement"},{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"OptionalAnnotation"}],nm:"Value"},{dv:"in",sts:[{pk:"$",nm:"Annotated"}],nm:"ProgramElement"}],ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Value"},{mt:"tp",nm:"ProgramElement"},{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"OptionalAnnotation"},{mt:"tp",pk:"ceylon.language.meta.model",nm:"Nothing"}],pk:"ceylon.language.meta.model",nm:"Class"},mt:"prm",nm:"annotationType"},{$t:{nm:"ProgramElement"},mt:"prm",nm:"programElement"}]],nm:"optionalAnnotation"},typeLiteral:{$t:{tp:[{mt:"tp",nm:"Type"}],pk:"ceylon.language.meta.model",nm:"Type"},pa:65,mt:"m",an:{doc:["Functional equivalent to type literals. Allows you to get a closed type instance\nfor a given type argument.\n\nFor example:\n\n    assert(is Interface<List<Integer>> listOfIntegers = typeLiteral<List<Integer>>());\n"]},tp:[{dv:"out",sts:[{pk:"$",nm:"Anything"}],nm:"Type"}],nm:"typeLiteral"},annotations:{$t:{nm:"Values"},pa:65,mt:"m",an:{doc:["The annotations of the [[given type|annotationType]] \napplied to the [[given program element|programElement]]. \nFor example:\n\n    \/\/ Does the process declaration have any annotations\n    \/\/ of type SharedAnnotation?\n    value isShared = annotations(`SharedAnnotation`, `value process`) exists;\n\nThe annotations may be returned in any order."]},tp:[{sts:[{tp:[{mt:"tp",nm:"Value"},{mt:"tp",nm:"Values"},{mt:"tp",nm:"ProgramElement"},{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"ConstrainedAnnotation"}],nm:"Value"},{nm:"Values"},{dv:"in",sts:[{pk:"$",nm:"Annotated"}],nm:"ProgramElement"}],ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Value"},{mt:"tp",nm:"Values"},{mt:"tp",nm:"ProgramElement"},{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"ConstrainedAnnotation"},{mt:"tp",pk:"ceylon.language.meta.model",nm:"Nothing"}],pk:"ceylon.language.meta.model",nm:"Class"},mt:"prm",nm:"annotationType"},{$t:{nm:"ProgramElement"},mt:"prm",nm:"programElement"}]],nm:"annotations"},type:{$t:{tp:[{mt:"tp",nm:"Type"},{mt:"tp",pk:".",nm:"Nothing"}],pk:"ceylon.language.meta.model",nm:"ClassModel"},pa:65,mt:"m",an:{doc:["Returns the closed type and model of a given instance. Since only classes\ncan be instantiated, this will always be a [[ClassModel]] model."]},tp:[{dv:"out",sts:[{pk:"$",nm:"Anything"}],nm:"Type"}],ps:[[{$t:{nm:"Type"},mt:"prm",nm:"instance"}]],nm:"type"},modules:{super:{pk:"$",nm:"Basic"},pa:65,mt:"o",an:{doc:["Represents the list of Ceylon modules currently loaded at runtime.\n\nNote that this contains all loaded modules, including those that are\nnot imported by your module.\n\nSince Ceylon supports module isolation at runtime, it is possible that\nthere are more than one version of a given module loaded at the same time.\n\n### Usage example\n\nHere's how you would iterate all the loaded modules and print their name and version:\n\n    import ceylon.language.meta { modules }\n\n    for(mod in modules.list){\n        print(\"Module: ``mod.name``\/``mod.version``\");\n    }\n"]},$m:{find:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:"ceylon.language.meta.declaration",nm:"Module"}]},pa:65,mt:"m",an:{doc:["Finds a module by name and version, returns `null` if not found."]},ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"},{$t:{pk:"$",nm:"String"},mt:"prm",nm:"version"}]],nm:"find"}},$at:{default:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{pk:"ceylon.language.meta.declaration",nm:"Module"}]},pa:65,mt:"a",an:{doc:["Returns the default module, if there is one. This is only the case when\nyou are running the default module."]},nm:"default"},list:{$t:{tp:[{mt:"tp",pk:"ceylon.language.meta.declaration",nm:"Module"}],pk:"$",nm:"Sequential"},pa:65,mt:"a",an:{doc:["Returns the list of all currently loaded modules. This may include modules that\nwere not imported directly but your module, and multiple versions of the same\nmodule."]},nm:"list"}},nm:"modules"},"$pkg-anns":{doc:["The Ceylon metamodel base package.\n\nThe Ceylon metamodel allows you to: \n\n* dynamically inspect modules, packages, functions, values and types, \n* invoke functions and class initialisers, or read and write values, and\n* inspect the annotations on program elements.\n\n### A little bit of terminology\n\nThere are a few concepts and terms in the Ceylon metamodel API that you should be familiar with:\n\n- A _declaration_ is the definition of a Ceylon construct, such as a module, package, value, function\n  or class. Declarations are singletons: there is only a single instance of a given class declaration,\n  for example. You can inspect declarations to get information about how they were defined by their\n  author. You cannot directly invoke function or class declarations, but you can _apply_ them to get\n  a _model_ that you can invoke.\n- A _model_ is a Ceylon definition that represents a declaration where all the type variables have\n  been bound to _closed type_ values. You can query models for their member models and you can directly\n  invoke models.\n- A _closed type_ is a type which does not contain any unbound type variables.\n- An _open type_ is a type which may contain unbound type variables.\n\nFor example, given the following Ceylon program:\n\n    shared abstract class MyList<T>() satisfies List<T>{}\n\nThe declaration of `MyList` represents the class declaration and contains the information that it is\n`abstract` and that it satisfies the `List<T>` open type. That type is open because it contains an\nunbound type variable `T`, which is not bound when we inspect the `MyList` class declaration.\n\nGiven an particular instance of `MyList`, we can query its (closed) type with the [[type]] function,\nand we obtain a closed type representing (for example) `MyList<Integer>`. Object instances necessarily\nhave a closed type at runtime, since in order to instantiate an object, all type arguments must be\nprovided and known during instantiation, so the type of an object instance at runtime is necessarily\na closed type: they cannot contain unbound type variables.\n\nClosed types that represent class or interfaces are also models. For example, the closed type of our\n`MyList<Integer>` instance is both a closed type and a class model: you can query its satisfied types\nand find that it satisfies `List<Integer>` closed type and model (as opposed to the class declaration\nof `MyList` which satisfies the `List<T>` open type). You can also invoke that model to obtain a new\ninstance of `MyList<Integer>`.\n\n### Model and declaration literals\n\nCeylon supports getting declaration values using either the declaration API or using declaration\nliterals:\n\n- <code>\\`module ceylon.file\\`<\/code> returns the [[Module|ceylon.language.meta.declaration::Module]] \n  declaration which corresponds to the `ceylon.file` module you imported in your module descriptor.\n- <code>\\`package ceylon.language.meta\\`<\/code> returns the [[Package|ceylon.language.meta.declaration::Package]]\n  declaration from your current module imports.\n- <code>\\`interface List\\`<\/code> returns the [[InterfaceDeclaration|ceylon.language.meta.declaration::InterfaceDeclaration]] \n  for the [[List|ceylon.language::List]] type.\n- <code>\\`class Integer\\`<\/code> returns the [[ClassDeclaration|ceylon.language.meta.declaration::ClassDeclaration]] \n  for the [[Integer|ceylon.language::Integer]] type.\n- <code>\\`function type\\`<\/code> returns the [[FunctionDeclaration|ceylon.language.meta.declaration::FunctionDeclaration]] \n  for the [[type]] function. Similarly <code>\\`function List.shorterThan\\`<\/code> for methods.\n- <code>\\`value modules\\`<\/code> returns the [[ValueDeclaration|ceylon.language.meta.declaration::ValueDeclaration]] \n  for the [[modules]] value. Similarly <code>\\`function List.size\\`<\/code> for attributes.\n- <code>\\`alias AliasName\\`<\/code> returns the [[AliasDeclaration|ceylon.language.meta.declaration::AliasDeclaration]]\n  for the `AliasName` type alias. \n- <code>\\`given T\\`<\/code> returns the [[TypeParameter|ceylon.language.meta.declaration::TypeParameter]] \n  for the `T` type parameter.\n\nNote that declaration literals cannot have type arguments specified on types or methods, as declarations are not types.\n\nYou can also get access to closed types and model using either the model API or using literals: \n\n- <code>\\`List&lt;Integer>\\`<\/code> returns the [[Interface|ceylon.language.meta.model::Interface]] model and \n  closed type for the [[List|ceylon.language::List]] type applied with the [[Integer|ceylon.language::Integer]] type argument.\n- <code>\\`Integer\\`<\/code> returns the [[Class|ceylon.language.meta.model::Class]] model and closed type \n  for the [[Integer|ceylon.language::Integer]] type.\n- <code>\\`type&lt;Integer>\\`<\/code> returns the [[Function|ceylon.language.meta.model::Function]] model \n  for the [[type]] function applied with the [[Integer|ceylon.language::Integer]] type argument.\n  Similarly <code>\\`List&lt;Integer>.shorterThan\\`<\/code> for method models.\n- <code>\\`modules\\`<\/code> returns the [[Value|ceylon.language.meta.model::Value]] model \n  for the [[modules]] value. Similarly <code>\\`List&lt;Integer>.size\\`<\/code> for attribute models.\n- <code>\\`A & B\\`<\/code> returns a [[IntersectionType|ceylon.language.meta.model::IntersectionType]]\n  for the `A & B` intersection type.\n- <code>\\`A | B\\`<\/code> returns a [[UnionType|ceylon.language.meta.model::UnionType]]\n  for the `A | B` union type.\n- <code>\\`T\\`<\/code> returns a [[Type|ceylon.language.meta.model::Type]] representing the runtime type \n  argument value for the `T` type parameter.\n\nNotice that all model and close type literals must be applied with all required type arguments.\n\n### Accessing the metamodel using the API\n\nAside from declaration and model literals there are several ways you can start using the metamodel API:\n\n- The [[modules]] object contains a list of all currently loaded [[Module|ceylon.language.meta.declaration::Module]]\n  declarations. Note that these contain even modules you did not import as it contains all transitive\n  dependencies, and may contain multiple different versions of the same module.\n- The [[type]] function will return the closed type of the given instance, which can only be a\n  [[ClassModel|ceylon.language.meta.model::ClassModel]] since only classes can be instantiated.\n- The [[typeLiteral]] function is the functional equivalent to closed type literals: it turns a type argument\n  value into a metamodel closed type.\n- The [declaration](declaration\/index.html) package contains all the declaration and open types.\n- The [model](model\/index.html) package contains all the model and closed types.\n\n### Inspecting annotations\n\nConstrained annotations can be inspected using the [[annotations]] \nfunction, like this:\n\n    \/\/ Does the process declaration have the Shared annotation?\n    value isShared = annotations(`Shared`, `value process`) exists;\n\nor the related [[optionalAnnotation]] and [[sequencedAnnotations]] functions.\n\nNote that annotations are queried for via their \n[[ceylon.language::Annotation]] type, \nnot by the annotation constructor which was used to annotate \nthe program element.\n"],by:["Gavin King","Stephane Epardaud"]},"$pkg-pa":1},"ceylon.language.meta.model":{Member:{pa:17,mt:"i",an:{doc:["Model for members that can be bound to a containing instance to turn them into toplevel models.\n\nYou can bind a member to an instance by invoking that member with the instance as parameter:\n\n    shared class Outer(String name){\n        shared class Inner(){\n            shared String hello => \"Hello \"+name;\n        }\n    }\n    \n    void test(){\n        Member<Outer,Class<Outer.Inner,[]>> memberClass = `Outer.Inner`;\n        Class<Outer.Inner,[]> c = memberClass(Outer(\"Stef\"));\n        \/\/ This will print: Hello Stef\n        print(c().hello);\n    }\n"]},sts:[{tp:[{mt:"tp",nm:"Kind"},{mt:"tp",nm:"Container"}],pk:".",nm:"Qualified"}],tp:[{dv:"in",def:{pk:".",nm:"Nothing"},nm:"Container"},{dv:"out",def:{pk:".",nm:"Model"},sts:[{pk:".",nm:"Model"}],nm:"Kind"}],$at:{declaringType:{$t:{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"Type"},pa:5,mt:"a",an:{doc:["The declaring closed type. This is the type that declared this member."]},nm:"declaringType"}},nm:"Member"},Model:{of:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"ClassOrInterface"},{tp:[{mt:"tp",pk:"$",nm:"Anything"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"FunctionModel"},{tp:[{mt:"tp",pk:"$",nm:"Anything"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"ValueModel"}],pa:17,mt:"i",an:{doc:["The root of all models. There are several types of models:\n\n- [[ClassOrInterface]]\n- [[FunctionModel]]\n- [[ValueModel]]\n"]},sts:[{pk:".",nm:"Declared"}],$at:{declaration:{$t:{pk:"ceylon.language.meta.declaration",nm:"NestableDeclaration"},pa:7,mt:"a",an:{doc:["The declaration for this model."]},nm:"declaration"},container:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"Type"}]},pa:7,mt:"a",an:{doc:["The container type of this model, or `null` if this is a toplevel model."]},nm:"container"}},nm:"Model"},InterfaceModel:{pa:17,mt:"i",an:{doc:["An interface model represents the model of a Ceylon interface that you can inspect.\n\nAn interface model can be either a toplevel [[Interface]] or a member [[MemberInterface]].\n"]},sts:[{tp:[{mt:"tp",nm:"Type"}],pk:".",nm:"ClassOrInterface"}],tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"}],$at:{declaration:{$t:{pk:"ceylon.language.meta.declaration",nm:"InterfaceDeclaration"},pa:7,mt:"a",nm:"declaration"}},nm:"InterfaceModel"},Method:{pa:17,mt:"i",an:{doc:["A function model represents the model of a Ceylon function that you can invoke and inspect.\n\nA method is a member function: it is declared on classes or interfaces.\n\nThis is both a [[FunctionModel]] and a [[Member]]: you can invoke it with an instance value\nto bind it to that instance and obtain a [[Function]]:\n\n    class Outer(){\n        shared String foo(String name) => \"Hello \"+name;\n    }\n    \n    void test(){\n        Method<Outer,String,[String]> method = `Outer.foo`;\n        \/\/ Bind it to an instance value\n        Function<String,[String]> f = method(Outer());\n        \/\/ This will print: Hello Stef\n        print(f(\"Stef\"));\n    }\n"]},sts:[{tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"FunctionModel"},{tp:[{mt:"tp",nm:"Container"},{mt:"tp",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"Function"}],pk:".",nm:"Member"}],tp:[{dv:"in",def:{pk:".",nm:"Nothing"},nm:"Container"},{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"},{dv:"in",def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],$m:{bind:{$t:{tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"Function"},pa:7,mt:"m",ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"container"}]],nm:"bind"}},nm:"Method"},Type:{pa:17,mt:"i",an:{doc:["A closed type.\n\nA closed type is a type which is fully resolved and bound and contains no open type variables.\nAll instance types are closed at runtime.\n\nYou have only four sorts of types:\n\n- [[ClassOrInterface]]\n- [[UnionType]]\n- [[IntersectionType]]\n- [[nothingType]]"]},tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Target"}],$m:{intersection:{$t:{tp:[{comp:"i",mt:"tp",l:[{nm:"Target"},{nm:"Other"}]}],pk:".",nm:"Type"},pa:5,mt:"m",an:{doc:["The intersection of this type with the other type."]},tp:[{nm:"Other"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Type"},mt:"prm",nm:"other"}]],nm:"intersection"},exactly:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"m",an:{doc:["True if the given type is a exactly this type."]},ps:[[{$t:{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"Type"},mt:"prm",nm:"type"}]],nm:"exactly"},subtypeOf:{$t:{pk:"$",nm:"Boolean"},pa:9,mt:"m",an:{doc:["True if this type is a subtype of the given type, or if both types are the same."]},ps:[[{$t:{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"Type"},mt:"prm",nm:"type"}]],nm:"subtypeOf"},union:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Target"},{nm:"Other"}]}],pk:".",nm:"Type"},pa:5,mt:"m",an:{doc:["The union of this type with the other type."]},tp:[{nm:"Other"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Type"},mt:"prm",nm:"other"}]],nm:"union"},typeOf:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"m",an:{doc:["True if the given instance is of this type, or is of a subtype of this type."]},ps:[[{$t:{pk:"$",nm:"Anything"},mt:"prm",nm:"instance"}]],nm:"typeOf"},supertypeOf:{$t:{pk:"$",nm:"Boolean"},pa:5,mt:"m",an:{doc:["True if this type is a supertype of the given type, or if both types are the same."]},ps:[[{$t:{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"Type"},mt:"prm",nm:"type"}]],nm:"supertypeOf"}},nm:"Type"},IntersectionType:{pa:17,mt:"i",an:{doc:["A closed intersection type."]},sts:[{tp:[{mt:"tp",nm:"Intersection"}],pk:".",nm:"Type"}],tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Intersection"}],$at:{satisfiedTypes:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"Type"}],pk:"$",nm:"List"},pa:5,mt:"a",an:{doc:["The list of closed satisfied types of this intersection."]},nm:"satisfiedTypes"}},nm:"IntersectionType"},Applicable:{pa:17,mt:"i",an:{doc:["Represents classes or functions that you can apply in a type-unsafe way.\n"]},sts:[{tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:"$",nm:"Callable"}],tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"},{dv:"in",def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],$m:{namedApply:{$t:{nm:"Type"},pa:5,mt:"m",an:{throws:["InvocationException","If there are not enough or too many provided arguments, \nor if the target does not support named invocation"],doc:["Type-unsafe application by name, to be used when the argument types are unknown until runtime.\n\nThis has the same behaviour as invoking the applicable directly, but exchanges compile-time type\nsafety with runtime checks."]},ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"String"},{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Entry"},{mt:"tp",pk:"$",nm:"Null"}],pk:"$",nm:"Iterable"},mt:"prm",nm:"arguments"}]],nm:"namedApply"},apply:{$t:{nm:"Type"},pa:5,mt:"m",an:{throws:["InvocationException","If there are not enough or too many provided arguments"],doc:["Type-unsafe application, to be used when the argument types are unknown until runtime.\n\nThis has the same behaviour as invoking the applicable directly, but exchanges compile-time type\nsafety with runtime checks."]},ps:[[{$t:{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"arguments"}]],nm:"apply"}},nm:"Applicable"},UnionType:{pa:17,mt:"i",an:{doc:["A closed union type."]},sts:[{tp:[{mt:"tp",nm:"Union"}],pk:".",nm:"Type"}],tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Union"}],$at:{caseTypes:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"Type"}],pk:"$",nm:"List"},pa:5,mt:"a",an:{doc:["The list of closed case types of this union."]},nm:"caseTypes"}},nm:"UnionType"},Functional:{pa:17,mt:"i",an:{doc:["Abstraction for models which have a parameter list. That is, \n[[ClassModel]]s, [[ConstructorModel]]s and [[FunctionModel]]s."]},$at:{parameterTypes:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"Type"}],pk:"$",nm:"Sequential"},pa:5,mt:"a",an:{doc:["The parameter types"]},nm:"parameterTypes"}},nm:"Functional"},Qualified:{pa:17,mt:"i",an:{doc:["Abstraction for models of elements which must be qualified \nby an instance to order to be evaluated, including:\n\n* [[Attribute]]s (a Qualified `Value`), \n* [[Method]]s  (a Qualified `Function`), \n* [[MemberClass|member classes]]  (a Qualified `Class`) and,\n* [[MemberClassConstructor|member constructors]]  (a constructor of a Qualified `Class`).\n\nTo qualify a `Qualified` metamodel instance in a type-safe way you \nsimply invoke it. Alternatively use [[bind]] if the qualifying instance's \ntype is unknown until runtime."]},sts:[{tp:[{mt:"tp",nm:"Kind"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"Container"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Container"},{mt:"tp",pk:"$",nm:"Empty"}],pk:"$",nm:"Tuple"}],pk:"$",nm:"Callable"}],tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Kind"},{dv:"in",def:{pk:".",nm:"Nothing"},nm:"Container"}],$m:{bind:{$t:{nm:"Kind"},pa:5,mt:"m",an:{throws:["IncompatibleTypeException","If the container is not assignable to this member's container"],doc:["Type-unsafe container binding, to be used when the container type is unknown until runtime.\n\nThis has the same behaviour as invoking this `Member` directly, but exchanges compile-time type\nsafety with runtime checks."]},ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"container"}]],nm:"bind"}},nm:"Qualified"},FunctionModel:{pa:17,mt:"i",an:{doc:["A function model represents the model of a Ceylon function that you can inspect.\n\nA function model can be either a toplevel [[Function]] or a member [[Method]].\n"]},sts:[{pk:".",nm:"Model"},{pk:".",nm:"Generic"},{pk:".",nm:"Functional"}],tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"},{dv:"in",def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],$at:{declaration:{$t:{pk:"ceylon.language.meta.declaration",nm:"FunctionDeclaration"},pa:7,mt:"a",an:{doc:["This function's declaration."]},nm:"declaration"},type:{$t:{tp:[{mt:"tp",nm:"Type"}],pk:".",nm:"Type"},pa:5,mt:"a",an:{doc:["This function's return closed type."]},nm:"type"}},nm:"FunctionModel"},MemberClassConstructor:{pa:17,mt:"i",sts:[{tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"ConstructorModel"},{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"Constructor"},{mt:"tp",nm:"Container"}],pk:".",nm:"Qualified"}],tp:[{dv:"in",def:{pk:".",nm:"Nothing"},nm:"Container"},{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"},{dv:"in",def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],nm:"MemberClassConstructor"},ValueModel:{pa:17,mt:"i",an:{doc:["A value model represents the model of a Ceylon value that you can inspect.\n\nA value model can be either a toplevel [[Value]] or a member [[Attribute]].\n"]},sts:[{pk:".",nm:"Model"}],tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Get"},{dv:"in",def:{pk:".",nm:"Nothing"},nm:"Set"}],$at:{declaration:{$t:{pk:"ceylon.language.meta.declaration",nm:"ValueDeclaration"},pa:7,mt:"a",an:{doc:["This value's declaration."]},nm:"declaration"},type:{$t:{tp:[{mt:"tp",nm:"Get"}],pk:".",nm:"Type"},pa:5,mt:"a",an:{doc:["This value's closed type."]},nm:"type"}},nm:"ValueModel"},ClassModel:{pa:17,mt:"i",an:{doc:["A class model represents the model of a Ceylon class that you can inspect.\n\nA class model can be either a toplevel [[Class]] or a member [[MemberClass]].\n"]},sts:[{tp:[{mt:"tp",nm:"Type"}],pk:".",nm:"ClassOrInterface"},{pk:".",nm:"Functional"}],tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"},{dv:"in",def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],$m:{getConstructor:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"ConstructorModel"}]},pa:5,mt:"m",an:{doc:["The constructor with the given name, or null if this class lacks \na constructor of the given name"]},tp:[{def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],nm:"getConstructor"}},$at:{declaration:{$t:{pk:"ceylon.language.meta.declaration",nm:"ClassDeclaration"},pa:7,mt:"a",nm:"declaration"}},nm:"ClassModel"},Attribute:{pa:17,mt:"i",an:{doc:["An attribute model represents the model of a Ceylon attribute that you can read and inspect.\n\nAn attribute is a member value: it is declared on classes or interfaces.\n\nThis is both a [[ValueModel]] and a [[Member]]: you can invoke it with an instance value\nto bind it to that instance and obtain a [[Value]]:\n\n    class Outer(){\n        shared String foo = \"Hello\";\n    }\n    \n    void test(){\n        Attribute<Outer,String> attribute = `Outer.foo`;\n        Value<String> boundAttribute = attribute(Outer());\n        \/\/ This will print: Hello\n        print(boundAttribute.get());\n    }\n"]},sts:[{tp:[{mt:"tp",nm:"Get"},{mt:"tp",nm:"Set"}],pk:".",nm:"ValueModel"},{tp:[{mt:"tp",nm:"Container"},{mt:"tp",tp:[{mt:"tp",nm:"Get"},{mt:"tp",nm:"Set"}],pk:".",nm:"Value"}],pk:".",nm:"Member"}],tp:[{dv:"in",def:{pk:".",nm:"Nothing"},nm:"Container"},{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Get"},{dv:"in",def:{pk:".",nm:"Nothing"},nm:"Set"}],$m:{bind:{$t:{tp:[{mt:"tp",nm:"Get"},{mt:"tp",nm:"Set"}],pk:".",nm:"Value"},pa:7,mt:"m",ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"container"}]],nm:"bind"}},nm:"Attribute"},"$pkg-pa":1,Value:{pa:17,mt:"i",an:{doc:["A value model represents the model of a Ceylon value that you can read and inspect.\n\nA value is a toplevel binding, declared on a package.\n\nThis is a [[ValueModel]] that you can query for a value declaration's current value:\n\n    shared String foo = \"Hello\";\n    \n    void test(){\n        Value<String> val = `foo`;\n        \/\/ This will print: Hello\n        print(val.get());\n    }\n"]},sts:[{tp:[{mt:"tp",nm:"Get"},{mt:"tp",nm:"Set"}],pk:".",nm:"ValueModel"}],tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Get"},{dv:"in",def:{pk:".",nm:"Nothing"},nm:"Set"}],$m:{get:{$t:{nm:"Get"},pa:5,mt:"m",an:{doc:["Reads the current value for this value binding. Note that in the case of getter\nvalues, this can throw if the getter throws."]},nm:"get"},set:{$t:{pk:"$",nm:"Anything"},pa:5,mt:"m",an:{doc:["Changes this variable's value to the given new value. Note that in the case of\nsetter attributes, this can throw if the setter throws."]},ps:[[{$t:{nm:"Set"},mt:"prm",nm:"newValue"}]],nm:"set"},setIfAssignable:{$t:{pk:"$",nm:"Anything"},pa:5,mt:"m",an:{throws:["MutationException","If this value is not variable"],doc:["Non type-safe equivalent to [[Value.set]], to be used when you don't know the \nvariable type at compile-time. This only works if the underlying value is \nvariable. Note that if the underlying variable is a setter, this can throw \nexceptions thrown in the setter block."]},ps:[[{$t:{pk:"$",nm:"Anything"},mt:"prm",nm:"newValue"}]],nm:"setIfAssignable"}},nm:"Value"},InvocationException:{super:{pk:"$",nm:"Exception"},pa:1,mt:"c",an:{doc:["Thrown when attempting to invoke something which can't be invoked, like abstract class\ninitialisers."]},$at:{message$g4ihko:{$t:{pk:"$",nm:"String"},mt:"a",nm:"message"}},ps:[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"message"}],nm:"InvocationException"},Function:{pa:17,mt:"i",an:{doc:["A function model represents the model of a Ceylon function that you can invoke and inspect.\n\nA function is a toplevel binding, declared on a package.\n\nThis is a [[FunctionModel]] that you can also invoke:\n\n    shared String foo(String name) => \"Hello \"+name;\n    \n    void test(){\n        Function<String,[String]> f = `foo`;\n        \/\/ This will print: Hello Stef\n        print(f(\"Stef\"));\n    }\n"]},sts:[{tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"FunctionModel"},{tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"Applicable"}],tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"},{dv:"in",def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],nm:"Function"},TypeApplicationException:{super:{pk:"$",nm:"Exception"},pa:1,mt:"c",an:{doc:["Thrown when declarations are applied with invalid or incompatible type arguments.\nAlso throw when trying to apply member declarations with no containers, or toplevel\ndeclarations with a container.\n\nFor example if you try to apply `Foo` with `String`, hoping to get a `Foo<String>`\nbut the type parameter for `Foo` only accepts types that satisfy `Numeric`.\n"]},$at:{message$9tu43y:{$t:{pk:"$",nm:"String"},mt:"a",nm:"message"}},ps:[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"message"}],nm:"TypeApplicationException"},MemberClass:{pa:17,mt:"i",an:{doc:["A class model represents the model of a Ceylon class that you can instantiate and inspect.\n\nA member class is is declared on classes or interfaces.\n\nThis is both a [[ClassModel]] and a [[Member]]: you can invoke it with an instance value\nto bind it to that instance and obtain a [[Class]]:\n\n    shared class Outer(String name){\n        shared class Inner(){\n            shared String hello => \"Hello \"+name;\n        }\n    }\n    \n    void test(){\n        MemberClass<Outer,Outer.Inner,[]> memberClass = `Outer.Inner`;\n        Class<Outer.Inner,[]> c = memberClass(Outer(\"Stef\"));\n        \/\/ This will print: Hello Stef\n        print(c().hello);\n    }\n"]},sts:[{tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"ClassModel"},{tp:[{mt:"tp",nm:"Container"},{mt:"tp",tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"Class"}],pk:".",nm:"Member"}],tp:[{dv:"in",def:{pk:".",nm:"Nothing"},nm:"Container"},{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"},{dv:"in",def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],$m:{bind:{$t:{tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"Class"},pa:7,mt:"m",ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"container"}]],nm:"bind"},getConstructor:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"MemberClassConstructor"}]},pa:7,mt:"m",an:{doc:["The constructor with the given name, or null if this class lacks \na constructor of the given name"]},tp:[{def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],nm:"getConstructor"}},nm:"MemberClass"},MutationException:{super:{pk:"$",nm:"Exception"},pa:1,mt:"c",an:{doc:["Thrown when you try to change the value of a non-variable value"]},$at:{message$l7zqwp:{$t:{pk:"$",nm:"String"},mt:"a",nm:"message"}},ps:[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"message"}],nm:"MutationException"},Interface:{pa:17,mt:"i",an:{doc:["An interface model that you can inspect."]},sts:[{tp:[{mt:"tp",nm:"Type"}],pk:".",nm:"InterfaceModel"}],tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"}],nm:"Interface"},ConstructorModel:{pa:17,mt:"i",an:{doc:["A constructor model represents the model of a Ceylon class constructor \nthat you can inspect.\n\nA constructor model can be either a [[Constructor]] (when for a toplevel [[Class]]) \nor a member [[MemberClassConstructor]] (when for a [[MemberClass]]).\n"]},sts:[{pk:".",nm:"Functional"},{pk:".",nm:"Declared"}],tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"},{dv:"in",def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],nm:"ConstructorModel"},Declared:{pa:17,mt:"i",an:{doc:["A model element that has a declaration."]},$at:{declaration:{$t:{pk:"ceylon.language.meta.declaration",nm:"Declaration"},pa:5,mt:"a",nm:"declaration"},container:{$t:{comp:"u",l:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"Type"},{comp:"u",l:[{pk:"$",nm:"Null"},{pk:"ceylon.language.meta.declaration",nm:"Package"}]}]},pa:5,mt:"a",an:{doc:["The container type of this model, or `null` if this is a toplevel model."]},nm:"container"}},nm:"Declared"},nothingType:{super:{pk:"$",nm:"Basic"},pa:1,mt:"o",an:{doc:["The singleton closed type for [[Nothing|ceylon.language::nothing]]."]},sts:[{tp:[{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Type"}],$m:{intersection:{$t:{tp:[{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Type"},pa:3,mt:"m",tp:[{nm:"Other"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Type"},mt:"prm",nm:"type"}]],nm:"intersection"},exactly:{$t:{pk:"$",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"Type"},mt:"prm",nm:"type"}]],nm:"exactly"},subtypeOf:{$t:{pk:"$",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"Type"},mt:"prm",nm:"type"}]],nm:"subtypeOf"},union:{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Type"},pa:3,mt:"m",tp:[{nm:"Other"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Type"},mt:"prm",nm:"type"}]],nm:"union"},typeOf:{$t:{pk:"$",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:"$",nm:"Anything"},mt:"prm",nm:"instance"}]],nm:"typeOf"},supertypeOf:{$t:{pk:"$",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"Type"},mt:"prm",nm:"type"}]],nm:"supertypeOf"}},$at:{string:{$t:{pk:"$",nm:"String"},pa:3,mt:"g",nm:"string"}},nm:"nothingType"},Class:{pa:17,mt:"i",an:{doc:["A class model represents the model of a Ceylon class that you can instantiate and inspect.\n\nA class is a toplevel type, declared on a package.\n\nThis is a [[ClassModel]] that you can also invoke to instantiate new instances of the class:\n\n    shared class Foo(String name){\n        shared String hello => \"Hello \"+name;\n    }\n    \n    void test(){\n        Class<Foo,[String]> c = `Foo`;\n        \/\/ This will print: Hello Stef\n        print(c(\"Stef\").hello);\n    }\n"]},sts:[{tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"ClassModel"},{tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"Applicable"}],tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"},{dv:"in",def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],$m:{getConstructor:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"Constructor"}]},pa:7,mt:"m",an:{doc:["The constructor with the given name, or null if this class lacks \na constructor of the given name."]},tp:[{def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],nm:"getConstructor"}},nm:"Class"},ClassOrInterface:{of:[{tp:[{mt:"tp",nm:"Type"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"ClassModel"},{tp:[{mt:"tp",nm:"Type"}],pk:".",nm:"InterfaceModel"}],pa:17,mt:"i",an:{doc:["Model of a class or interface that you can inspect.\n\nThe models of classes and interfaces are also closed types."]},sts:[{pk:".",nm:"Model"},{pk:".",nm:"Generic"},{tp:[{mt:"tp",nm:"Type"}],pk:".",nm:"Type"}],tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"}],$m:{getClasses:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"MemberClass"}],pk:"$",nm:"Sequential"},pa:5,mt:"m",an:{doc:["Gets a list of member classes matching the given container, return and parameter types, annotated with all the\nspecified annotations, which are declared on this type or inherited."]},tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"},{def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Annotation"}],pk:".",nm:"Type"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"annotationTypes"}]],nm:"getClasses"},getClass:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"MemberClass"}]},pa:5,mt:"m",an:{throws:["TypeApplicationException","If the specified closed type argument values are not compatible with the actual result's type parameters."],doc:["Gets a member class by name. Returns `null` if not found."]},tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"},{def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"},{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"Type"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"types"}]],nm:"getClass"},getDeclaredClassOrInterface:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Kind"}],pk:".",nm:"Member"}]},pa:5,mt:"m",an:{throws:["TypeApplicationException","If the specified closed type argument values are not compatible with the actual result's type parameters."],doc:["Gets a member class or interface by name. Returns `null` if not found."]},tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"ClassOrInterface"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"ClassOrInterface"}],nm:"Kind"}],ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"},{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"Type"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"types"}]],nm:"getDeclaredClassOrInterface"},getDeclaredInterface:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"}],pk:".",nm:"MemberInterface"}]},pa:5,mt:"m",an:{throws:["TypeApplicationException","If the specified closed type argument values are not compatible with the actual result's type parameters."],doc:["Gets a member interface by name. Returns `null` if not found."]},tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"}],ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"},{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"Type"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"types"}]],nm:"getDeclaredInterface"},getMethod:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"Method"}]},pa:5,mt:"m",an:{throws:["TypeApplicationException","If the specified closed type argument values are not compatible with the actual result's type parameters."],doc:["Gets a method by name. Returns `null` if not found."]},tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"},{def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"},{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"Type"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"types"}]],nm:"getMethod"},getInterfaces:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"}],pk:".",nm:"MemberInterface"}],pk:"$",nm:"Sequential"},pa:5,mt:"m",an:{doc:["Gets a list of interfaces matching the given container and interface types, annotated with all the\nspecified annotations, which are declared on this type or inherited."]},tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"}],ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Annotation"}],pk:".",nm:"Type"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"annotationTypes"}]],nm:"getInterfaces"},getDeclaredAttributes:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Get"},{mt:"tp",nm:"Set"}],pk:".",nm:"Attribute"}],pk:"$",nm:"Sequential"},pa:5,mt:"m",an:{doc:["Gets a list of attributes matching the given container and attribute type, annotated with all the\nspecified annotations, which are directly declared on this type."]},tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Get"},{def:{pk:".",nm:"Nothing"},nm:"Set"}],ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Annotation"}],pk:".",nm:"Type"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"annotationTypes"}]],nm:"getDeclaredAttributes"},getClassOrInterface:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Kind"}],pk:".",nm:"Member"}]},pa:5,mt:"m",an:{throws:["TypeApplicationException","If the specified closed type argument values are not compatible with the actual result's type parameters."],doc:["Gets a member class or interface by name. Returns `null` if not found."]},tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"ClassOrInterface"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"ClassOrInterface"}],nm:"Kind"}],ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"},{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"Type"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"types"}]],nm:"getClassOrInterface"},getAttribute:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Get"},{mt:"tp",nm:"Set"}],pk:".",nm:"Attribute"}]},pa:5,mt:"m",an:{throws:["IncompatibleTypeException","If the specified `Container`, `Get` or `Set` type arguments are not compatible with the actual result."],doc:["Gets an attribute by name. Returns `null` if not found."]},tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Get"},{def:{pk:".",nm:"Nothing"},nm:"Set"}],ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],nm:"getAttribute"},getDeclaredAttribute:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Get"},{mt:"tp",nm:"Set"}],pk:".",nm:"Attribute"}]},pa:5,mt:"m",an:{throws:["IncompatibleTypeException","If the specified `Container`, `Get` or `Set` type arguments are not compatible with the actual result."],doc:["Gets an attribute by name. Returns `null` if not found."]},tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Get"},{def:{pk:".",nm:"Nothing"},nm:"Set"}],ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"}]],nm:"getDeclaredAttribute"},getDeclaredClass:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"MemberClass"}]},pa:5,mt:"m",an:{throws:["TypeApplicationException","If the specified closed type argument values are not compatible with the actual result's type parameters."],doc:["Gets a member class by name. Returns `null` if not found."]},tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"},{def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"},{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"Type"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"types"}]],nm:"getDeclaredClass"},getMethods:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"Method"}],pk:"$",nm:"Sequential"},pa:5,mt:"m",an:{doc:["Gets a list of methods matching the given container, return and parameter types, annotated with all the\nspecified annotations, which are declared on this type or inherited."]},tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"},{def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Annotation"}],pk:".",nm:"Type"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"annotationTypes"}]],nm:"getMethods"},getDeclaredInterfaces:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"}],pk:".",nm:"MemberInterface"}],pk:"$",nm:"Sequential"},pa:5,mt:"m",an:{doc:["Gets a list of interfaces matching the given container and interface types, annotated with all the\nspecified annotations, which are directly declared on this type."]},tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"}],ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Annotation"}],pk:".",nm:"Type"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"annotationTypes"}]],nm:"getDeclaredInterfaces"},getDeclaredMethod:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"Method"}]},pa:5,mt:"m",an:{throws:["TypeApplicationException","If the specified closed type argument values are not compatible with the actual result's type parameters."],doc:["Gets a method by name. Returns `null` if not found."]},tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"},{def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"},{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"Type"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"types"}]],nm:"getDeclaredMethod"},getDeclaredMethods:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"Method"}],pk:"$",nm:"Sequential"},pa:5,mt:"m",an:{doc:["Gets a list of methods matching the given container, return and parameter types, annotated with all the\nspecified annotations, which are directly declared on this type."]},tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"},{def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Annotation"}],pk:".",nm:"Type"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"annotationTypes"}]],nm:"getDeclaredMethods"},getInterface:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"}],pk:".",nm:"MemberInterface"}]},pa:5,mt:"m",an:{throws:["TypeApplicationException","If the specified closed type argument values are not compatible with the actual result's type parameters."],doc:["Gets a member interface by name. Returns `null` if not found."]},tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"}],ps:[[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"name"},{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"Type"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"types"}]],nm:"getInterface"},getAttributes:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Get"},{mt:"tp",nm:"Set"}],pk:".",nm:"Attribute"}],pk:"$",nm:"Sequential"},pa:5,mt:"m",an:{doc:["Gets a list of attributes matching the given container and attribute type, annotated with all the\nspecified annotations, which are declared on this type or inherited."]},tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Get"},{def:{pk:".",nm:"Nothing"},nm:"Set"}],ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Annotation"}],pk:".",nm:"Type"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"annotationTypes"}]],nm:"getAttributes"},getDeclaredClasses:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Container"},{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"MemberClass"}],pk:"$",nm:"Sequential"},pa:5,mt:"m",an:{doc:["Gets a list of member classes matching the given container, return and parameter types, annotated with all the\nspecified annotations, which are directly declared on this type."]},tp:[{def:{pk:".",nm:"Nothing"},nm:"Container"},{def:{pk:"$",nm:"Anything"},nm:"Type"},{def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Annotation"}],pk:".",nm:"Type"}],pk:"$",nm:"Sequential"},mt:"prm",seq:1,nm:"annotationTypes"}]],nm:"getDeclaredClasses"}},$at:{extendedType:{$t:{comp:"u",l:[{pk:"$",nm:"Null"},{tp:[{mt:"tp",pk:"$",nm:"Anything"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"ClassModel"}]},pa:5,mt:"a",an:{doc:["The extended closed type for this class or interface. Note that the [[Anything|ceylon.language::Anything]] type\nhas no extended type since it is the top of the type hierarchy."]},nm:"extendedType"},declaration:{$t:{pk:"ceylon.language.meta.declaration",nm:"ClassOrInterfaceDeclaration"},pa:7,mt:"a",an:{doc:["The declaration for this class or interface."]},nm:"declaration"},caseValues:{$t:{tp:[{mt:"tp",nm:"Type"}],pk:"$",nm:"Sequential"},pa:5,mt:"a",an:{doc:["The list of case values for this type. This omits any case type to only contain case values."]},nm:"caseValues"},satisfiedTypes:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"InterfaceModel"}],pk:"$",nm:"Sequential"},pa:5,mt:"a",an:{doc:["The list of closed types that this class or interface satisfies."]},nm:"satisfiedTypes"}},nm:"ClassOrInterface"},Generic:{pa:17,mt:"i",an:{doc:["A generic model which has closed type arguments."]},$at:{typeArguments:{$t:{tp:[{mt:"tp",pk:"ceylon.language.meta.declaration",nm:"TypeParameter"},{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"Type"}],pk:"$",nm:"Map"},pa:5,mt:"a",an:{doc:["The map of type parameter declaration to type arguments for this generic model."]},nm:"typeArguments"},typeArgumentList:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:".",nm:"Type"}],pk:"$",nm:"Sequential"},pa:5,mt:"a",an:{doc:["The list of type arguments for this generic model."]},nm:"typeArgumentList"}},nm:"Generic"},Constructor:{pa:17,mt:"i",an:{doc:["A constructor model that represents the model of \na constructor of a top level Ceylon [[Class]] that \nyou can instantiate and inspect.\n"]},sts:[{tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"ConstructorModel"},{tp:[{mt:"tp",nm:"Type"},{mt:"tp",nm:"Arguments"}],pk:".",nm:"Applicable"}],tp:[{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"},{dv:"in",def:{pk:".",nm:"Nothing"},sts:[{tp:[{mt:"tp",pk:"$",nm:"Anything"}],pk:"$",nm:"Sequential"}],nm:"Arguments"}],$at:{declaration:{$t:{pk:"ceylon.language.meta.declaration",nm:"ConstructorDeclaration"},pa:7,mt:"a",an:{doc:["The declaration for this model."]},nm:"declaration"}},nm:"Constructor"},IncompatibleTypeException:{super:{pk:"$",nm:"Exception"},pa:1,mt:"c",an:{doc:["Thrown when you invoke metamodel methods with invalid or incompatible type arguments.\n\nFor example if you try to get an attribute from a class and expect an attribute of `String`\ntype but it is an attribute of `Integer` type.\n"]},$at:{message$kubtzh:{$t:{pk:"$",nm:"String"},mt:"a",nm:"message"}},ps:[{$t:{pk:"$",nm:"String"},mt:"prm",nm:"message"}],nm:"IncompatibleTypeException"},"$pkg-anns":{doc:["The Ceylon metamodel closed type and model package.\n\nAs described in the [ceylon.language.meta](..\/index.html) documentation, this package contains all\nthe types that represent Ceylon closed types and models.\n\n### Usage example\n\nThe following code will list all the value declarations in the `ceylon.language` package and print their\ncurrent value:\n\n    Package languagePackage = `package ceylon.language`;\n    ValueDeclaration[] valueDeclarations = languagePackage.members<ValueDeclaration>();\n    Value<Anything>[] valueModels = valueDeclarations*.apply<Anything>();\n    for(val in valueModels){\n        \/\/ skip the nothing value which cannot be read\n        if(val.type != `Nothing`){\n            print(val.get());\n        }\n    }\n\nThe following code will iterate all the class declarations in the `ceylon.language` package that\nare not abstract, anonymous or annotations, and that have no type parameters nor initialiser\nparameters. For each matching class, we will apply it to get a class model which we can then\nuse to instantiate the class and display its instance:\n\n    for(decl in `package ceylon.language`.members<ClassDeclaration>()){\n        if(!decl.abstract \n                && !decl.anonymous \n                && !decl.annotation\n                && decl.parameterDeclarations.empty\n                && decl.typeParameterDeclarations.empty){\n            Class<Object,[]> classModel = decl.classApply<Object,[]>();\n            Object instance = classModel();\n            print(\"Instance of ``decl.name`` is: ``instance``\");\n        }\n    }\n"],by:["Gavin King","Stephane Epardaud"]},MemberInterface:{pa:17,mt:"i",an:{doc:["A member interface model that you can inspect."]},sts:[{tp:[{mt:"tp",nm:"Type"}],pk:".",nm:"InterfaceModel"},{tp:[{mt:"tp",nm:"Container"},{mt:"tp",tp:[{mt:"tp",nm:"Type"}],pk:".",nm:"Interface"}],pk:".",nm:"Member"}],tp:[{dv:"in",def:{pk:".",nm:"Nothing"},nm:"Container"},{dv:"out",def:{pk:"$",nm:"Anything"},nm:"Type"}],$m:{bind:{$t:{tp:[{mt:"tp",nm:"Type"}],pk:".",nm:"Interface"},pa:7,mt:"m",ps:[[{$t:{pk:"$",nm:"Object"},mt:"prm",nm:"container"}]],nm:"bind"}},nm:"MemberInterface"}},"ceylon.language":{Iterator:{pa:1,mt:"i",an:{see:["Iterable"],doc:["Produces the elements of an [[Iterable]] object. For \nexample, this class has an `Iterator` that produces the \nintegers from `min` to `max`:\n\n    class IntegerIterable(Integer min, Integer max) \n           satisfies {Integer+} {\n       iterator() => object satisfies Iterator<Integer> {\n           variable value i = min;\n           next() => i<=max then i++ else finished;\n       };\n    }\n\nAn iterator is _exhausted_ when [[next]] produces the \nvalue [[finished]]."],by:["Gavin"]},tp:[{dv:"out",nm:"Element"}],$m:{next:{$t:{comp:"u",l:[{nm:"Element"},{pk:".",nm:"Finished"}]},pa:5,mt:"m",an:{doc:["The next element, or [[finished]] if there are no more \nelements to be iterated.\n\nRepeated invocations of `next()` for a given iterator\nmust eventually produce any given element of the stream\nto which the iterator belongs. A given iterator must\nnot produce the same element of the stream more often\nthan the element occurs in the stream.\n\nIf an invocation of `next()` for a given iterator \nproduces the value `finished`, then every future \ninvocation of `next()` for that iterator must also\nproduce the value `finished`.\n\nAn iterator for a nonfinite stream may never produce\nthe value `finished`."]},nm:"next"}},nm:"Iterator"},LateAnnotation:{super:{pk:".",nm:"Basic"},pa:545,mt:"c",an:{doc:["The annotation class for the [[late]] annotation."]},sts:[{tp:[{mt:"tp",pk:".",nm:"LateAnnotation"},{mt:"tp",pk:"ceylon.language.meta.declaration",nm:"ValueDeclaration"},{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"OptionalAnnotation"}],nm:"LateAnnotation"},ThrownExceptionAnnotation:{super:{pk:".",nm:"Basic"},pa:545,mt:"c",an:{doc:["The annotation class for the [[throws]] annotation."]},sts:[{tp:[{mt:"tp",pk:".",nm:"ThrownExceptionAnnotation"},{comp:"u",mt:"tp",l:[{pk:"ceylon.language.meta.declaration",nm:"FunctionOrValueDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ClassDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ConstructorDeclaration"}]},{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"SequencedAnnotation"}],$at:{when:{$t:{pk:".",nm:"String"},pa:1,mt:"a",an:{doc:["A description, in Markdown syntax, of the circumstances \nthat cause this exception to be thrown."]},nm:"when"},type:{$t:{pk:"ceylon.language.meta.declaration",nm:"Declaration"},pa:1,mt:"a",an:{doc:["The [[Exception]] type that is thrown."]},nm:"type"}},ps:[{$t:{pk:"ceylon.language.meta.declaration",nm:"Declaration"},pa:1,mt:"prm",an:{doc:["The [[Exception]] type that is thrown."]},nm:"type"},{$t:{pk:".",nm:"String"},pa:1,mt:"prm",an:{doc:["A description, in Markdown syntax, of the circumstances \nthat cause this exception to be thrown."]},nm:"when"}],nm:"ThrownExceptionAnnotation"},Array:{super:{pk:".",nm:"Basic"},pa:97,mt:"c",an:{doc:["A fixed-sized array of mutable elements. An _empty_ array \nis an array of [[size]] `0`. Any element of an array may be\nset to a new value.\n\n    value array = Array { \"hello\", \"world\" };\n    array.set(0, \"goodbye\");\n\nThis class is provided primarily to support interoperation \nwith Java, and for some performance-critical low-level \nprogramming tasks."]},sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},{tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",nm:"Element"},{mt:"tp",tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Array"}],pk:".",nm:"Ranged"}],tp:[{nm:"Element"}],$cn:{OfSize:{pa:65,an:{see:["runtime.maxArraySize"],throws:["AssertionError","if `size>runtime.maxArraySize`"],doc:["Create an array of the specified [[size]], populating \nevery index with the given [[element]]. The specified \n`size` must be no larger than [[runtime.maxArraySize]].\nIf `size<=0`, the new array will have no elements."]},ps:[{$t:{pk:".",nm:"Integer"},mt:"prm",an:{doc:["The size of the resulting array. If the size is \nnon-positive, an empty array will be created."]},nm:"size"},{$t:{nm:"Element"},mt:"prm",an:{doc:["The element value with which to populate the array.\nAll elements of the resulting array will have the \nsame value."]},nm:"element"}],nm:"OfSize"},$def:{pa:65,an:{doc:["Create an array with the given [[elements]]."]},ps:[{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"elements"}]}},$m:{sort:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:67,mt:"m",an:{doc:["Sorts the elements in this array according to the \norder induced by the given \n[[comparison function|comparing]], returning a new\nsequence. This operation has no side-effect, and does\nnot modify the array."]},ps:[[{$t:{pk:".",nm:"Comparison"},mt:"prm",an:{doc:["A comparison function that compares pairs of\nelements of this array."]},$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],nm:"comparing"}]],nm:"sort"},sortInPlace:{$t:{pk:".",nm:"Anything"},pa:65,mt:"m",an:{doc:["Sorts the elements in this array according to the \norder induced by the given \n[[comparison function|comparing]]. This operation \nworks by side-effect, modifying the array."]},ps:[[{$t:{pk:".",nm:"Comparison"},mt:"prm",an:{doc:["A comparison function that compares pairs of\nelements of this array."]},$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],nm:"comparing"}]],nm:"sortInPlace"},measure:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Array"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"measure"},count:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"count"},set:{$t:{pk:".",nm:"Anything"},pa:65,mt:"m",an:{throws:["AssertionError","if the given index is out of bounds, that is, if \n`index<0` or if `index>lastIndex`"],doc:["Replace the existing element at the specified index \nwith the given element."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",an:{doc:["The index of the element to replace."]},nm:"index"},{$t:{nm:"Element"},mt:"prm",an:{doc:["The new element."]},nm:"element"}]],nm:"set"},locateLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",nm:"Element"}],pk:".",nm:"Entry"}]},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"locateLast"},contains:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],nm:"contains"},by:{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"step"}]],nm:"by"},skip:{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"skipping"}]],nm:"skip"},every:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"every"},occurs:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",nm:"element"}]],nm:"occurs"},getFromLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:67,mt:"m",an:{doc:["Get the element at the specified index, where the array\nis indexed from the _end_ of the array, or `null` if\nthe index falls outside the bounds of this array."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromLast"},copyTo:{$t:{pk:".",nm:"Anything"},pa:65,mt:"m",an:{doc:["Efficiently copy the elements in the segment\n`sourcePosition:length` of this array to the segment \n`destinationPosition:length` of the given \n[[array|destination]]."]},ps:[[{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Array"},mt:"prm",an:{doc:["The array into which to copy the elements."]},nm:"destination"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The index of the first element in this array to \ncopy."]},nm:"sourcePosition"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The index in the given array into which to copy the \nfirst element."]},nm:"destinationPosition"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The number of elements to copy."]},nm:"length"}]],nm:"copyTo"},firstOccurrence:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",nm:"element"}]],nm:"firstOccurrence"},spanTo:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Array"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"spanTo"},any:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"any"},spanFrom:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Array"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],nm:"spanFrom"},locate:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",nm:"Element"}],pk:".",nm:"Entry"}]},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"locate"},find:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"find"},clone:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Array"},pa:67,mt:"m",an:{doc:["A new array with the same elements as this array."]},nm:"clone"},iterator:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"},pa:67,mt:"m",nm:"iterator"},equals:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],nm:"equals"},reduce:{$t:{comp:"u",l:[{nm:"Result"},{nm:"Element"},{pk:".",nm:"Null"}]},pa:67,mt:"m",tp:[{nm:"Result"}],ps:[[{$t:{nm:"Result"},mt:"prm",$pt:"f",ps:[[{$t:{comp:"u",l:[{nm:"Result"},{nm:"Element"}]},mt:"prm",nm:"partial"},{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"accumulating"}]],nm:"reduce"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:67,mt:"m",an:{doc:["Get the element at the specified index, or `null` if\nthe index falls outside the bounds of this array."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromFirst"},reverseInPlace:{$t:{pk:".",nm:"Anything"},pa:65,mt:"m",an:{doc:["Reverses the order of the current elements in this \narray. This operation works by side-effect, modifying \nthe array."]},nm:"reverseInPlace"},defines:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"defines"},sequence:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:67,mt:"m",nm:"sequence"},take:{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"taking"}]],nm:"take"},lastOccurrence:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",nm:"element"}]],nm:"lastOccurrence"},each:{$t:{pk:".",nm:"Anything"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"step"}]],nm:"each"},findLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"findLast"},span:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Array"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"span"}},$at:{lastIndex:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:67,mt:"a",nm:"lastIndex"},last:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:67,mt:"a",nm:"last"},hash:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"hash"},coalesced:{$t:{tp:[{comp:"i",mt:"tp",l:[{nm:"Element"},{pk:".",nm:"Object"}]},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:67,mt:"a",nm:"coalesced"},empty:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"a",nm:"empty"},first:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:67,mt:"a",nm:"first"},size:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"size"}},ps:[{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"elements"}],nm:"Array"},ArraySequence:{super:{pk:".",nm:"Object"},pa:49,mt:"c",an:{see:["seq"],doc:["A [[Sequence]] backed by an [[Array]]. \n\nSince [[Array]]s are mutable, this class is private to the\nlanguage module, where we can be sure the `Array` is not\nmodified after the `ArraySequence` has been initialized."],by:["Tom"],serializable:[]},sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"}],tp:[{dv:"out",nm:"Element"}],$m:{clone:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"},pa:3,mt:"m",nm:"clone"},iterator:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},sort:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"},pa:3,mt:"m",$m:{comparing$r21usz:{$t:{pk:".",nm:"Comparison"},mt:"m",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],nm:"comparing"}},ps:[[{$t:{pk:".",nm:"Comparison"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],nm:"comparing"}]],nm:"sort"},measure:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"measure"},count:{$t:{pk:".",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"count"},contains:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],nm:"contains"},every:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"every"},occurs:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",nm:"element"}]],nm:"occurs"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromFirst"},reduce:{$t:{comp:"u",l:[{nm:"Result"},{nm:"Element"}]},pa:3,mt:"m",tp:[{nm:"Result"}],$m:{accumulating$lf3r4a:{$t:{nm:"Result"},mt:"m",ps:[[{$t:{comp:"u",l:[{nm:"Result"},{nm:"Element"}]},mt:"prm",nm:"partial"},{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"accumulating"}},ps:[[{$t:{nm:"Result"},mt:"prm",$pt:"f",ps:[[{$t:{comp:"u",l:[{nm:"Result"},{nm:"Element"}]},mt:"prm",nm:"partial"},{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"accumulating"}]],nm:"reduce"},firstOccurrence:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",nm:"element"}]],nm:"firstOccurrence"},spanTo:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"spanTo"},any:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"any"},lastOccurrence:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",nm:"element"}]],nm:"lastOccurrence"},each:{$t:{pk:".",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"step"}]],nm:"each"},findLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"findLast"},spanFrom:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],nm:"spanFrom"},find:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"find"},span:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"span"},collect:{$t:{tp:[{mt:"tp",nm:"Result"}],pk:".",nm:"Sequence"},pa:3,mt:"m",tp:[{nm:"Result"}],$m:{collecting$5nxe1r:{$t:{nm:"Result"},mt:"m",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"collecting"}},ps:[[{$t:{nm:"Result"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"collecting"}]],nm:"collect"}},$at:{last:{$t:{nm:"Element"},pa:3,mt:"g",nm:"last"},rest:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"g",nm:"rest"},array$sfdy8d:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Array"},mt:"a",nm:"array"},first:{$t:{nm:"Element"},pa:3,mt:"g",nm:"first"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"}},ps:[{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Array"},mt:"prm",$hdn:1,nm:"array"}],nm:"ArraySequence"},byKey:{$t:{pk:".",nm:"Comparison"},pa:1,mt:"m",an:{see:["byItem"],doc:["A comparator for [[Entry]]s which compares their keys \naccording to the given [[comparing]] function.\n\n    value sortedEntries = map.sort(byKey(byIncreasing(String.lowercased)));\n\nThis function is intended for use with [[Iterable.sort]]\nand [[Iterable.max]]."]},tp:[{sts:[{pk:".",nm:"Object"}],nm:"Key"}],ps:[[{$t:{pk:".",nm:"Comparison"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Key"},mt:"prm",nm:"x"},{$t:{nm:"Key"},mt:"prm",nm:"y"}]],nm:"comparing"}],[{$t:{tp:[{mt:"tp",nm:"Key"},{mt:"tp",pk:".",nm:"Object"}],pk:".",nm:"Entry"},mt:"prm",nm:"x"},{$t:{tp:[{mt:"tp",nm:"Key"},{mt:"tp",pk:".",nm:"Object"}],pk:".",nm:"Entry"},mt:"prm",nm:"y"}]],nm:"byKey"},Singleton:{super:{pk:".",nm:"Object"},pa:33,mt:"c",an:{doc:["A [[Sequence]] with exactly one [[element]], which may be \nnull."],serializable:[]},sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"}],tp:[{dv:"out",nm:"Element"}],$m:{clone:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Singleton"},pa:3,mt:"m",an:{doc:["Returns a `Singleton` with the same element."]},nm:"clone"},iterator:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},sort:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Singleton"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Comparison"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"a"},{$t:{nm:"Element"},mt:"prm",nm:"b"}]],nm:"comparing"}]],nm:"sort"},measure:{$t:{comp:"u",l:[{pk:".",nm:"Empty"},{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Singleton"}]},pa:3,mt:"m",an:{doc:["Returns a `Singleton` if the given starting index \nis `0` and the given `length` is greater than `0`.\nOtherwise, returns an instance of `Empty`."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"measure"},count:{$t:{pk:".",nm:"Integer"},pa:3,mt:"m",an:{doc:["Returns `1` if this `Singleton`'s element\nsatisfies the predicate, or `0` otherwise."]},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"count"},equals:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",an:{doc:["A `Singleton` can be equal to another `List` if \nthat `List` has only one element which is equal to \nthis `Singleton`'s element."]},ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],nm:"equals"},select:{$t:{comp:"u",l:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Singleton"},{pk:".",nm:"Empty"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"select"},contains:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",an:{doc:["Returns `true` if the specified element is this \n`Singleton`'s element."]},ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],nm:"contains"},skip:{$t:{comp:"u",l:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Singleton"},{pk:".",nm:"Empty"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"skipping"}]],nm:"skip"},every:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"e"}]],nm:"selecting"}]],nm:"every"},fold:{$t:{nm:"Result"},pa:3,mt:"m",tp:[{nm:"Result"}],ps:[[{$t:{nm:"Result"},mt:"prm",nm:"initial"}],[{$t:{nm:"Result"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Result"},mt:"prm",nm:"partial"},{$t:{nm:"Element"},mt:"prm",nm:"e"}]],nm:"accumulating"}]],nm:"fold"},reduce:{$t:{nm:"Element"},pa:3,mt:"m",tp:[{nm:"Result"}],ps:[[{$t:{nm:"Result"},mt:"prm",$pt:"f",ps:[[{$t:{comp:"u",l:[{nm:"Result"},{nm:"Element"}]},mt:"prm",nm:"partial"},{$t:{nm:"Element"},mt:"prm",nm:"e"}]],nm:"accumulating"}]],nm:"reduce"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,mt:"m",an:{doc:["Returns the contained element, if the specified \nindex is `0`."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromFirst"},chain:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Iterable"},pa:3,mt:"m",tp:[{nm:"Other"},{sts:[{pk:".",nm:"Null"}],nm:"OtherAbsent"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Other"},{mt:"tp",nm:"OtherAbsent"}],pk:".",nm:"Iterable"},mt:"prm",nm:"other"}]],nm:"chain"},spanTo:{$t:{comp:"u",l:[{pk:".",nm:"Empty"},{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Singleton"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"spanTo"},take:{$t:{comp:"u",l:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Singleton"},{pk:".",nm:"Empty"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"taking"}]],nm:"take"},any:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"e"}]],nm:"selecting"}]],nm:"any"},map:{$t:{tp:[{mt:"tp",nm:"Result"}],pk:".",nm:"Singleton"},pa:3,mt:"m",tp:[{nm:"Result"}],ps:[[{$t:{nm:"Result"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"e"}]],nm:"collecting"}]],nm:"map"},each:{$t:{pk:".",nm:"Anything"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"step"}]],nm:"each"},findLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"e"}]],nm:"selecting"}]],nm:"findLast"},spanFrom:{$t:{comp:"u",l:[{pk:".",nm:"Empty"},{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Singleton"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],nm:"spanFrom"},find:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"e"}]],nm:"selecting"}]],nm:"find"},filter:{$t:{comp:"u",l:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Singleton"},{pk:".",nm:"Empty"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"e"}]],nm:"selecting"}]],nm:"filter"},collect:{$t:{tp:[{mt:"tp",nm:"Result"}],pk:".",nm:"Singleton"},pa:3,mt:"m",tp:[{nm:"Result"}],ps:[[{$t:{nm:"Result"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"collecting"}]],nm:"collect"},span:{$t:{comp:"u",l:[{pk:".",nm:"Empty"},{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Singleton"}]},pa:3,mt:"m",an:{doc:["Returns a `Singleton` if the given starting index \nis `0`. Otherwise, returns an instance of `Empty`."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"span"}},$at:{lastIndex:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",an:{doc:["Returns `0`."]},nm:"lastIndex"},last:{$t:{nm:"Element"},pa:3,mt:"g",an:{doc:["Returns the element contained in this `Singleton`."]},nm:"last"},hash:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"hash"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},coalesced:{$t:{comp:"u",l:[{tp:[{comp:"i",mt:"tp",l:[{nm:"Element"},{pk:".",nm:"Object"}]}],pk:".",nm:"Singleton"},{pk:".",nm:"Empty"}]},pa:3,mt:"g",nm:"coalesced"},reversed:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Singleton"},pa:3,mt:"g",an:{doc:["Return this singleton."]},nm:"reversed"},rest:{$t:{pk:".",nm:"Empty"},pa:3,mt:"g",an:{doc:["Returns `Empty`."]},nm:"rest"},element$kjdnp3:{$t:{nm:"Element"},mt:"a",nm:"element"},first:{$t:{nm:"Element"},pa:3,mt:"g",an:{doc:["Returns the element contained in this `Singleton`."]},nm:"first"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",an:{doc:["Returns `1`."]},nm:"size"}},ps:[{$t:{nm:"Element"},mt:"prm",nm:"element"}],nm:"Singleton"},Comparable:{of:[{nm:"Other"}],pa:1,mt:"i",an:{see:["Comparison","sort","max","min","largest","smallest"],doc:["The general contract for values whose magnitude can be \ncompared. `Comparable` imposes a total ordering upon\ninstances of any type that satisfies the interface.\n\nIf a type `T` satisfies `Comparable<T>`, then instances \nof `T` may be compared using the comparison operators\n`<`, `>`, `<=`, `>=`.\n\n    assert (x>=0.0);\n\nA _ternary comparison_ is useful for asserting lower and \nupper bounds.\n\n    assert (0.0<=x<1.0);\n\nFinally, the _compare_ operator `<=>` may be used to \nproduce an instance of [[Comparison]].\n\n    switch (x<=>y)\n    case (equal) {\n        print(\"same same\");\n    }\n    case (smaller) {\n        print(\"x smaller\");\n    }\n    case (larger) {\n        print(\"y smaller\");\n    }\n\nThe total order of a type must be consistent with the \ndefinition of equality for the type. That is, there are \nthree mutually exclusive possibilities:\n\n- `x<y`,\n- `x>y`, or\n- `x==y`\n\n(These possibilities are expressed by the enumerated\ninstances [[smaller]], [[larger]], and [[equal]] of\n`Comparison`.)\n\nThe order imposed by `Comparable` is sometimes called the\n_natural order_ of a type, to reflect the fact that any\nfunction of type `Comparison(T,T)` might determine a \ndifferent order. Thus, some order-related operations come \nin two flavors: a flavor that depends upon the natural \norder, and a flavor which accepts an arbitrary comparator \nfunction. Examples are:\n\n- [[sort]] vs [[Iterable.sort]] and\n- [[max]] vs [[Iterable.max]]."],by:["Gavin"]},tp:[{dv:"in",sts:[{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Comparable"}],nm:"Other"}],st:"Other",$m:{notLargerThan:{$t:{pk:".",nm:"Boolean"},pa:9,mt:"m",an:{doc:["Determines if this value is smaller than or equal to \nthe given value."]},ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],nm:"notLargerThan"},largerThan:{$t:{pk:".",nm:"Boolean"},pa:9,mt:"m",an:{doc:["Determines if this value is strictly larger than the \ngiven value."]},ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],nm:"largerThan"},notSmallerThan:{$t:{pk:".",nm:"Boolean"},pa:9,mt:"m",an:{doc:["Determines if this value is larger than or equal to the \ngiven value."]},ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],nm:"notSmallerThan"},compare:{$t:{pk:".",nm:"Comparison"},pa:5,mt:"m",an:{see:["equals"],doc:["Compares this value with the given value. \nImplementations must respect the constraints that: \n\n- `x==y` if and only if `x<=>y == equal` \n   (consistency with `equals()`), \n- if `x>y` then `y<x` (symmetry), and \n- if `x>y` and `y>z` then `x>z` (transitivity)."]},ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],nm:"compare"},smallerThan:{$t:{pk:".",nm:"Boolean"},pa:9,mt:"m",an:{doc:["Determines if this value is strictly smaller than the \ngiven value."]},ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],nm:"smallerThan"}},nm:"Comparable"},Comparison:{super:{pk:".",nm:"Basic"},of:[{pk:".",nm:"larger"},{pk:".",nm:"smaller"},{pk:".",nm:"equal"}],pa:257,mt:"c",an:{see:["Comparable"],doc:["The result of a comparison between two [[Comparable]] \nobjects: [[larger]], [[smaller]], or [[equal]]."],by:["Gavin"]},$at:{string:{$t:{pk:".",nm:"String"},pa:3,mt:"a",nm:"string"},reversed:{$t:{pk:".",nm:"Comparison"},pa:5,mt:"a",an:{doc:["The reversed value of this comparison."]},nm:"reversed"}},ps:[{$t:{pk:".",nm:"String"},pa:3,mt:"prm",nm:"string"}],nm:"Comparison"},AbstractAnnotation:{super:{pk:".",nm:"Basic"},pa:545,mt:"c",an:{doc:["The annotation class for the [[abstract]] annotation."]},sts:[{tp:[{mt:"tp",pk:".",nm:"AbstractAnnotation"},{comp:"u",mt:"tp",l:[{pk:"ceylon.language.meta.declaration",nm:"ClassDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ConstructorDeclaration"}]},{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"OptionalAnnotation"}],nm:"AbstractAnnotation"},ActualAnnotation:{super:{pk:".",nm:"Basic"},pa:545,mt:"c",an:{doc:["The annotation class for the [[actual]] annotation."]},sts:[{tp:[{mt:"tp",pk:".",nm:"ActualAnnotation"},{comp:"u",mt:"tp",l:[{pk:"ceylon.language.meta.declaration",nm:"FunctionOrValueDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ClassOrInterfaceDeclaration"}]},{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"OptionalAnnotation"}],nm:"ActualAnnotation"},SeeAnnotation:{super:{pk:".",nm:"Basic"},pa:545,mt:"c",an:{doc:["The annotation class for the [[see]] annotation."]},sts:[{tp:[{mt:"tp",pk:".",nm:"SeeAnnotation"},{mt:"tp",pk:".",nm:"Annotated"},{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"SequencedAnnotation"}],$at:{programElements:{$t:{tp:[{mt:"tp",pk:"ceylon.language.meta.declaration",nm:"Declaration"}],pk:".",nm:"Sequential"},pa:1,mt:"a",an:{doc:["The program elements being referred to."]},nm:"programElements"}},ps:[{$t:{tp:[{mt:"tp",pk:"ceylon.language.meta.declaration",nm:"Declaration"}],pk:".",nm:"Sequential"},pa:1,mt:"prm",an:{doc:["The program elements being referred to."]},seq:1,nm:"programElements"}],nm:"SeeAnnotation"},maximumIntegerExponent:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"maximumIntegerExponent"},SerializableAnnotation:{super:{pk:".",nm:"Basic"},pa:545,mt:"c",an:{doc:["The annotation class for the [[serializable]] annotation."]},sts:[{tp:[{mt:"tp",pk:".",nm:"SerializableAnnotation"},{mt:"tp",pk:"ceylon.language.meta.declaration",nm:"ClassDeclaration"},{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"OptionalAnnotation"}],nm:"SerializableAnnotation"},compose:{$t:{tp:[{mt:"tp",nm:"X"},{mt:"tp",nm:"Args"}],pk:".",nm:"Callable"},pa:1,mt:"m",an:{see:["curry","uncurry"],doc:["Given a function with return type `Y`, and a second \nfunction with a single parameter also of type `Y`, return \nthe composition of the two functions. The first function \nmay have any number of parameters.\n\nFor any such functions `f()` and `g()`,\n\n    compose(g,f)(*args)==g(f(*args))\n\nfor every possible argument tuple `args` of `f()`."]},tp:[{nm:"X"},{nm:"Y"},{sts:[{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"Sequential"}],nm:"Args"}],ps:[[{$t:{tp:[{mt:"tp",nm:"X"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"Y"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Y"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}],pk:".",nm:"Callable"},mt:"prm",nm:"x"},{$t:{tp:[{mt:"tp",nm:"Y"},{mt:"tp",nm:"Args"}],pk:".",nm:"Callable"},mt:"prm",nm:"y"}]],nm:"compose"},sealed:{$t:{pk:".",nm:"SealedAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to mark an interface, class, or constructor as \nsealed. A `sealed` interface may not be satisfied outside \nof the module in which it is defined. A `sealed` class may \nnot be extended or instantiated outside of the module in \nwhich it is defined. A `sealed` constructor may not be\ninvoked outside of the module in which it is defined."]},nm:"sealed"},DeprecationAnnotation:{super:{pk:".",nm:"Basic"},pa:545,mt:"c",an:{doc:["The annotation class for the [[deprecated]] annotation."]},sts:[{tp:[{mt:"tp",pk:".",nm:"DeprecationAnnotation"},{mt:"tp",pk:".",nm:"Annotated"},{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"OptionalAnnotation"}],$at:{reason:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"String"}]},pa:1,mt:"g",an:{doc:["A description, in Markdown syntax, of why the program \nelement is deprecated, and what alternatives are \navailable, or `null`."]},nm:"reason"},description:{$t:{pk:".",nm:"String"},pa:1,mt:"a",an:{doc:["A description, in Markdown syntax, of why the program \nelement is deprecated, and of what alternatives are \navailable."]},nm:"description"}},ps:[{$t:{pk:".",nm:"String"},pa:1,mt:"prm",an:{doc:["A description, in Markdown syntax, of why the program \nelement is deprecated, and of what alternatives are \navailable."]},nm:"description"}],nm:"DeprecationAnnotation"},Sequential:{of:[{pk:".",nm:"Empty"},{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"}],pa:1,mt:"i",an:{see:["Tuple"],doc:["A possibly-empty, immutable sequence of values. The type \n`Sequential<Element>` may be abbreviated `[Element*]` or \n`Element[]`. \n\n`Sequential` has two enumerated subtypes:\n\n- [[Empty]], abbreviated `[]`, represents an empty \n  sequence, and\n- [[Sequence]]`<Element>`, abbreviated `[Element+]` \n  represents a non-empty sequence, and has the very \n  important subclass [[Tuple]]."]},sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},{tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",nm:"Element"},{mt:"tp",tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"}],pk:".",nm:"Ranged"}],tp:[{dv:"out",def:{pk:".",nm:"Anything"},nm:"Element"}],$m:{clone:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:11,mt:"m",an:{doc:["This sequence."]},nm:"clone"},append:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],pk:".",nm:"Sequential"},pa:5,mt:"m",an:{see:["prepend","withTrailing","concatenate","chain"],doc:["Return a sequence containing the elements of this \nsequence, in the order in which they occur in this \nsequence, followed by the given [[elements]], in the \norder in which they occur in the given sequence."]},tp:[{nm:"Other"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Sequential"},mt:"prm",nm:"elements"}]],nm:"append"},prepend:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],pk:".",nm:"Sequential"},pa:5,mt:"m",an:{see:["append","withLeading","concatenate"],doc:["Return a sequence containing the given [[elements]], in \nthe order in which they occur in the given sequence,\nfollowed by the elements of this sequence, in the order \nin which they occur in this sequence."]},tp:[{nm:"Other"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Sequential"},mt:"prm",nm:"elements"}]],nm:"prepend"},trimLeading:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:11,mt:"m",an:{doc:["Trim the elements satisfying the given predicate\nfunction from the start of this sequence, returning \na sequence no longer than this sequence."]},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The predicate function that determines if an \nelement at the start of this sequence should be \ntrimmed"]},$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"trimming"}]],nm:"trimLeading"},repeat:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:7,mt:"m",an:{doc:["Produced a sequence formed by repeating the elements of\nthis sequence the given [[number of times|times]], or\nthe [[empty sequence|empty]] if `times<=0` or if this\nsequence is the empty sequence."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"times"}]],nm:"repeat"},withTrailing:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],pk:".",nm:"Sequence"},pa:5,mt:"m",an:{see:["append","withLeading"],doc:["Returns a new sequence that starts with the elements of \nthis sequence, in the order they occur in this sequence, \nand ends with the specified [[element]]."]},tp:[{nm:"Other"}],ps:[[{$t:{nm:"Other"},mt:"prm",an:{doc:["The last element of the resulting sequence."]},nm:"element"}]],nm:"withTrailing"},terminal:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:11,mt:"m",an:{doc:["Select the last elements of the sequence, returning a \nsequence no longer than the given length. If this \nsequence is shorter than the given length, return this \nsequence. Otherwise return a sequence of the given \nlength."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"terminal"},sequence:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:11,mt:"m",an:{doc:["This sequence."]},nm:"sequence"},initial:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:11,mt:"m",an:{doc:["Select the first elements of this sequence, returning \na sequence no longer than the given length. If this \nsequence is shorter than the given length, return this \nsequence. Otherwise return a sequence of the given \nlength."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"initial"},trimTrailing:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:11,mt:"m",an:{doc:["Trim the elements satisfying the given predicate\nfunction from the end of this sequence, returning a \nsequence no longer than this sequence."]},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The predicate function that determines if an \nelement at the end of this sequence should be \ntrimmed"]},$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"trimming"}]],nm:"trimTrailing"},slice:{$t:{tp:[{comp:"u",mt:"tp",l:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},{comp:"u",l:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},{pk:".",nm:"Nothing"}]},{mt:"tp",tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}],pk:".",nm:"Tuple"},pa:11,mt:"m",an:{doc:["Return two sequences, the first containing the elements\nthat occur before the given [[index]], the second with\nthe elements that occur after the given `index`. If the\ngiven `index` is outside the range of indices of this\nlist, one of the returned sequences will be empty."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"slice"},trim:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:11,mt:"m",an:{doc:["Trim the elements satisfying the given predicate\nfunction from the start and end of this sequence, \nreturning a sequence no longer than this sequence."]},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The predicate function that determines if an \nelement at the start or end of this sequence should\nbe trimmed"]},$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"trimming"}]],nm:"trim"},withLeading:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Other"},{comp:"u",l:[{nm:"Element"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"Other"},{mt:"tp",tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"}],pk:".",nm:"Tuple"},pa:5,mt:"m",an:{see:["prepend","withTrailing","follow"],doc:["Returns a new sequence that starts with the specified\n[[element]], followed by the elements of this sequence,\nin the order they occur in this sequence."]},tp:[{nm:"Other"}],ps:[[{$t:{nm:"Other"},mt:"prm",an:{doc:["The first element of the resulting sequence."]},nm:"element"}]],nm:"withLeading"}},$at:{keys:{$t:{tp:[{mt:"tp",pk:".",nm:"Integer"}],pk:".",nm:"Sequential"},pa:11,mt:"g",an:{doc:["A sequence containing all indexes of this sequence,\nthat is, every index in the range `0:sequence.size`."]},nm:"keys"},string:{$t:{pk:".",nm:"String"},pa:11,mt:"g",an:{doc:["A string of form `\"[ x, y, z ]\"` where `x`, `y`, and \n`z` are the `string` representations of the elements of \nthis collection, as produced by the iterator of the \ncollection, or the string `\"{}\"` if this collection \nis empty. If the collection iterator produces the value \n`null`, the string representation contains the string \n`\"null\"`."]},nm:"string"},reversed:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:7,mt:"a",an:{doc:["A sequence containing the elements of this sequence in\nreverse order to the order in which they occur in this\nsequence, or the [[empty sequence|empty]] if this\nsequence is the empty sequence."]},nm:"reversed"},rest:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:7,mt:"a",an:{doc:["The rest of the sequence, without the first element."]},nm:"rest"},size:{$t:{pk:".",nm:"Integer"},pa:7,mt:"a",an:{doc:["The strictly-positive length of this sequence, that is, \nthe number of elements in this sequence."]},nm:"size"}},nm:"Sequential"},Finished:{super:{pk:".",nm:"Basic"},of:[{pk:".",nm:"finished"}],pa:257,mt:"c",an:{see:["Iterator"],doc:["The type of the value that indicates that an [[Iterator]] \nis exhausted and has no more values to return."]},nm:"Finished"},Ordinal:{of:[{nm:"Other"}],pa:1,mt:"i",an:{see:["Character","Integer","Integral","Comparable","Enumerable"],doc:["Abstraction of _ordinal types_, that is, of types where \neach instance has a [[successor]] and [[predecessor]], such \nas:\n \n- types which represent or are isomorphic to the \n  mathematical integers, for example, [[Integer]] and other \n  [[Integral]] numeric types, and even [[Character]], along \n  with\n- enumerated types which are isomorphic to the mathematical\n  integers under modular arithmetic, for example, the days\n  of the week, and\n- enumerated types which are isomorphic to a bounded range \n  of integers, for example, a list of priorities.\n\nThe _increment_ operator `++` and _decrement_ operator `--`\nare defined for all types which satisfy `Ordinal`.\n\n    function increment() {\n        count++;\n    }\n\nMany ordinal types have a [[total order|Comparable]]. If an\nordinal type has a total order, then it should satisfy:\n\n- `x.successor >= x`, and\n- `x.predecessor <= x`.\n\nAn ordinal enumerated type `X` with a total order has \nwell-defined `maximum` and `minimum` values where\n`minimum<x<maximum` for any other instance `x` of `X`.\nThen the `successor` and `predecessor` operations should\nsatisfy:\n\n- `minimum.predecessor==minimum`, and\n- `maximum.successor==maximum`."],by:["Gavin"]},tp:[{dv:"out",sts:[{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Ordinal"}],nm:"Other"}],st:"Other",$at:{predecessor:{$t:{nm:"Other"},pa:5,mt:"a",an:{doc:["The predecessor of this value."]},nm:"predecessor"},successor:{$t:{nm:"Other"},pa:5,mt:"a",an:{doc:["The successor of this value."]},nm:"successor"}},nm:"Ordinal"},interleave:{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},pa:1,mt:"m",an:{see:["Iterable.interpose"],doc:["Given one or more argument [[streams|iterables]], return a\nstream containing elements of the given streams. The \nelements are ordered first according to their position in \nthe argument stream, and then according to the stream in \nwhich they occur. The resulting stream contains exactly the \nsame number of elements from each stream.\n\nFor example, the expression\n\n    interleave(1..5, \"-+\".cycled)\n\nresults in the stream \n`{ 1, '-', 2, '+', 3, '-', 4, '+', 5, '-' }`."]},tp:[{nm:"Element"},{sts:[{pk:".",nm:"Null"}],nm:"Absent"}],ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"}],pk:".",nm:"Sequence"},mt:"prm",seq:1,$min1:1,nm:"iterables"}]],nm:"interleave"},Byte:{super:{pk:".",nm:"Object"},pa:97,mt:"c",an:{doc:["An 8-bit byte. A `Byte` value represents a congruence class\nof [[integers|Integer]] modulo 256, and may be interpreted \nas:\n\n- an [[unsigned]] integer value in the range `0..255`, or \n- a [[signed]] integer value in the range `-128..127`. \n\n`Byte` is not considered a full numeric type, supporting \nonly:\n\n- [[bitwise|Binary]] operations, and \n- addition and subtraction modulo 256.\n\n`Byte`s with modular addition form a [[mathematical \ngroup|Invertible]]. Thus, every byte `b` has an additive\ninverse `-b` where:\n\n    (-b).signed == -b.signed\n    (-b).unsigned == b.unsigned==0 then 0 else 256 - b.unsigned\n\n`Byte` is a [[recursive enumerable type|Enumerable]]. For\nexample, the range:\n\n    254.byte .. 1.byte\n    \ncontains the values `254.byte, 255.byte, 0.byte, 1.byte`.\n\n`Byte` does not have a [[total order|Comparable]] because\nany such order would:\n \n- be inconsistent with the definition of [[successor]] and \n  [[predecessor]] under modular addition, and\n- would depend on interpretation of the `Byte` value as\n  signed or unsigned.\n\nThus, to compare the magnitude of two bytes, it is \nnecessary to first convert them to either their `signed` or \n`unsigned` integer values.\n\n`Byte`s are useful mainly because they can be efficiently \nstored in an [[Array]]."]},sts:[{tp:[{mt:"tp",pk:".",nm:"Byte"}],pk:".",nm:"Binary"},{tp:[{mt:"tp",pk:".",nm:"Byte"}],pk:".",nm:"Invertible"},{tp:[{mt:"tp",pk:".",nm:"Byte"}],pk:".",nm:"Enumerable"}],$m:{plus:{$t:{pk:".",nm:"Byte"},pa:67,mt:"m",an:{doc:["The modulo 256 sum of this byte and the given byte."]},ps:[[{$t:{pk:".",nm:"Byte"},mt:"prm",nm:"other"}]],nm:"plus"},xor:{$t:{pk:".",nm:"Byte"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Byte"},mt:"prm",nm:"other"}]],nm:"xor"},get:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"get"},equals:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],nm:"equals"},offsetSign:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Byte"},mt:"prm",nm:"other"}]],nm:"offsetSign"},or:{$t:{pk:".",nm:"Byte"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Byte"},mt:"prm",nm:"other"}]],nm:"or"},set:{$t:{pk:".",nm:"Byte"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"},{$t:{pk:".",nm:"Boolean"},def:1,mt:"prm",nm:"bit"}]],nm:"set"},and:{$t:{pk:".",nm:"Byte"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Byte"},mt:"prm",nm:"other"}]],nm:"and"},leftLogicalShift:{$t:{pk:".",nm:"Byte"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"shift"}]],nm:"leftLogicalShift"},rightArithmeticShift:{$t:{pk:".",nm:"Byte"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"shift"}]],nm:"rightArithmeticShift"},rightLogicalShift:{$t:{pk:".",nm:"Byte"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"shift"}]],nm:"rightLogicalShift"},neighbour:{$t:{pk:".",nm:"Byte"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"offset"}]],nm:"neighbour"},offset:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Byte"},mt:"prm",nm:"other"}]],nm:"offset"},flip:{$t:{pk:".",nm:"Byte"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"flip"}},$at:{predecessor:{$t:{pk:".",nm:"Byte"},pa:67,mt:"a",nm:"predecessor"},not:{$t:{pk:".",nm:"Byte"},pa:67,mt:"a",nm:"not"},unit:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Whether this byte is one."]},nm:"unit"},successor:{$t:{pk:".",nm:"Byte"},pa:67,mt:"a",nm:"successor"},hash:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"hash"},signed:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{doc:["This byte interpreted as a signed integer in the range \n`-128..127`."]},nm:"signed"},string:{$t:{pk:".",nm:"String"},pa:67,mt:"a",an:{doc:["The [[unsigned]] interpretation of this byte as a \nstring."]},nm:"string"},congruent$4ssbsl:{$t:{pk:".",nm:"Integer"},mt:"a",an:{doc:["An integer member of the congruence class of the \nresulting `Byte`.\n\nFor any integer `x>=0`:\n\n    x.byte.unsigned == x % 256\n    x.byte.signed == x % 256\n\nAnd for an integer `x<0`:\n\n    x.byte.unsigned == 256 + x % 256\n    x.byte.signed == x % 256\n\nAnd for any integers `x` and `y` which are congruent\nmodulo 256:\n\n    x.byte == y.byte"]},nm:"congruent"},even:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Whether this byte is even."]},nm:"even"},unsigned:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{doc:["This byte interpreted as an unsigned integer in the\nrange `0..255`."]},nm:"unsigned"},zero:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Whether this byte is zero."]},nm:"zero"},negated:{$t:{pk:".",nm:"Byte"},pa:67,mt:"a",an:{doc:["The additive inverse of this byte. For any integer `x`:\n\n    (-x.byte).signed = -x.byte.signed"]},nm:"negated"}},ps:[{$t:{pk:".",nm:"Integer"},mt:"prm",an:{doc:["An integer member of the congruence class of the \nresulting `Byte`.\n\nFor any integer `x>=0`:\n\n    x.byte.unsigned == x % 256\n    x.byte.signed == x % 256\n\nAnd for an integer `x<0`:\n\n    x.byte.unsigned == 256 + x % 256\n    x.byte.signed == x % 256\n\nAnd for any integers `x` and `y` which are congruent\nmodulo 256:\n\n    x.byte == y.byte"]},$hdn:1,nm:"congruent"}],nm:"Byte"},zipPairs:{$t:{tp:[{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"First"},{comp:"u",l:[{nm:"Second"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"First"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"Second"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Second"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}],pk:".",nm:"Tuple"},{comp:"u",mt:"tp",l:[{nm:"FirstAbsent"},{nm:"SecondAbsent"}]}],pk:".",nm:"Iterable"},pa:1,mt:"m",an:{doc:["Given two streams, form a new stream consisting of all \npairs where, for any given index in the resulting stream, \nthe first element of the pair is the element occurring at \nthe same index in the [[first stream|firstElements]], and \nthe second element of the pair is the element occurring at \nthe same index in the [[second stream|secondElements]]. The \nlength of the resulting stream is the length of the shorter \nof the two given streams.\n\nThus:\n\n    zipPairs(xs, ys)[i] == [xs[i], ys[i]]\n\nfor every `0<=i<smallest(xs.size,ys.size)`."]},tp:[{nm:"First"},{nm:"Second"},{sts:[{pk:".",nm:"Null"}],nm:"FirstAbsent"},{sts:[{pk:".",nm:"Null"}],nm:"SecondAbsent"}],ps:[[{$t:{tp:[{mt:"tp",nm:"First"},{mt:"tp",nm:"FirstAbsent"}],pk:".",nm:"Iterable"},mt:"prm",nm:"firstElements"},{$t:{tp:[{mt:"tp",nm:"Second"},{mt:"tp",nm:"SecondAbsent"}],pk:".",nm:"Iterable"},mt:"prm",nm:"secondElements"}]],nm:"zipPairs"},system:{super:{pk:".",nm:"Basic"},pa:65,mt:"o",an:{see:["process","runtime","language","operatingSystem"],doc:["Represents the system on which the current process is \nexecuting.\n\nHolds information about system time and locale."]},$at:{string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},locale:{$t:{pk:".",nm:"String"},pa:65,mt:"a",an:{doc:["Returns the IETF language tag representing the default \nlocale for this system."]},nm:"locale"},nanoseconds:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{doc:["The elapsed time in nanoseconds since an arbitrary \nstarting point."]},nm:"nanoseconds"},timezoneOffset:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{doc:["Returns the offset from UTC, in milliseconds, of the \ndefault timezone for this system."]},nm:"timezoneOffset"},milliseconds:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{doc:["The elapsed time in milliseconds since midnight, \n1 January 1970."]},nm:"milliseconds"},characterEncoding:{$t:{pk:".",nm:"String"},pa:65,mt:"a",an:{doc:["Returns the IANA character set name representing the default \ncharacter encoding for this system."]},nm:"characterEncoding"}},nm:"system"},unflatten:{$t:{nm:"Return"},pa:65,mt:"m",an:{see:["flatten"],doc:["Given a function with parameter types `P1`, `P2`, ..., `Pn`, \nreturn a function with a single parameter of tuple type \n`[P1, P2, ..., Pn]`.\n\nThat is, if `fun` has type `W(X,Y,Z)` then `unflatten(fun)` \nhas type `W([X,Y,Z])`.\n\nIn the case of a variadic function, the returned function \nhas a single parameter whose type is a sequence type or \nunterminated tuple type:\n\n- if the given function has a single variadic parameter of \n  type `S*`, the returned function accepts `[S*]`,\n- if the given function has a single variadic parameter of \n  type `S+`, the returned function accepts `[S+]`,\n- if the given function has multiple parameters with types\n  `P1`, `P2`, ..., `Pn`, `S*`, the returned function \n  accepts `[P1, P2, ..., Pn, S*]`, or\n- if the given function has multiple parameters with types\n  `P1`, `P2`, ..., `Pn`, `S+`, the returned function \n  accepts `[P1, P2, ..., Pn, S+]`."]},tp:[{nm:"Return"},{sts:[{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"Sequential"}],nm:"Args"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Return"},{mt:"tp",nm:"Args"}],pk:".",nm:"Callable"},mt:"prm",nm:"flatFunction"}],[{$t:{nm:"Args"},mt:"prm",nm:"args"}]],nm:"unflatten"},native:{$t:{pk:".",nm:"NativeAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to mark a member whose implementation is defined \nin platform-native code."]},ps:[[{$t:{pk:".",nm:"String"},def:1,mt:"prm",nm:"backend"}]],nm:"native"},formatInteger:{$t:{pk:".",nm:"String"},pa:1,mt:"m",an:{see:["parseInteger"],throws:["AssertionError","if [[radix]] is not between [[minRadix]] and \n[[maxRadix]]"],doc:["The string representation of the given [[integer]] in the \nbase given by [[radix]]. If the given integer is negative, \nthe string representation will begin with `-`. Digits \nconsist of decimal digits `0` to `9`, together with and \nlowercase letters `a` to `z` for bases greater than 10.\n\nFor example:\n\n- `formatInteger(-46)` is `\"-46\"`\n- `formatInteger(9,2)` is `\"1001\"`\n- `formatInteger(10,8)` is `\"12\"`\n- `formatInteger(511,16)` is `\"1ff\"`\n- `formatInteger(512,32)` is `\"g0\"`"]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",an:{doc:["The integer value to format."]},nm:"integer"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The base, between [[minRadix]] and [[maxRadix]] \ninclusive."]},nm:"radix"}]],nm:"formatInteger"},Identifiable:{pa:1,mt:"i",an:{doc:["The abstract supertype of all types with a well-defined\nnotion of identity. Values of type `Identifiable` may be \ncompared using the `===` operator to determine if they are \nreferences to the same object instance.\n\nFor the sake of convenience, this interface defines a \ndefault implementation of value equality equivalent to \nidentity. Of course, subtypes are encouraged to refine this \nimplementation."],by:["Gavin"]},$m:{equals:{$t:{pk:".",nm:"Boolean"},pa:11,mt:"m",an:{doc:["Identity equality comparing the identity of the two \nvalues. May be refined by subtypes for which value \nequality is more appropriate. Implementations must\nrespect the constraint that if `x===y` then `x==y` \n(equality is consistent with identity)."]},ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],nm:"equals"}},$at:{hash:{$t:{pk:".",nm:"Integer"},pa:11,mt:"g",an:{see:["identityHash"],doc:["The system-defined identity hash value of the instance. \nSubtypes which refine `equals()` must also refine \n`hash`, according to the general contract defined by \n[[Object]]."]},nm:"hash"}},nm:"Identifiable"},Throwable:{super:{pk:".",nm:"Basic"},pa:337,mt:"c",an:{doc:["The abstract supertype of values indicating exceptional \nconditions. An exception may be raised using the `throw` \nstatement, and handled using the `catch` clause of the `try` \nstatement. An instance of `Throwable` may be passed from\n`throw` to `catch`.\n    \n    void tryToDoIt() {\n        if (canDoIt()) {\n            doIt();\n        }\n        else {\n            throw CantDoIt(); \/\/the Throwable\n        }\n    }\n    \n    try {\n        tryToDoIt();\n    }\n    catch (CantDoIt e) {\n        e.printStackTrace();\n    }\n\nAn instance of `Throwable` represents a problem, typically \nan _unexpected failure_. Either:\n\n- a unrecoverable error in the program, especially an \n  [[AssertionError]], or\n- a transient, and possibly-recoverable [[Exception]].\n\nThe use of the exceptions facility to manage _expected \nfailures_, that is, failures that are usually handled by \nthe immediate caller of an operation, is discouraged. \nInstead, the failure should be represented as a return \nvalue of the operation being called.\n\nFor example, nonexistence of a file should not result in an \nexception. Instead, an `openFile()` operation should return \nthe type `File?`, where a `null` return value indicates \nnonexistence. On the other hand, failure to read from an\nalready open file could result in an `Exception`."],by:["Gavin","Tom"]},$m:{addSuppressed:{$t:{pk:".",nm:"Anything"},pa:65,mt:"m",an:{doc:["The given exception was suppressed in order to \npropagate this exception."]},ps:[[{$t:{pk:".",nm:"Throwable"},mt:"prm",nm:"suppressed"}]],nm:"addSuppressed"},printStackTrace:{$t:{pk:".",nm:"Anything"},pa:1,mt:"m",an:{see:["printTrace"],doc:["Print the stack trace to the standard error of the \nvirtual machine process."]},nm:"printStackTrace"}},$at:{message:{$t:{pk:".",nm:"String"},pa:9,mt:"g",an:{see:["cause"],doc:["A message describing the problem. This default \nimplementation returns the description, if any, or \notherwise the message of the cause, if any."]},nm:"message"},suppressed:{$t:{tp:[{mt:"tp",pk:".",nm:"Throwable"}],pk:".",nm:"Sequential"},pa:65,mt:"a",an:{doc:["The exceptions that were suppressed in order to \npropagate this exception."]},nm:"suppressed"},cause:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Throwable"}]},pa:1,mt:"a",an:{doc:["The underlying cause of this exception."]},nm:"cause"},string:{$t:{pk:".",nm:"String"},pa:11,mt:"g",nm:"string"},description$arbt90:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"String"}]},mt:"a",an:{doc:["A description of the problem."]},nm:"description"}},ps:[{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"String"}]},def:1,mt:"prm",an:{doc:["A description of the problem."]},$hdn:1,nm:"description"},{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Throwable"}]},def:1,pa:1,mt:"prm",an:{doc:["The underlying cause of this exception."]},$hdn:1,nm:"cause"}],nm:"Throwable"},Null:{super:{pk:".",nm:"Anything"},of:[{pk:".",nm:"null"}],pa:257,mt:"c",an:{see:["null"],doc:["The type of the [[null]] value. Any union type of form \n`Null|T` is considered an _optional_ type, whose values\ninclude `null`. Any type of this form may be written as\n`T?` for convenience.\n\nThe `if (exists ... )` construct, or, alternatively,\n`assert (exists ...)`, may be used to narrow an optional \ntype to a _definite_ type, that is, a subtype of \n[[Object]]:\n\n    String? firstArg = process.arguments.first;\n    if (exists firstArg) {\n        print(\"hello \" + firstArg);\n    }\n\nThe `else` operator evaluates its second operand if and \nonly if its first operand is `null`:\n\n    String name = process.arguments.first else \"world\";\n\nThe `then` operator evaluates its second operand when\nits first operand evaluates to `true`, and to `null` \notherwise:\n\n    Float? diff = x>=y then x-y;\n\nNo equivalence relation is defined for `Null`. In \nparticular, neither `null==null` nor `null===null` are\nconsidered meaningful. Therefore, `Null` is neither\n[[Identifiable]], nor does it define \n[[value equality|Object.equals]]."],by:["Gavin"]},nm:"Null"},JoinedSequence:{super:{pk:".",nm:"Object"},mt:"c",sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"}],tp:[{nm:"Element"}],$m:{iterator:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},measure:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"measure"},spanTo:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"spanTo"},slice:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},{mt:"tp",tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},{mt:"tp",tp:[{mt:"tp",tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},{mt:"tp",tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}],pk:".",nm:"Tuple"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"slice"},spanFrom:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],nm:"spanFrom"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromFirst"},span:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"span"}},$at:{last:{$t:{nm:"Element"},pa:3,mt:"g",nm:"last"},secondSeq$g3ri2t:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"},mt:"a",nm:"secondSeq"},rest:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"g",nm:"rest"},first:{$t:{nm:"Element"},pa:3,mt:"g",nm:"first"},firstSeq$vc5yc7:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"},mt:"a",nm:"firstSeq"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"}},ps:[{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"},mt:"prm",nm:"firstSeq"},{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"},mt:"prm",nm:"secondSeq"}],nm:"JoinedSequence"},sort:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:1,mt:"m",an:{see:["Comparable","Iterable.sort"],doc:["Sort the given elements according to their \n[[natural order|Comparable]], returning a new \n[[sequence|Sequential]].\n\nNote that [[Iterable.sort]] may be used to sort any stream\naccording to a given comparator function."]},tp:[{sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Comparable"}],nm:"Element"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"elements"}]],nm:"sort"},comparing:{$t:{pk:".",nm:"Comparison"},pa:1,mt:"m",an:{see:["byDecreasing","byIncreasing","Iterable.max","Iterable.sort"],doc:["A single comparator function which delegates to each of the \ngiven [[comparator functions|comparators]] in turn, \nreturning the first result of [[smaller]] or [[larger]] if \nany, or returning [[equal]] otherwise.\n\nConsider the following type:\n\n    class Person(shared Integer age, shared String name) {}\n\nA stream of `Person`s may be sorted by `age`, breaking ties \nby `name`, like this:\n\n    people.sort(comparing(byDecreasing(Person.age), byIncreasing(Person.name)))\n\nIf no `comparators` are given, the resulting comparator\nalways returns `equal`.\n\nThis function is intended for use with [[Iterable.sort]]\nand [[Iterable.max]]."]},tp:[{dv:"in",nm:"Value"}],ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:".",nm:"Comparison"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{comp:"u",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"Value"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Value"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}],pk:".",nm:"Tuple"}],pk:".",nm:"Callable"}],pk:".",nm:"Sequential"},mt:"prm",seq:1,nm:"comparators"}],[{$t:{nm:"Value"},mt:"prm",nm:"x"},{$t:{nm:"Value"},mt:"prm",nm:"y"}]],nm:"comparing"},Usable:{of:[{pk:".",nm:"Destroyable"},{pk:".",nm:"Obtainable"}],pa:1,mt:"i",an:{doc:["Abstract supertype of resources whose lifecyle may be\nmanaged by the `try` statement."]},nm:"Usable"},arrayOfSize:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Array"},pa:1,mt:"m",an:{deprecated:["Use [[Array.OfSize]]"],see:["runtime.maxArraySize"],throws:["AssertionError","if `size>runtime.maxArraySize`"],doc:["Create an array of the specified [[size]], populating every \nindex with the given [[element]]. The specified `size` must \nbe no larger than [[runtime.maxArraySize]]. If `size<=0`, \nthe new array will have no elements."]},tp:[{nm:"Element"}],ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",an:{doc:["The size of the resulting array. If the size is \nnon-positive, an empty array will be created."]},nm:"size"},{$t:{nm:"Element"},mt:"prm",an:{doc:["The element value with which to populate the array.\nAll elements of the resulting array will have the \nsame value."]},nm:"element"}]],nm:"arrayOfSize"},OptionalImportAnnotation:{super:{pk:".",nm:"Basic"},pa:545,mt:"c",an:{doc:["The annotation class for the [[optional]] annotation."]},sts:[{tp:[{mt:"tp",pk:".",nm:"OptionalImportAnnotation"},{mt:"tp",pk:"ceylon.language.meta.declaration",nm:"Import"},{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"OptionalAnnotation"}],nm:"OptionalImportAnnotation"},everyPair:{$t:{pk:".",nm:"Boolean"},pa:1,mt:"m",an:{see:["corresponding","anyPair"],doc:["Given two streams, return `true` if every pair of elements \nin the given streams satisfies the given binary [[predicate\nfunction|selecting]], or `false` otherwise. If one of the\nstreams is longer than the other, simply ignore additional \nelements of the longer stream with no pair in the other \nstream. If either stream is empty, return `true`.\n\nFor any given streams `xs` and `ys`, and predicate function \n`p`, `everyPair()` may be defined in terms of \n[[Iterable.every]], [[zipPairs]], and [[unflatten]]:\n\n    everyPair(p, xs, ys) == zipPairs(xs, ys).every(unflatten(p))"]},tp:[{nm:"First"},{nm:"Second"}],$m:{selecting$dw9v1x:{$t:{pk:".",nm:"Boolean"},mt:"m",an:{doc:["The binary predicate function to apply to each pair of \nelements."]},ps:[[{$t:{nm:"First"},mt:"prm",nm:"first"},{$t:{nm:"Second"},mt:"prm",nm:"second"}]],nm:"selecting"}},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The binary predicate function to apply to each pair of \nelements."]},$pt:"f",ps:[[{$t:{nm:"First"},mt:"prm",nm:"first"},{$t:{nm:"Second"},mt:"prm",nm:"second"}]],nm:"selecting"},{$t:{tp:[{mt:"tp",nm:"First"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"firstIterable"},{$t:{tp:[{mt:"tp",nm:"Second"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"secondIterable"}]],nm:"everyPair"},times:{$t:{nm:"Value"},pa:1,mt:"m",an:{see:["plus","product"],doc:["Multiply the given [[Numeric]] values.\n\n    (1..100).by(2).fold(1)(times<Integer>)"]},tp:[{sts:[{tp:[{mt:"tp",nm:"Value"}],pk:".",nm:"Numeric"}],nm:"Value"}],ps:[[{$t:{nm:"Value"},mt:"prm",nm:"x"},{$t:{nm:"Value"},mt:"prm",nm:"y"}]],nm:"times"},Invertible:{of:[{nm:"Other"}],pa:1,mt:"i",an:{see:["Integer","Float"],doc:["Abstraction of [[additive|Summable]] numeric types which \nsupport a unary operation `-x` producing the additive\ninverse of `x`. Every `Invertible` type supports a binary \nsubtraction operation `x-y`.\n\n    Integer negativeOne = -1;\n    Float delta = x-y;\n\nA concrete class that implements this interface should be a \nmathematical _group_. That is, it should have an additive \nidentity, denoted `0`, and satisfy:\n\n- `0+x == x+0 == x`\n- `x + -x == 0`\n\nSubtraction must be defined so that it is consistent with\nthe additive inverse:\n\n- `x - y == x + -y`"],by:["Gavin"]},sts:[{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Summable"}],tp:[{sts:[{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Invertible"}],nm:"Other"}],st:"Other",$m:{minus:{$t:{nm:"Other"},pa:9,mt:"m",an:{doc:["The difference between this number and the given \nnumber. Must produce the value `x + -y`."]},ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],nm:"minus"}},$at:{negated:{$t:{nm:"Other"},pa:5,mt:"a",an:{doc:["The additive inverse of this value."]},nm:"negated"}},nm:"Invertible"},loop:{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Iterable"},pa:1,mt:"m",an:{doc:["Produces the [[stream|Iterable]] that results from repeated \napplication of the given [[function|next]] to the given \n[[first]] element of the stream. The stream is infinite.\n\nFor example:\n\n    loop(0)(2.plus).takeWhile(10.largerThan)\n\nproduces the stream `{ 0, 2, 4, 6, 8 }`."]},tp:[{nm:"Element"}],$m:{next$nr9e8n:{$t:{nm:"Element"},mt:"m",an:{doc:["The function that produces the next element of the\nstream, given the current element."]},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"next"}},$o:{iterable$cridai:{super:{pk:".",nm:"Basic"},mt:"o",sts:[{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Iterable"}],$m:{iterator:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"},pa:3,mt:"m",$o:{iterator$h1tkyg:{super:{pk:".",nm:"Basic"},mt:"o",sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"}],$m:{next:{$t:{comp:"u",l:[{nm:"Element"},{pk:".",nm:"Finished"}]},pa:3,mt:"m",nm:"next"}},nm:"iterator"}},nm:"iterator"},nextElement$gvzcve:{$t:{nm:"Element"},mt:"m",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"nextElement"}},$at:{empty:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"g",nm:"empty"},first:{$t:{nm:"Element"},pa:3,mt:"g",nm:"first"},size:{$t:{pk:".",nm:"Nothing"},pa:3,mt:"g",nm:"size"}},nm:"iterable"}},ps:[[{$t:{nm:"Element"},mt:"prm",an:{doc:["The first element of the resulting stream."]},nm:"first"}],[{$t:{nm:"Element"},mt:"prm",an:{doc:["The function that produces the next element of the\nstream, given the current element."]},$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"next"}]],nm:"loop"},license:{$t:{pk:".",nm:"LicenseAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to specify the URL of the license of a module or \npackage."]},ps:[[{$t:{pk:".",nm:"String"},mt:"prm",an:{doc:["The name, text, or URL of the license."]},nm:"description"}]],nm:"license"},"$pkg-pa":1,deprecated:{$t:{pk:".",nm:"DeprecationAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to mark program elements which should not be \nused anymore."]},ps:[[{$t:{pk:".",nm:"String"},def:1,mt:"prm",an:{doc:["A description, in Markdown syntax, of why the program \nelement is deprecated, and what alternatives are \navailable."]},nm:"reason"}]],nm:"deprecated"},Range:{super:{pk:".",nm:"Object"},of:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Span"},{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Measure"}],pa:273,mt:"c",an:{see:["makeSpan","makeMeasure"],doc:["A range of adjacent [[Enumerable]] values. Two values of an\nenumerable type are considered _adjacent_ if their \n[[offset|Enumerable.offset]] is of unit or zero magnitude. \nThus, a `Range` is a list of values where for every integer \n`index` where both `index` and `index+1` fall within the \nindices of the range:\n\n    range[index+1].offset(range[index]).magnitude <= 1\n\nA range is always nonempty, containing at least one value.\nThus, it is a [[Sequence]].\n\nA sequence of adjacent values may be represented very \nefficiently in memory, either:\n\n- via its endpoints, `first..last`, or \n- via an endpoint and length, `first:size`.\n\nFurthermore, certain operations are much more efficient \nthan for other lists, assuming that the enumerable type has \nefficient [[neighbour|Enumerable.neighbour]] and\n[[offset|Enumerable.offset]] functions.\n\nThe functions [[ceylon.language::span]] and \n[[ceylon.language::measure]], and corresponding operators \n`..` and `:` are used to create new instances of `Range`."],serializable:[]},sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"}],tp:[{sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Enumerable"}],nm:"Element"}],$m:{shifted:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Range"},pa:5,mt:"m",an:{doc:["Returns a range of the same length and type as this\n   range, with its endpoints shifted by the given number \n   of elements, where:\n   \n   - a negative [[shift]] measures \n     [[decrements|Ordinal.predecessor]], and \n   - a positive `shift` measures \n     [[increments|Ordinal.successor]]."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"shift"}]],nm:"shifted"},includesRange:{$t:{pk:".",nm:"Boolean"},pa:5,mt:"m",an:{doc:["Determines if this range includes the given range."]},ps:[[{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Range"},mt:"prm",nm:"range"}]],nm:"includesRange"},contains:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],nm:"contains"},containsElement:{$t:{pk:".",nm:"Boolean"},pa:5,mt:"m",an:{doc:["Determines if this range includes the given value."]},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"containsElement"},occurs:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",nm:"element"}]],nm:"occurs"}},$at:{decreasing:{$t:{pk:".",nm:"Boolean"},pa:5,mt:"a",an:{doc:["Determines if the range is decreasing, that is, if\npredecessors occur after successors."]},nm:"decreasing"},coalesced:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Range"},pa:3,mt:"g",an:{doc:["Returns the range itself, since a range cannot contain \nnull elements."]},nm:"coalesced"},increasing:{$t:{pk:".",nm:"Boolean"},pa:5,mt:"a",an:{doc:["Determines if the range is increasing, that is, if\nsuccessors occur after predecessors."]},nm:"increasing"}},nm:"Range"},Integral:{of:[{nm:"Other"}],pa:1,mt:"i",an:{see:["Integer"],doc:["Abstraction of integral numeric types. That is, types \nwith no fractional part, including [[Integer]].\n\nThe division operation for integral numeric types results \nin a remainder. Therefore, integral numeric types have \n[[an operation|remainder]], denoted by the _remainder_\noperator `%`, to determine the remainder of any division \noperation.\n\n    if (n%2==0) {\n        print(\"Even!\");\n    }\n\nDivision and the remainder operation should satisfy: \n\n- `x == (x\/y)*y + x%y`\n\nfor any instance `y` other than `0`.\n\nAll `Integral` numeric types are also [[Enumerable]], so \nranges of integral values may be produced using the \n[[measure]] and [[span]] operators.\n    \n    \/\/ Iterate from 0 to 100 inclusive\n    for (i in 0..100) {\n        print(\"The square of ``i`` is ``i^2``\");\n    }\n    \n    \/\/ Iterate all indices of the array, \n    \/\/ from 0 to array.size-1\n    for (i in 0:array.size) {\n        print(array[i]);\n    }"],by:["Gavin"]},sts:[{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Number"},{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Enumerable"}],tp:[{sts:[{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Integral"}],nm:"Other"}],st:"Other",$m:{remainder:{$t:{nm:"Other"},pa:5,mt:"m",an:{see:["Numeric.divided"],doc:["The remainder, after dividing this number by the given \nnumber."]},ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],nm:"remainder"},divides:{$t:{pk:".",nm:"Boolean"},pa:9,mt:"m",an:{doc:["Determine if this number is a factor of the given \nnumber."]},ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],nm:"divides"}},$at:{unit:{$t:{pk:".",nm:"Boolean"},pa:5,mt:"a",an:{doc:["Determine if the number is the multiplicative identity."]},nm:"unit"},zero:{$t:{pk:".",nm:"Boolean"},pa:5,mt:"a",an:{doc:["Determine if the number is the additive identity."]},nm:"zero"}},nm:"Integral"},max:{$t:{comp:"u",l:[{nm:"Absent"},{nm:"Value"}]},pa:1,mt:"m",an:{see:["Comparable","min","largest","Iterable.max"],doc:["Given a stream of [[Comparable]] values, return the largest \nvalue in the stream, or `null` if the stream is empty.\n\nFor any nonempty stream `it`, `max(it)` evaluates to the \nfirst element of `it` such that for every element `e` of \n`it`, `max(it) >= e`.\n\nNote that [[Iterable.max]] may be used to find the largest \nvalue in any stream, as determined by a given comparator \nfunction."]},tp:[{sts:[{tp:[{mt:"tp",nm:"Value"}],pk:".",nm:"Comparable"}],nm:"Value"},{sts:[{pk:".",nm:"Null"}],nm:"Absent"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Value"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},mt:"prm",nm:"values"}]],nm:"max"},suppressWarnings:{$t:{pk:".",nm:"SuppressWarningsAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to suppress compilation warnings of the \n[[specified types|warnings]] when typechecking the \nannotated program element."]},ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"String"}],pk:".",nm:"Sequential"},mt:"prm",an:{doc:["The warning types to suppress.\n\nAllowed warning types are:\n`filenameNonAscii`,\n`filenameCaselessCollision`,\n`deprecation`,\n`compilerAnnotation`,\n`doclink`,\n`expressionTypeNothing`,\n`unusedDeclaration`,\n`unusedImport`,\n`ceylonNamespace`,\n`javaNamespace,` \n`suppressedAlready`, \n`suppressesNothing`, \n`unknownWarning`, \n`ambiguousAnnotation`,\n`javaAnnotationElement`."]},seq:1,nm:"warnings"}]],nm:"suppressWarnings"},increasing:{$t:{pk:".",nm:"Comparison"},pa:1,mt:"m",an:{see:["decreasing","byIncreasing","Iterable.max","Iterable.sort"],doc:["A comparator function which orders elements in increasing \n[[natural order|Comparable]].\n\n       \"Hello World!\".sort(increasing)\n\nThis function is intended for use with [[Iterable.sort]]\nand [[Iterable.max]]."]},tp:[{sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Comparable"}],nm:"Element"}],ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],nm:"increasing"},Character:{super:{pk:".",nm:"Object"},pa:97,mt:"c",an:{see:["String"],doc:["A 32-bit [Unicode][] character.\n\nLiteral characters may be written between single quotes:\n\n    ' '\n    '\\n'\n    '\\{#03C0}'\n    '\\{GREEK SMALL LETTER PI}'\n\nEvery `Character` has a unique [[Integer]]-valued Unicode \n_code point_.\n\n    Integer piCodePoint = '\\{GREEK SMALL LETTER PI}'.integer; \/\/ #03C0\n    Character pi = #03C0.character; \/\/ GREEK SMALL LETTER PI\n\nCharacters are [[Enumerable]], so character ranges may be\nproduced using the [[measure]] and [[span]] operators.\n\n    value lowerLatinLetters = 'a'..'z';\n    value upperLatinLetters = 'A':26;\n\nCharacters have a [[natural order|Comparable]] determined\nby their Unicode code points. So, for example, `'a'<'b'`,\nsince `'a'.integer<'b'.integer`.\n\n[Unicode]: http:\/\/www.unicode.org\/"],by:["Gavin"]},sts:[{tp:[{mt:"tp",pk:".",nm:"Character"}],pk:".",nm:"Comparable"},{tp:[{mt:"tp",pk:".",nm:"Character"}],pk:".",nm:"Enumerable"}],$m:{notLargerThan:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"other"}]],nm:"notLargerThan"},largerThan:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"other"}]],nm:"largerThan"},notSmallerThan:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"other"}]],nm:"notSmallerThan"},offsetSign:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"other"}]],nm:"offsetSign"},equals:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",an:{doc:["Determines if the given object is a character with the\nsame code point as this character."]},ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],nm:"equals"},compare:{$t:{pk:".",nm:"Comparison"},pa:67,mt:"m",an:{doc:["Compare this character with the given string character, \naccording to the Unicode code points of the characters."]},ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"other"}]],nm:"compare"},smallerThan:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"other"}]],nm:"smallerThan"},offset:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"other"}]],nm:"offset"},neighbour:{$t:{pk:".",nm:"Character"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"offset"}]],nm:"neighbour"}},$at:{control:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Determine if this character is an ISO control \ncharacter."]},nm:"control"},successor:{$t:{pk:".",nm:"Character"},pa:67,mt:"a",an:{doc:["The character with the unicode code point that is one\nless than this character."]},nm:"successor"},hash:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",an:{doc:["The code point of the character."]},nm:"hash"},integer:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{doc:["The Unicode code point of the character, an [[Integer]]\nin the range `0..#10FFFF`."]},nm:"integer"},lowercased:{$t:{pk:".",nm:"Character"},pa:65,mt:"a",an:{see:["String.lowercased"],doc:["The lowercase representation of this character.\n\nConversion of uppercase characters to lowercase is\nperformed according to a locale-independent mapping\nthat produces incorrect results in certain locales\n(e.g. `tr-TR`).\n\nFurthermore, this conversion always produces a single\ncharacter, which is incorrect for characters whose\nuppercase representation comprises multiple characters,\nfor example . \nThus,\n\n- `''.uppercased`\n  evaluates to `'i'`, whereas\n- `\"\".uppercased`\n  evaluates, more correctly, to the string \n  `\"i\"`.\n\nTherefore, for most purposes, it is better to use \n`char.string.lowercased` instead of `char.lowercased`."]},nm:"lowercased"},letter:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Determine if this character is a letter. That is, if \nits Unicode general category is *Lu*, *Ll*, *Lt*, *Lm*,\nor *Lo*."]},nm:"letter"},uppercased:{$t:{pk:".",nm:"Character"},pa:65,mt:"a",an:{see:["String.uppercased"],doc:["The uppercase representation of this character, in the\n[[system]] default locale.\n\nConversion of lowercase characters to uppercase is\nperformed according to a locale-independent mapping\nthat produces incorrect results in certain locales\n(e.g. `tr-TR`).\n\nFurthermore, this conversion always produces a single\ncharacter, which is incorrect for characters whose\nuppercase representation comprises multiple characters,\nfor example . Thus,\n\n- `''.uppercased`\n  evaluates to `''`, \n  whereas\n- `\"\".uppercased`\n  evaluates, more correctly, to the string `\"SS\"`.\n\nTherefore, for most purposes, it is better to use \n`char.string.uppercased` instead of `char.uppercased`."]},nm:"uppercased"},whitespace:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Determine if this character is a whitespace character. \nThe following characters are whitespace characters:\n\n- *LINE FEED*, `\\n` or `\\{#000A}`,\n- *FORM FEED*, `\\f` or `\\{#000C}`,\n- *CARRIAGE RETURN*, `\\r` or `\\{#000D}`,\n- *HORIZONTAL TABULATION*, `\\t` or `\\{#0009}`,\n- *VERTICAL TABULATION*, `\\{#000B}`,\n- *FILE SEPARATOR*, `\\{#001C}`,\n- *GROUP SEPARATOR*, `\\{#001D}`,\n- *RECORD SEPARATOR*, `\\{#001E}`,\n- *UNIT SEPARATOR*, `\\{#001F}`, and\n- any Unicode character in the general category *Zs*, \n  *Zl*, or *Zp* that is not a non-breaking space."]},nm:"whitespace"},titlecased:{$t:{pk:".",nm:"Character"},pa:65,mt:"a",an:{doc:["The title case representation of this character."]},nm:"titlecased"},character$f3csq2:{$t:{pk:".",nm:"Character"},mt:"a",nm:"character"},predecessor:{$t:{pk:".",nm:"Character"},pa:67,mt:"a",an:{doc:["The character with the unicode code point that is one\ngreater than this character."]},nm:"predecessor"},uppercase:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Determine if this is an uppercase representation of the\ncharacter. That is, if its Unicode general category is \n*Lu*."]},nm:"uppercase"},digit:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Determine if this character is a numeric digit. That \nis, if its Unicode general category is *Nd*."]},nm:"digit"},lowercase:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Determine if this is a lowercase representation of the\ncharacter. That is, if its Unicode general category is \n*Ll*."]},nm:"lowercase"},string:{$t:{pk:".",nm:"String"},pa:67,mt:"a",an:{doc:["A string containing just this character."]},nm:"string"},titlecase:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Determine if this is a title case representation of the\ncharacter. That is, if its Unicode general category is \n*Lt*."]},nm:"titlecase"}},ps:[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"character"}],nm:"Character"},forItem:{$t:{nm:"Result"},pa:1,mt:"m",an:{see:["forKey"],doc:["A function that returns the result of applying the given \n[[function|resulting]] to the [[item|Entry.item]] \nof a given [[Entry]], discarding its `key`.\n    \n    Map<String,List<Item>> map = ... ;\n    {Item?*} topItems = map.map(forItem(List<Item>.first));"]},tp:[{nm:"Item"},{nm:"Result"}],ps:[[{$t:{nm:"Result"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Item"},mt:"prm",nm:"item"}]],nm:"resulting"}],[{$t:{tp:[{mt:"tp",pk:".",nm:"Object"},{mt:"tp",nm:"Item"}],pk:".",nm:"Entry"},mt:"prm",nm:"entry"}]],nm:"forItem"},sequence:{$t:{comp:"u",l:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"},{nm:"Absent"}]},pa:1,mt:"m",an:{see:["Iterable.sequence"],doc:["A [[nonempty sequence|Sequence]] of the given [[elements]], \nor  `null` if the given stream is empty. A non-null, but\npossibly empty, [[sequence|Sequential]] may be obtained \nusing the `else` operator:\n\n    [Element*] sequenceOfElements = sequence(elements) else [];"],by:["Gavin"]},tp:[{nm:"Element"},{def:{pk:".",nm:"Null"},sts:[{pk:".",nm:"Null"}],nm:"Absent"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},mt:"prm",nm:"elements"}]],nm:"sequence"},ConstrainedAnnotation:{of:[{nm:"Value"}],pa:1,mt:"i",an:{see:["Annotation","OptionalAnnotation","SequencedAnnotation"],doc:["An annotation constrained to appear only on certain program \nelements, and only with certain values. \n\nThis interface should never be satisfied directly by any\nannotation type. Instead, either [[OptionalAnnotation]] or \n[[SequencedAnnotation]] should be satisfied by the \nannotation type.\n\nThe type parameters encode information about the annotation\ntype and its constraints:\n\n - [[Value]] represents the type of the annotation itself, \n - [[ProgramElement]] represents a constraint on the  \n   _reference expression type_ of the annotated program \n   element, for example, \n   [[ceylon.language.meta.declaration::ClassDeclaration]] \n   or [[ceylon.language.meta.declaration::Module]], where\n   [[Annotated]] means there is no constraint, and\n - [[Type]] is a constraint on the metamodel type of the \n   annotated program element, for example, \n   [[`Function<Float,[Float,Float]>`\n    |ceylon.language.meta.model::Function]], \n   where `Anything` means there is no constraint, and that \n   the program element need not have a metamodel type."]},sts:[{pk:".",nm:"Annotation"}],tp:[{dv:"out",def:{pk:".",nm:"Annotation"},sts:[{pk:".",nm:"Annotation"}],nm:"Value"},{dv:"out",def:{pk:".",nm:"Anything"},nm:"Values"},{dv:"in",def:{pk:".",nm:"Nothing"},sts:[{pk:".",nm:"Annotated"}],nm:"ProgramElement"},{dv:"out",def:{pk:".",nm:"Anything"},nm:"Type"}],st:"Value",nm:"ConstrainedAnnotation"},Annotation:{of:[{tp:[{mt:"tp",pk:".",nm:"Annotation"},{mt:"tp",pk:".",nm:"Anything"},{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"ConstrainedAnnotation"}],pa:1,mt:"i",an:{see:["OptionalAnnotation","SequencedAnnotation","annotations","optionalAnnotation","sequencedAnnotations"],doc:["The supertype of all *annotation classes*. \n\n### Annotation classes\n\nAn *annotation class* must satisfy `Annotation`,\n[[OptionalAnnotation]],  or [[SequencedAnnotation]] and \nmust be annotated `final annotation`. For example:\n\n    \"An annotation class.\"\n    final annotation class Example(shared String description) \n          satisfies Annotation {}\n\nAnnotation classes which satisfy `Annotation` directly \nmay be applied to any program element that supports \nannotations (see [[Annotated]]). In practice, annotation \nclasses often satisfy [[OptionalAnnotation]] or \n[[SequencedAnnotation]] in order to prevent annotations \nbeing applied to inappropriate program elements.\n\nEach initializer parameter of an annotation class must \nhave one of the following types:\n\n* `Integer`, `Float`, `Character`, or `String`,\n* an enumerated type whose cases are all anonymous \n  classes, such as `Boolean`,\n* a subtype of [[ceylon.language.meta.declaration::Declaration]]\n* an annotation class,\n* `{T*}` or `[T*]` where `T` is a legal annotation \n  parameter type, or\n* any tuple type whose element types are legal annotation \n  parameter types.\n\nAn initializer parameter of an annotation class may be \nvariadic or defaulted.\n\n### Annotation constructors\n\nAn *annotation constructor* is simply a top level \nfunction, annotated with `annotation` whose return type \nis an annotation class type. For example:\n\n    \"An annotation constructor.\"\n    annotation Example example(String description=\"\") \n        => Example(description);\n\nEach parameter of an annotation constructor must have one \nof the following types:\n\n* `Integer`, `Float`, `Character`, or `String`,\n* an enumerated type whose cases are all anonymous classes, \n  such as `Boolean`,\n* a subtype of [[ceylon.language.meta.declaration::Declaration]],\n* an annotation type,\n* `{T*}` or `[T*]` where `T` is a legal annotation \n  constructor parameter type, or\n* any tuple type whose element types are legal annotation \n  constructor parameter types.\n\nA parameter of an annotation constructor may be variadic \nor defaulted.\n\nThe constructor must simply instantiate and return the \nannotation class, and there are strict rules about the \narguments to the instantiation.\n\nA given annotation class can have multiple annotation \nconstructors."]},nm:"Annotation"},doc:{$t:{pk:".",nm:"DocAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to specify API documentation of a program\nelement."]},ps:[[{$t:{pk:".",nm:"String"},mt:"prm",an:{doc:["Documentation, in Markdown syntax, about the annotated element"]},nm:"description"}]],nm:"doc"},nothing:{$t:{pk:".",nm:"Nothing"},pa:1,mt:"g",an:{throws:["AssertionError","when evaluated"],doc:["A value getter of type `Nothing`. The expression `nothing`\nis formally assignable to any type, but produces an \nexception when evaluated.\n\n(This is most useful for tool-generated implementations of\n`formal` members.)"]},nm:"nothing"},AuthorsAnnotation:{super:{pk:".",nm:"Basic"},pa:545,mt:"c",an:{doc:["The annotation class for the [[by]] annotation."]},sts:[{tp:[{mt:"tp",pk:".",nm:"AuthorsAnnotation"},{mt:"tp",pk:".",nm:"Annotated"},{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"OptionalAnnotation"}],$at:{authors:{$t:{tp:[{mt:"tp",pk:".",nm:"String"}],pk:".",nm:"Sequential"},pa:1,mt:"a",an:{doc:["The authors, in Markdown syntax, of the annotated \nprogram element"]},nm:"authors"}},ps:[{$t:{tp:[{mt:"tp",pk:".",nm:"String"}],pk:".",nm:"Sequential"},pa:1,mt:"prm",an:{doc:["The authors, in Markdown syntax, of the annotated \nprogram element"]},seq:1,nm:"authors"}],nm:"AuthorsAnnotation"},printAll:{$t:{pk:".",nm:"Anything"},pa:1,mt:"m",an:{see:["process.write"],doc:["Print multiple values to the standard output of the virtual \nmachine process as a single line of text, separated by a\ngiven character sequence."],by:["Gavin"]},ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Anything"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"values"},{$t:{pk:".",nm:"String"},def:1,mt:"prm",an:{doc:["A character sequence to use to separate the values"]},nm:"separator"}]],nm:"printAll"},"$pkg-anns":{doc:["The root package of the Ceylon language module, functioning\nas the core of the [Ceylon platform][sdk], and covering the \nfollowing areas of functionality:\n\n- the foundational types [[Anything]], [[Object]], and \n  [[Null]], and a [[logical boolean|Boolean]] type,\n- abstractions of [[numeric|Numeric]] types, along with\n  basic types representing [[integral|Integer]] and \n  [[floating point|Float]] values,\n- [[characters|Character]] and [[character strings|String]],\n- [[unsigned bytes|Byte]],\n- support for functional programming with \n  [[streams|Iterable]],\n- abstract interfaces for unmodifiable [[lists|List]],\n  [[sets|Set]], and [[maps|Map]],\n- a low-level abstraction of native [[arrays|Array]],\n- immutable [[sequences|Sequential]], [[ranges|Range]], and\n  [[tuples|Tuple]], which provide the foundation for \n  representing [[function types|Callable]] and lists of\n  function arguments,\n- generic higher-order functions, including for function \n  [[composition|compose]] and [[partial application|curry]],\n- [[exceptions|Throwable]] and support for management of\n  heavyweight [[destroyable|Destroyable]] and \n  [[obtainable|Obtainable]] objects,\n- support for loading [[resources|Resource]] packaged with\n  a module,\n- access to information about the current \n  [[virtual machine|runtime]], [[system|system]],\n  [[process]], and [[operating system|system]], and\n- support for definition of [[annotations|Annotation]].\n\nFinally, this module defines the [[most useful and\ninteresting void function of all time ever|print]].\n\nDeclarations belonging to this package need not be \nexplicitly imported by other source files.\n\n[sdk]: https:\/\/modules.ceylon-lang.org\/categories\/SDK"],by:["Gavin King","Tom Bentley","Tako Schotanus","Stephane Epardaud","Enrique Zamudio"]},variable:{$t:{pk:".",nm:"VariableAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to mark a value as variable. A `variable` value \nmay be assigned multiple times."]},nm:"variable"},Correspondence:{pa:1,mt:"i",an:{see:["Map","List","Category"],doc:["Abstract supertype of objects which associate values with \nkeys.\n\n`Correspondence` does not satisfy [[Category]], since in \nsome cases&mdash;`List`, for example&mdash;it is convenient \nto consider the subtype a `Category` of its indexed items, \nand in other cases&mdash;`Map`, for example&mdash;it is \nconvenient to treat the subtype as a `Category` of its \n[[entries|Entry]].\n\nThe item corresponding to a given key may be obtained from \na `Correspondence` using the item operator:\n\n    value bg = settings[\"backgroundColor\"] else white;\n\nThe `get()` operation and item operator result in an\noptional type, to reflect the possibility that there may be\nno item for the given key."],by:["Gavin"]},tp:[{dv:"in",sts:[{pk:".",nm:"Object"}],nm:"Key"},{dv:"out",def:{pk:".",nm:"Anything"},nm:"Item"}],$m:{definesAny:{$t:{pk:".",nm:"Boolean"},pa:9,mt:"m",an:{see:["Correspondence.defines"],doc:["Determines if this `Correspondence` defines a value for\nany one of the given keys."]},ps:[[{$t:{tp:[{mt:"tp",nm:"Key"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"keys"}]],nm:"definesAny"},defines:{$t:{pk:".",nm:"Boolean"},pa:5,mt:"m",an:{see:["Correspondence.definesAny","Correspondence.definesEvery","Correspondence.keys"],doc:["Determines if there is a value defined for the given \nkey."]},ps:[[{$t:{nm:"Key"},mt:"prm",nm:"key"}]],nm:"defines"},get:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Item"}]},pa:5,mt:"m",an:{see:["Correspondence.getAll"],doc:["Returns the value defined for the given key, or `null` \nif there is no value defined for the given key."]},ps:[[{$t:{nm:"Key"},mt:"prm",nm:"key"}]],nm:"get"},getAll:{$t:{tp:[{comp:"u",mt:"tp",l:[{pk:".",nm:"Null"},{nm:"Item"}]},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},pa:9,mt:"m",an:{see:["Correspondence.get"],doc:["Returns the items defined for the given keys, in the \nsame order as the corresponding keys. For any key which \ndoes not have an item defined, the resulting stream \ncontains the value `null`."]},tp:[{sts:[{pk:".",nm:"Null"}],nm:"Absent"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},mt:"prm",nm:"keys"}]],nm:"getAll"},definesEvery:{$t:{pk:".",nm:"Boolean"},pa:9,mt:"m",an:{see:["Correspondence.defines"],doc:["Determines if this `Correspondence` defines a value for\nevery one of the given keys."]},ps:[[{$t:{tp:[{mt:"tp",nm:"Key"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"keys"}]],nm:"definesEvery"}},$c:{anon$0$89x05:{super:{pk:".",nm:"Basic"},$anon:1,mt:"c",sts:[{tp:[{mt:"tp",nm:"Key"}],pk:".",nm:"Category"}],nm:"anon$0$89x05"}},$at:{keys:{$t:{tp:[{mt:"tp",nm:"Key"}],pk:".",nm:"Category"},pa:9,mt:"g",an:{see:["Correspondence.defines"],doc:["The `Category` of all keys for which a value is defined\nby this `Correspondence`."]},nm:"keys"}},$o:{$m:{contains:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{nm:"Key"},mt:"prm",nm:"key"}]],nm:"contains"}}},nm:"Correspondence"},decreasing:{$t:{pk:".",nm:"Comparison"},pa:1,mt:"m",an:{see:["increasing","byDecreasing","Iterable.max","Iterable.sort"],doc:["A comparator function which orders elements in decreasing \n[[natural order|Comparable]].\n\n       \"Hello World!\".sort(decreasing)\n\nThis function is intended for use with [[Iterable.sort]]\nand [[Iterable.max]]."]},tp:[{sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Comparable"}],nm:"Element"}],ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],nm:"decreasing"},by:{$t:{pk:".",nm:"AuthorsAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to document the authors of an API."]},ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"String"}],pk:".",nm:"Sequential"},mt:"prm",an:{doc:["The authors, in Markdown syntax, of the annotated \nprogram element"]},seq:1,nm:"authors"}]],nm:"by"},Tuple:{super:{pk:".",nm:"Object"},pa:97,mt:"c",an:{doc:["A _tuple_ is a typed linked list. Each instance of \n`Tuple` represents the value and type of a single link.\nThe attributes `first` and `rest` allow us to retrieve a \nvalue from the list without losing its static type \ninformation.\n\n    value point = Tuple(0.0, Tuple(0.0, Tuple(\"origin\")));\n    Float x = point.first;\n    Float y = point.rest.first;\n    String label = point.rest.rest.first;\n\nUsually, we abbreviate code involving tuples.\n\n    [Float,Float,String] point = [0.0, 0.0, \"origin\"];\n    Float x = point[0];\n    Float y = point[1];\n    String label = point[2];\n\nA list of types enclosed in brackets is an abbreviated \ntuple type. An instance of `Tuple` may be constructed by \nsurrounding a value list in brackets:\n\n    [String,String] words = [\"hello\", \"world\"];\n\nThe index operator with a literal integer argument is a \nshortcut for a chain of evaluations of `rest` and \n`first`. For example, `point[1]` means `point.rest.first`.\n\nA _terminated_ tuple type is a tuple where the type of\nthe last link in the chain is `Empty`. An _unterminated_ \ntuple type is a tuple where the type of the last link\nin the chain is `Sequence` or `Sequential`. Thus, a \nterminated tuple type has a length that is known\nstatically. For an unterminated tuple type only a lower\nbound on its length is known statically.\n\nHere, `point` is an unterminated tuple:\n\n    String[] labels = ... ;\n    [Float,Float,String*] point = [0.0, 0.0, *labels];\n    Float x = point[0];\n    Float y = point[1];\n    String? firstLabel = point[2];\n    String[] allLabels = point[2...];"],by:["Gavin"],serializable:[]},sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"}],tp:[{dv:"out",nm:"Element"},{dv:"out",sts:[{nm:"Element"}],nm:"First"},{dv:"out",def:{pk:".",nm:"Empty"},sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"}],nm:"Rest"}],$m:{append:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"First"},{comp:"u",l:[{comp:"u",l:[{nm:"Element"},{nm:"Other"}]},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"First"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],pk:".",nm:"Sequential"}],pk:".",nm:"Tuple"},pa:67,mt:"m",an:{doc:["Return a tuple containing the elements of this \ntuple, followed by the given [[elements]]."]},tp:[{nm:"Other"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Sequential"},mt:"prm",an:{doc:["The list of elements to be appended."]},nm:"elements"}]],nm:"append"},clone:{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"First"},{mt:"tp",nm:"Rest"}],pk:".",nm:"Tuple"},pa:67,mt:"m",an:{doc:["This tuple."]},nm:"clone"},iterator:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"},pa:67,mt:"m",nm:"iterator"},withTrailing:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"First"},{comp:"u",l:[{comp:"u",l:[{nm:"Element"},{nm:"Other"}]},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"First"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],pk:".",nm:"Sequence"}],pk:".",nm:"Tuple"},pa:67,mt:"m",an:{doc:["Return a new tuple containing the elements of this \ntuple, followed by the given [[element]]."]},tp:[{nm:"Other"}],ps:[[{$t:{nm:"Other"},mt:"prm",an:{doc:["The last element of the resulting tuple."]},nm:"element"}]],nm:"withTrailing"},measure:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"measure"},spanTo:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"spanTo"},contains:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",an:{doc:["Determine if the given value is an element of this\ntuple."]},ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],nm:"contains"},withLeading:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]},{mt:"tp",nm:"Other"},{mt:"tp",tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"First"},{mt:"tp",nm:"Rest"}],pk:".",nm:"Tuple"}],pk:".",nm:"Tuple"},pa:67,mt:"m",an:{doc:["Return a new tuple that starts with the specified\n[[element]], followed by the elements of this tuple."]},tp:[{nm:"Other"}],ps:[[{$t:{nm:"Other"},mt:"prm",an:{doc:["The first element of the resulting tuple."]},nm:"element"}]],nm:"withLeading"},spanFrom:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],nm:"spanFrom"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromFirst"},span:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"end"}]],nm:"span"}},$at:{lastIndex:{$t:{pk:".",nm:"Integer"},pa:67,mt:"g",nm:"lastIndex"},last:{$t:{nm:"Element"},pa:67,mt:"g",an:{doc:["The last element of this tuple."]},nm:"last"},rest:{$t:{nm:"Rest"},pa:67,mt:"a",an:{doc:["A tuple with the elements of this tuple, except for the\nfirst element. (The tail of the linked list.)"]},nm:"rest"},first:{$t:{nm:"First"},pa:67,mt:"a",an:{doc:["The first element of this tuple. (The head of the \nlinked list.)"]},nm:"first"},size:{$t:{pk:".",nm:"Integer"},pa:67,mt:"g",nm:"size"}},ps:[{$t:{nm:"First"},pa:67,mt:"prm",an:{doc:["The first element of this tuple. (The head of the \nlinked list.)"]},$hdn:1,nm:"first"},{$t:{nm:"Rest"},pa:67,mt:"prm",an:{doc:["A tuple with the elements of this tuple, except for the\nfirst element. (The tail of the linked list.)"]},$hdn:1,nm:"rest"}],nm:"Tuple"},optional:{$t:{pk:".",nm:"OptionalImportAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to specify that a module can be executed even if \nthe annotated dependency is not available."]},nm:"optional"},any:{$t:{pk:".",nm:"Boolean"},pa:1,mt:"m",an:{see:["every","Iterable.any"],doc:["Determines if any one of the given boolean values \n(usually a comprehension) is `true`.\n\n    Boolean anyNegative = any { for (x in xs) x<0.0 };\n\nIf there are no boolean values, return `false`."]},ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Boolean"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"values"}]],nm:"any"},expand:{$t:{tp:[{mt:"tp",nm:"Element"},{comp:"u",mt:"tp",l:[{nm:"OuterAbsent"},{nm:"InnerAbsent"}]}],pk:".",nm:"Iterable"},pa:1,mt:"m",an:{see:["Iterable.flatMap","concatenate","Iterable.chain"],doc:["Given a [[stream|iterables]] whose elements are also \nstreams, return a new stream with all elements of every \nnested stream. If there are no nested streams, or if all of\nthe nested streams are empty, return an empty stream.\n\nFor example, the expression\n\n    expand { 1..3, {5}, \"hi\" }\n\nresults in the stream `{ 1, 2, 3, 5, 'h', 'i' }` which has\nthe type `{Integer|Character*}`."]},tp:[{nm:"Element"},{sts:[{pk:".",nm:"Null"}],nm:"OuterAbsent"},{sts:[{pk:".",nm:"Null"}],nm:"InnerAbsent"}],ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"InnerAbsent"}],pk:".",nm:"Iterable"},{mt:"tp",nm:"OuterAbsent"}],pk:".",nm:"Iterable"},mt:"prm",nm:"iterables"}]],nm:"expand"},Set:{pa:1,mt:"i",an:{doc:["A collection of unique elements.\n\nA `Set` is a [[Collection]] of its elements.\n\nSets may be the subject of the binary union, intersection, \nand complement operators `|`, `&`, and `~`.\n\n    value kids = girls|boys; \n\nElements are compared for equality using [[Object.equals]] \nor [[Comparable.compare]]. An element may occur at most \nonce in a set."]},sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Collection"}],tp:[{dv:"out",def:{pk:".",nm:"Object"},sts:[{pk:".",nm:"Object"}],nm:"Element"}],$m:{complement:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Set"},pa:5,mt:"m",an:{doc:["Returns a new `Set` containing all the elements in this \nset that are not contained in the given `Set`."]},tp:[{sts:[{pk:".",nm:"Object"}],nm:"Other"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Set"},mt:"prm",nm:"set"}]],nm:"complement"},subset:{$t:{pk:".",nm:"Boolean"},pa:9,mt:"m",an:{doc:["Determines if this set is a subset of the given `Set`, \nthat is, if the given set contains all of the elements \nin this set."]},ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Object"}],pk:".",nm:"Set"},mt:"prm",nm:"set"}]],nm:"subset"},intersection:{$t:{tp:[{comp:"i",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],pk:".",nm:"Set"},pa:5,mt:"m",an:{doc:["Returns a new `Set` containing only the elements that \nare present in both this set and the given `Set`."]},tp:[{sts:[{pk:".",nm:"Object"}],nm:"Other"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Set"},mt:"prm",nm:"set"}]],nm:"intersection"},clone:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Set"},pa:7,mt:"m",an:{doc:["A shallow copy of this set, that is, a set with the\nsame elements as this set, which do not change if the\nelements of this set change."]},nm:"clone"},exclusiveUnion:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],pk:".",nm:"Set"},pa:5,mt:"m",an:{doc:["Returns a new `Set` containing only the elements \ncontained in either this set or the given `Set`, but no \nelement contained in both sets."]},tp:[{sts:[{pk:".",nm:"Object"}],nm:"Other"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Set"},mt:"prm",nm:"set"}]],nm:"exclusiveUnion"},superset:{$t:{pk:".",nm:"Boolean"},pa:9,mt:"m",an:{doc:["Determines if this set is a superset of the given \n`Set`, that is, if this set contains all of the \nelements in the given set."]},ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Object"}],pk:".",nm:"Set"},mt:"prm",nm:"set"}]],nm:"superset"},equals:{$t:{pk:".",nm:"Boolean"},pa:11,mt:"m",an:{doc:["Two `Set`s are considered equal if they have the same \nsize and if every element of the first set is also an \nelement of the second set, as determined by \n[[contains]]. Equivalently, a set is equal to a second \nset if it is both a subset and a superset of the second\nset."]},ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],nm:"equals"},union:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],pk:".",nm:"Set"},pa:5,mt:"m",an:{doc:["Returns a new `Set` containing all the elements of this \nset and all the elements of the given `Set`."]},tp:[{sts:[{pk:".",nm:"Object"}],nm:"Other"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Set"},mt:"prm",nm:"set"}]],nm:"union"},contains:{$t:{pk:".",nm:"Boolean"},pa:11,mt:"m",an:{doc:["The fundamental operation for `Set`s. Determines if the\ngiven value belongs to this set."]},ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],nm:"contains"}},$at:{hash:{$t:{pk:".",nm:"Integer"},pa:11,mt:"g",nm:"hash"}},nm:"Set"},Scalable:{of:[{nm:"Value"}],pa:1,mt:"i",an:{doc:["Abstract supertype of types that support scaling by a \nnumeric factor. Examples of such types include vectors and \nmatrices. The _scale_ operator `**` accepts a scale factor\nas its first operand, and an instance of `Scalable` as its\nsecond operand.\n\n    Vector scaled = 2.0 ** Vector(x,y,z);\n\nConcrete classes which implement this interface should\nsatisfy:\n\n- `x == 1**x`\n- `a ** (b ** x) == a*b ** x`\n\nwhere `1` denotes the multiplicative identity of the \nnumeric scaling type.\n\nConcrete classes which implement this interface are\nencouraged to also satisfy [[Invertible]], in which case, \nthe following identity should be satisfied:\n\n- `-x == -1**x`\n\nConcrete classes which implement this interface and which\nalso satisfy [[Summable]] should satisfy:\n\n- `x+x == 2**x`\n- `a ** (x+y) == a**x + a**y`\n\nThe [[scaling type|Scale]] must be a [[numeric|Numeric]]\ntype, but is not required to be [[Number]], since a complex\nnumber scaling type should be allowed."],by:["Gavin"]},tp:[{dv:"in",sts:[{tp:[{mt:"tp",nm:"Scale"}],pk:".",nm:"Numeric"}],nm:"Scale"},{dv:"out",sts:[{tp:[{mt:"tp",nm:"Scale"},{mt:"tp",nm:"Value"}],pk:".",nm:"Scalable"}],nm:"Value"}],st:"Value",$m:{scale:{$t:{nm:"Value"},pa:5,mt:"m",an:{doc:["Scale this value by the given scale factor."]},ps:[[{$t:{nm:"Scale"},mt:"prm",nm:"scalar"}]],nm:"scale"}},nm:"Scalable"},Sequence:{pa:17,mt:"i",an:{see:["Empty","ArraySequence","Range","Tuple","Singleton"],doc:["A nonempty, immutable sequence of values. The type \n`Sequence<Element>` may be abbreviated `[Element+]`.\n\nGiven a possibly-empty sequence of type `[Element*]`, the \n`if (nonempty ...)` construct, or, alternatively, \n`assert (nonempty ...)`, may be used to narrow to a \nsequence type to a nonempty sequence type:\n\n    [Integer*] nums = ... ;\n    if (nonempty nums) {\n        Integer first = nums.first;\n        Integer max = max(nums);\n        [Integer+] squares = nums.collect((Integer i) => i**2));\n        [Integer+] sorted = nums.sort(byIncreasing((Integer i) => i));\n    }\n\nOperations like `first`, `max()`, `collect()`, and `sort()`, \nwhich polymorphically produce a nonempty or non-null output \nwhen given a nonempty input are called \n_emptiness-preserving_.\n\n`Sequence` has the following subtypes:\n\n- [[ArraySequence]], a sequence backed by an [[Array]],\n- [[Range]], an efficient representation of a sequence of \n  adjacent [[enumerable values|Enumerable]],\n- [[Tuple]], a typed linked list, and\n- [[Singleton]], a sequence of just one element."],by:["Gavin"]},sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Iterable"}],tp:[{dv:"out",def:{pk:".",nm:"Anything"},nm:"Element"}],$m:{clone:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"},pa:11,mt:"m",an:{doc:["This nonempty sequence."]},nm:"clone"},append:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],pk:".",nm:"Sequence"},pa:11,mt:"m",an:{doc:["Return a nonempty sequence containing the elements of \nthis sequence, followed by the given [[elements]]."]},tp:[{nm:"Other"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Sequential"},mt:"prm",nm:"elements"}]],nm:"append"},sort:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"},pa:11,mt:"m",an:{doc:["A nonempty sequence containing the elements of this\ncontainer, sorted according to a function imposing a \npartial order upon the elements."]},$m:{comparing$kwry1o:{$t:{pk:".",nm:"Comparison"},mt:"m",an:{doc:["The function comparing pairs of elements."]},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],nm:"comparing"}},ps:[[{$t:{pk:".",nm:"Comparison"},mt:"prm",an:{doc:["The function comparing pairs of elements."]},$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],nm:"comparing"}]],nm:"sort"},measure:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:11,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"measure"},prepend:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],pk:".",nm:"Sequence"},pa:11,mt:"m",an:{doc:["Return a nonempty sequence containing the given \n[[elements]], followed by the elements of this \nsequence."]},tp:[{nm:"Other"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Sequential"},mt:"prm",nm:"elements"}]],nm:"prepend"},longerThan:{$t:{pk:".",nm:"Boolean"},pa:11,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"longerThan"},contains:{$t:{pk:".",nm:"Boolean"},pa:11,mt:"m",ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],nm:"contains"},repeat:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:11,mt:"m",an:{doc:["Produced a sequence formed by repeating the elements of\nthis sequence the given [[number of times|times]], or\nthe [[empty sequence|empty]] if `times<=0`."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"times"}]],nm:"repeat"},withTrailing:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],pk:".",nm:"Sequence"},pa:11,mt:"m",an:{doc:["Return a nonempty sequence containing the elements of \nthis sequence, followed by the given [[element]]."]},tp:[{nm:"Other"}],ps:[[{$t:{nm:"Other"},mt:"prm",nm:"element"}]],nm:"withTrailing"},spanTo:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:11,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"spanTo"},shorterThan:{$t:{pk:".",nm:"Boolean"},pa:11,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"shorterThan"},sequence:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"},pa:11,mt:"m",an:{doc:["This nonempty sequence."]},nm:"sequence"},slice:{$t:{tp:[{comp:"u",mt:"tp",l:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},{comp:"u",l:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},{pk:".",nm:"Nothing"}]},{mt:"tp",tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}],pk:".",nm:"Tuple"},pa:11,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"slice"},getElement$kis5ex:{$t:{nm:"Element"},mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getElement"},findLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:11,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"elem"}]],nm:"selecting"}]],nm:"findLast"},spanFrom:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:11,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],nm:"spanFrom"},withLeading:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Other"},{comp:"u",l:[{nm:"Element"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"Other"},{mt:"tp",tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"}],pk:".",nm:"Tuple"},pa:11,mt:"m",an:{doc:["Return a nonempty sequence containing the given \n[[element]], followed by the elements of this \nsequence."]},tp:[{nm:"Other"}],ps:[[{$t:{nm:"Other"},mt:"prm",nm:"element"}]],nm:"withLeading"},find:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:11,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"elem"}]],nm:"selecting"}]],nm:"find"},span:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:11,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"span"},collect:{$t:{tp:[{mt:"tp",nm:"Result"}],pk:".",nm:"Sequence"},pa:11,mt:"m",an:{doc:["A nonempty sequence containing the results of applying \nthe given mapping to the elements of this sequence."]},tp:[{nm:"Result"}],$m:{collecting$hecv2q:{$t:{nm:"Result"},mt:"m",an:{doc:["The transformation applied to the elements."]},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"collecting"}},$o:{list$ap4q1c:{super:{pk:".",nm:"Object"},mt:"o",sts:[{tp:[{mt:"tp",nm:"Result"}],pk:".",nm:"List"}],$m:{getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Result"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromFirst"}},$at:{lastIndex:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:3,mt:"g",nm:"lastIndex"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"a",nm:"size"}},nm:"list"}},ps:[[{$t:{nm:"Result"},mt:"prm",an:{doc:["The transformation applied to the elements."]},$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"collecting"}]],nm:"collect"}},$c:{Repeat$op9ozo:{super:{pk:".",nm:"Object"},mt:"c",sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"}],$m:{iterator:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromFirst"}},$at:{last:{$t:{nm:"Element"},pa:3,mt:"g",nm:"last"},times$ryfnz9:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"times"},rest:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"g",nm:"rest"},first:{$t:{nm:"Element"},pa:3,mt:"g",nm:"first"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"}},ps:[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"times"}],nm:"Repeat$op9ozo"},Reverse$t1rj1v:{super:{pk:".",nm:"Object"},mt:"c",sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"}],$m:{iterator:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},measure:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"measure"},spanTo:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"spanTo"},spanFrom:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],nm:"spanFrom"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromFirst"},span:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"span"}},$at:{last:{$t:{nm:"Element"},pa:3,mt:"g",nm:"last"},reversed:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"},pa:3,mt:"g",nm:"reversed"},rest:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"g",nm:"rest"},first:{$t:{nm:"Element"},pa:3,mt:"g",nm:"first"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"}},nm:"Reverse$t1rj1v"}},$at:{lastIndex:{$t:{pk:".",nm:"Integer"},pa:11,mt:"g",an:{see:["size"],doc:["The index of the last element of the sequence."]},nm:"lastIndex"},last:{$t:{nm:"Element"},pa:7,mt:"a",an:{doc:["The last element of the sequence, that is, the element\nwith index `sequence.lastIndex`."]},nm:"last"},keys:{$t:{tp:[{mt:"tp",pk:".",nm:"Integer"}],pk:".",nm:"Sequence"},pa:11,mt:"g",an:{doc:["A nonempty sequence containing all indexes of this \nsequence, that is, every index in the range\n`0..sequence.lastIndex`."]},nm:"keys"},string:{$t:{pk:".",nm:"String"},pa:11,mt:"g",nm:"string"},empty:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"g",an:{doc:["Returns `false`, since every `Sequence` contains at\nleast one element."]},nm:"empty"},reversed:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"},pa:11,mt:"g",an:{doc:["A sequence containing the elements of this sequence in\nreverse order to the order in which they occur in this\nsequence."]},nm:"reversed"},rest:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:7,mt:"a",an:{doc:["The rest of the sequence, without the first element."]},nm:"rest"},first:{$t:{nm:"Element"},pa:7,mt:"a",an:{doc:["The first element of the sequence, that is, the element\nwith index `0`."]},nm:"first"},size:{$t:{pk:".",nm:"Integer"},pa:7,mt:"a",an:{doc:["The non-negative length of this sequence, that is, the\nnumber of elements in this sequence."]},nm:"size"}},nm:"Sequence"},Annotated:{pa:1,mt:"i",an:{see:["Annotation"],doc:["A program element that can\nbe annotated."]},$m:{annotated:{$t:{pk:".",nm:"Boolean"},pa:5,mt:"m",an:{doc:["true if this element has at least one annotation of the given annotation type."]},tp:[{sts:[{pk:".",nm:"Annotation"}],nm:"Annotation"}],nm:"annotated"}},nm:"Annotated"},emptyOrSingleton:{$t:{comp:"u",l:[{pk:".",nm:"Empty"},{tp:[{comp:"u",mt:"tp",l:[{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},{pk:".",nm:"Nothing"}]},{comp:"i",mt:"tp",l:[{nm:"Element"},{pk:".",nm:"Object"}]},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}]},pa:1,mt:"m",an:{see:["Tuple","Empty"],doc:["A singleton [[Tuple]] with the given [[element]] if the \ngiven element is non-null, or the [[empty sequence|Empty]] \notherwise. This operation transforms an optional type `T?`\nto a sequence type `[]|[T]` allowing optional values to be\nthe subject of operations defined for [[streams|Iterable]].\n\nFor example, [[flat mapping|Iterable.flatMap]] \n`emptyOrSingleton()` reproduces the behavior of \n[[Iterable.coalesced]]. The expression\n\n    { \"1.23\", \"foo\", \"5.67\", \"-1\", \"\" }\n            .map(parseFloat)\n            .flatMap(emptyOrSingleton<Float?>)\n\nproduces the stream:\n \n    { 1.23, 5.67, -1.0 }"]},tp:[{nm:"Element"}],ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"emptyOrSingleton"},shared:{$t:{pk:".",nm:"SharedAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to mark a declaration as shared. A `shared` \ndeclaration is visible outside the block of code in which \nit is declared."]},nm:"shared"},Binary:{of:[{nm:"Other"}],pa:1,mt:"i",an:{see:["Integer"],doc:["Abstraction of types that are conceptually a sequence of \nbits, and may be the subject of bitwise operations. A bit \nis a [[Boolean]] value. Bits are indexed from right to \nleft, where `0` is the index of the least significant bit."],by:["Stef"]},tp:[{sts:[{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Binary"}],nm:"Other"}],st:"Other",$m:{clear:{$t:{nm:"Other"},pa:9,mt:"m",an:{doc:["Returns an instance with the given bit set to 0 if \n`0 <= index < size`, otherwise returns a value with the \nsame bits as this value."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"clear"},xor:{$t:{nm:"Other"},pa:5,mt:"m",an:{doc:["Performs a logical exclusive OR operation."]},ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],nm:"xor"},get:{$t:{pk:".",nm:"Boolean"},pa:5,mt:"m",an:{doc:["Retrieves a given bit from this bit sequence if \n`0 <= index < size`, otherwise returns false."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"get"},leftLogicalShift:{$t:{nm:"Other"},pa:5,mt:"m",an:{doc:["Shift the sequence of bits to the left, by the \ngiven [[number of places|shift]], filling the least\nsignificant bits with zeroes."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"shift"}]],nm:"leftLogicalShift"},set:{$t:{nm:"Other"},pa:5,mt:"m",an:{doc:["Returns an instance with the given bit set to the given \nvalue if `0 <= index < size`, otherwise returns a value \nwith the same bits as this value."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"},{$t:{pk:".",nm:"Boolean"},def:1,mt:"prm",nm:"bit"}]],nm:"set"},or:{$t:{nm:"Other"},pa:5,mt:"m",an:{doc:["Performs a logical inclusive OR operation."]},ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],nm:"or"},rightArithmeticShift:{$t:{nm:"Other"},pa:5,mt:"m",an:{doc:["Shift the sequence of bits to the right, by the \ngiven [[number of places|shift]], preserving the values\nof the most significant bits.\n\nIf the sequence of bits represents a signed integer, \nthe sign is preserved."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"shift"}]],nm:"rightArithmeticShift"},rightLogicalShift:{$t:{nm:"Other"},pa:5,mt:"m",an:{doc:["Shift the sequence of bits to the right, by the \ngiven [[number of places|shift]], filling the most\nsignificant bits with zeroes.\n\nIf the sequence of bits represents a signed integer, \nthe sign is not preserved."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"shift"}]],nm:"rightLogicalShift"},flip:{$t:{nm:"Other"},pa:5,mt:"m",an:{doc:["Returns an instance with the given bit flipped to its \nopposite value if `0 <= index < size`, otherwise \nreturns a value with the same bits as this value."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"flip"},and:{$t:{nm:"Other"},pa:5,mt:"m",an:{doc:["Performs a logical AND operation."]},ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],nm:"and"}},$at:{not:{$t:{nm:"Other"},pa:5,mt:"a",an:{doc:["The binary complement of this sequence of bits."]},nm:"not"}},nm:"Binary"},and:{$t:{pk:".",nm:"Boolean"},pa:1,mt:"m",an:{doc:["Returns a function which is the logical conjunction of the \ngiven predicate functions."]},tp:[{dv:"in",nm:"Value"}],ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Boolean"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Value"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}],pk:".",nm:"Callable"},mt:"prm",an:{doc:["The first predicate function"]},nm:"p"},{$t:{tp:[{mt:"tp",pk:".",nm:"Boolean"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Value"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}],pk:".",nm:"Callable"},mt:"prm",an:{doc:["The second predicate function"]},nm:"q"}],[{$t:{nm:"Value"},mt:"prm",nm:"val"}]],nm:"and"},parseDigit:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},mt:"m",ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"digit"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"radix"}]],nm:"parseDigit"},unzipEntries:{$t:{tp:[{comp:"u",mt:"tp",l:[{tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},{comp:"u",l:[{tp:[{mt:"tp",nm:"Item"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{tp:[{mt:"tp",nm:"Item"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},{pk:".",nm:"Nothing"}]},{mt:"tp",tp:[{mt:"tp",nm:"Item"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}],pk:".",nm:"Tuple"},pa:1,mt:"m",an:{doc:["Given a stream of entries, return two streams. The\nfirst stream produces the keys of the given entries, \nand the second stream produces the items of the given \nentries.\n\nThus:\n\n    entries[i] == unzipEntries(entries)[0][i] \n               -> unzipEntries(entries)[1][i]"]},tp:[{sts:[{pk:".",nm:"Object"}],nm:"Key"},{nm:"Item"},{sts:[{pk:".",nm:"Null"}],nm:"Absent"}],ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"Item"}],pk:".",nm:"Entry"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},mt:"prm",nm:"entries"}]],nm:"unzipEntries"},minRadix:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"minRadix"},Obtainable:{pa:1,mt:"i",an:{see:["Destroyable"],doc:["Abstract supertype of resources which may be obtained at\nthe beginning of a `try` statement and then released when \nthe statement completes. Unlike a [[Destroyable]] resource, \na single instance of `Obtainable` may be reused between \nmultiple `try` statements or multiple executions of the \nsame `try` statement.\n\n    Lock lock = ... ;\n    try (lock) {\n        ...\n    }\n\n- [[obtain]] is called before the body of the `try` \n  statement is executed, and\n- [[release]] is called when execution of the body of the \n  `try` statement ends, even if an exception propagates out \n  of the body of the `try`.\n\nA class which satisfies `Obtainable` may impose constraints \non the ordering and nesting of invocations of `obtain()` \nand `release()`. For example, it may be not be possible to\nobtain a resource that has already been obtained. Those \nmethods should produce an [[AssertionError]] when any such \nconstraint is violated."]},sts:[{pk:".",nm:"Usable"}],$m:{obtain:{$t:{pk:".",nm:"Anything"},pa:5,mt:"m",an:{throws:["AssertionError","if an illegal state is detected"],doc:["Obtain this resource. Called before the body of a `try` \nstatement is executed.\n\nIf an exception is thrown by `obtain()`, then `release()` \nwill not be called."]},nm:"obtain"},release:{$t:{pk:".",nm:"Anything"},pa:5,mt:"m",an:{throws:["AssertionError","if an illegal state is detected"],doc:["Release this resource. Called when execution of the \nbody of a `try` statement ends, even if an exception \npropagates out of the body of the `try`."]},ps:[[{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Throwable"}]},mt:"prm",an:{doc:["The exception propagating out of the body of the \n`try` statement, or `null` if no exception was\npropagated."]},nm:"error"}]],nm:"release"}},nm:"Obtainable"},aIntLower:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"aIntLower"},String:{super:{pk:".",nm:"Object"},pa:97,mt:"c",an:{doc:["A string of characters. Each character in the string is a \n[[32-bit Unicode character|Character]]. The internal \nUTF-16 encoding is hidden from clients.\n\nLiteral strings may be written between double quotes:\n\n    \"hello world\"\n    \"\\r\\n\"\n    \"\\{#03C0} \\{#2248} 3.14159\"\n    \"\\{GREEK SMALL LETTER PI} \\{ALMOST EQUAL TO} 3.14159\"\n\nAlternatively, a _verbatim string_ may be written between\ntripled double quotes.\n\nThe _empty string_, `\"\"`, is a string with no characters.\n\nA string is a [[Category]] of its [[characters]], and of \nits substrings:\n\n    'w' in greeting \n    \"hello\" in greeting\n\nStrings are [[summable|Summable]]:\n\n    String greeting = \"hello\" + \" \" + \"world\";\n\nThey are efficiently [[iterable|Iterable]]:\n\n    for (char in \"hello world\") { ... }\n\nThey are [[lists|List]] of [[characters|Character]]:\n\n    value char = \"hello world\"[5];\n\nThey are [[ranged|Ranged]]:\n\n    String who = \"hello world\"[6...];\n\nNote that since `string[index]` evaluates to the optional \ntype `Character?`, it is often more convenient to write \n`string[index..index]`, which evaluates to a `String` \ncontaining a single character, or to the empty string \n`\"\"` if `index` refers to a position outside the string.\n\nIt is easy to use comprehensions to transform strings:\n\n    String { for (s in \"hello world\") if (s.letter) s.uppercased }\n\nSince a `String` has an underlying UTF-16 encoding, \ncertain operations are expensive, requiring iteration of \nthe characters of the string. In particular, [[size]]\nrequires iteration of the whole string, and `get()`,\n`span()`, and `measure()` require iteration from the \nbeginning of the string to the given index."],by:["Gavin"]},sts:[{tp:[{mt:"tp",pk:".",nm:"Character"}],pk:".",nm:"List"},{tp:[{mt:"tp",pk:".",nm:"String"}],pk:".",nm:"Comparable"},{tp:[{mt:"tp",pk:".",nm:"String"}],pk:".",nm:"Summable"},{tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",pk:".",nm:"Character"},{mt:"tp",pk:".",nm:"String"}],pk:".",nm:"Ranged"}],$m:{count:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"count"},locateLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",pk:".",nm:"Character"}],pk:".",nm:"Entry"}]},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"locateLast"},longerThan:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",an:{see:["size"],doc:["Determines if this string is longer than the given\n[[length]]. This is a more efficient operation than\n`string.size>length`."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"longerThan"},contains:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",an:{doc:["Determines if the given object is a `String` and, if \nso, if it occurs as a substring of this string, or if \nthe object is a `Character` that occurs in this string. \nThat is to say, a string is considered a [[Category]] \nof its substrings and of its characters."]},ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],nm:"contains"},every:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"every"},firstInclusion:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:67,mt:"m",ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"List"},mt:"prm",nm:"sublist"}]],nm:"firstInclusion"},compareIgnoringCase:{$t:{pk:".",nm:"Comparison"},pa:65,mt:"m",an:{see:["Character.lowercased","Character.uppercased"],doc:["Compare this string with the given string \nlexicographically, ignoring the case of the characters.\nThat is, by considering two characters `x` and `y` as\nequal if:\n\n- `x == y`,\n- `x.uppercased == y.uppercased`, or\n- `x.lowercased == y.lowercased`.\n\nThis defines a locale-independent collation that is\nincorrect in some locales."]},ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"other"}]],nm:"compareIgnoringCase"},getFromLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Character"}]},pa:67,mt:"m",an:{doc:["Get the character at the specified index, where the \nstring is indexed from the _end_ of the string, or \n`null` if the index falls outside the bounds of this \nstring."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromLast"},occurs:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",nm:"element"}]],nm:"occurs"},padTrailing:{$t:{pk:".",nm:"String"},pa:65,mt:"m",an:{doc:["Right pad this string with the given [[character]], \nproducing a string of the given minimum [[size]]."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"size"},{$t:{pk:".",nm:"Character"},def:1,mt:"prm",an:{doc:["The padding character"]},nm:"character"}]],nm:"padTrailing"},firstOccurrence:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",nm:"element"}]],nm:"firstOccurrence"},terminal:{$t:{pk:".",nm:"String"},pa:67,mt:"m",an:{doc:["Select the last characters of the string, returning a \nstring no longer than the given [[length]]. If this \nstring is shorter than the given length, return this \nstring. Otherwise, return a string of the given length."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"terminal"},initial:{$t:{pk:".",nm:"String"},pa:67,mt:"m",an:{doc:["Select the first characters of this string, returning a \nstring no longer than the given [[length]]. If this \nstring is shorter than the given length, return this \nstring. Otherwise, return a string of the given length."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"initial"},any:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"any"},inclusions:{$t:{tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:67,mt:"m",ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"List"},mt:"prm",nm:"sublist"}]],nm:"inclusions"},spanFrom:{$t:{pk:".",nm:"String"},pa:67,mt:"m",an:{doc:["A string containing the characters of this string from \nthe given [[start index|from]] inclusive to the end of \nthe string. If the start index is larger than the last \nindex of the string, return the empty string. If the\nstart index is negative, return this string."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],nm:"spanFrom"},plus:{$t:{pk:".",nm:"String"},pa:67,mt:"m",an:{doc:["Returns the concatenation of this string with the\ngiven string."]},ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"other"}]],nm:"plus"},clone:{$t:{pk:".",nm:"String"},pa:3,mt:"m",an:{doc:["This string."]},nm:"clone"},iterator:{$t:{tp:[{mt:"tp",pk:".",nm:"Character"}],pk:".",nm:"Iterator"},pa:67,mt:"m",an:{doc:["An iterator for the characters of the string."]},nm:"iterator"},equals:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",an:{doc:["Determines if the given object is a `String`, and if \nso, if this string has the same [[length|size]], and \nthe same [[characters]], in the same order, as the \ngiven [[string|that]]."]},ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],nm:"equals"},compare:{$t:{pk:".",nm:"Comparison"},pa:67,mt:"m",an:{doc:["Compare this string with the given string \nlexicographically, according to the Unicode code points\nof the characters.\n\nThis defines a locale-independent collation that is\nincorrect in some locales."]},ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"other"}]],nm:"compare"},reduce:{$t:{comp:"u",l:[{nm:"Result"},{pk:".",nm:"Character"},{pk:".",nm:"Null"}]},pa:67,mt:"m",tp:[{nm:"Result"}],ps:[[{$t:{nm:"Result"},mt:"prm",$pt:"f",ps:[[{$t:{comp:"u",l:[{nm:"Result"},{pk:".",nm:"Character"}]},mt:"prm",nm:"partial"},{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],nm:"accumulating"}]],nm:"reduce"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Character"}]},pa:67,mt:"m",an:{doc:["Returns the character at the given [[index]] in the \nstring, or `null` if the index is before the start of \nthe string or past the end of string. The first \ncharacter in the string occurs at index zero. The last \ncharacter in the string occurs at index \n`string.size-1`."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromFirst"},defines:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",an:{doc:["Determines if this string contains a character at the\ngiven [[index]], that is, if `0<=index<size`."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"defines"},lastOccurrence:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",nm:"element"}]],nm:"lastOccurrence"},split:{$t:{tp:[{mt:"tp",pk:".",nm:"String"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Iterable"},pa:65,mt:"m",an:{doc:["Split the string into tokens, using the given \n[[predicate function|splitting]] to determine which \ncharacters are separator characters.\n\n    value pathElements = path.split('\/'.equals);\n\nThe flags [[discardSeparators]] and [[groupSeparators]]\ndetermine how separator characters should occur in the\nresulting stream.\n\nNote that for the case of the empty string, `split()` \nalways produces a stream containing a single empty \ntoken. For example:\n\n    \"\".split('\/'.equals)\n\nevaluates to the nonempty stream `{ \"\" }`."]},ps:[[{$t:{pk:".",nm:"Boolean"},def:1,mt:"prm",an:{doc:["A predicate that determines if a character is a\nseparator characters at which to split. Default \nto split at any \n[[whitespace|Character.whitespace]] character."]},$pt:"f",ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"ch"}]],nm:"splitting"},{$t:{pk:".",nm:"Boolean"},def:1,mt:"prm",an:{doc:["Specifies that the separator characters\noccurring in the string should be discarded. If \n`false`, they will be included in the resulting \niterator."]},nm:"discardSeparators"},{$t:{pk:".",nm:"Boolean"},def:1,mt:"prm",an:{doc:["Specifies that the separator tokens should be \ngrouped eagerly and not be treated as \nsingle-character tokens. If `false` each \nseparator token will be of size `1`."]},nm:"groupSeparators"}]],nm:"split"},each:{$t:{pk:".",nm:"Anything"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],nm:"step"}]],nm:"each"},findLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Character"}]},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"findLast"},span:{$t:{pk:".",nm:"String"},pa:67,mt:"m",an:{doc:["A string containing the characters of this string \nbetween the given indexes. If the [[start index|from]] \nis the same as the [[end index|to]], return a string \nwith a single character. If the start index is larger \nthan the end index, return the characters in the \nreverse order from the order in which they appear in \nthis string. If both the start index and the end index \nare larger than the last index in the string, or if \nboth the start index and the end index are smaller than\nthe first index in the string, return the empty string. \nOtherwise, if the last index is larger than the last \nindex in the string, return all characters from the \nstart index to last character of the string."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"span"},measure:{$t:{pk:".",nm:"String"},pa:67,mt:"m",an:{doc:["A string containing the characters of this string \nbeginning at the given [[start index|from]], returning \na string no longer than the given [[length]]. If the \nportion of this string starting at the given index is \nshorter than the given length, return the portion of \nthis string from the given index until the end of this \nstring. Otherwise, return a string of the given length. \nIf the start index is larger than the last index of the \nstring, return the empty string."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"measure"},trimLeading:{$t:{pk:".",nm:"String"},pa:67,mt:"m",an:{doc:["A string containing the characters of this string, \nafter discarding the characters matching the given \n[[predicate function|trimming]] from the \nbeginning of the string.\n\nA character is removed from the string if it matches\nthe given predicate and every character occurring \nearlier in the string also matches the predicate."]},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The predicate function that determines whether\na character should be trimmed"]},$pt:"f",ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],nm:"trimming"}]],nm:"trimLeading"},repeat:{$t:{pk:".",nm:"String"},pa:67,mt:"m",an:{doc:["Returns a string formed by repeating this string the \ngiven number of [[times]], or the empty string if\n`times<=0`."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"times"}]],nm:"repeat"},includes:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"List"},mt:"prm",nm:"sublist"}]],nm:"includes"},copyTo:{$t:{pk:".",nm:"Anything"},pa:65,mt:"m",an:{doc:["Efficiently copy the characters in the segment\n`sourcePosition:length` of this string to the segment \n`destinationPosition:length` of the given \n[[character array|destination]]."]},ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Character"}],pk:".",nm:"Array"},mt:"prm",an:{doc:["The array into which to copy the elements."]},nm:"destination"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The index of the first element in this array to \ncopy."]},nm:"sourcePosition"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The index in the given array into which to copy the \nfirst element."]},nm:"destinationPosition"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The number of elements to copy."]},nm:"length"}]],nm:"copyTo"},spanTo:{$t:{pk:".",nm:"String"},pa:67,mt:"m",an:{doc:["A string containing the characters of this string from \nthe start of the string up to and including the given \n[[end index|to]]. If the end index is negative, return \nthe empty string. If the end index is larger than the\nlast index in this string, return this string."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"spanTo"},replaceFirst:{$t:{pk:".",nm:"String"},pa:65,mt:"m",an:{doc:["Returns a string formed by replacing the first \noccurrence in this string of the given [[substring]], \nif any, with the given [[replacement]] string."]},ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"substring"},{$t:{pk:".",nm:"String"},mt:"prm",nm:"replacement"}]],nm:"replaceFirst"},trim:{$t:{pk:".",nm:"String"},pa:67,mt:"m",an:{doc:["A string containing the characters of this string, \nafter discarding the characters matching the given \n[[predicate function|trimming]] from the beginning and \nend of the string.\n\n    value trimmed = name.trim('_'.equals);\n\nA character is removed from the string if it matches\nthe given predicate and if either:\n\n- every character occurring earlier in the string also \n  matches the predicate, or\n- every character occurring later in the string also\n  matches the predicate."]},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The predicate function that determines whether\na character should be trimmed"]},$pt:"f",ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],nm:"trimming"}]],nm:"trim"},locate:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",pk:".",nm:"Character"}],pk:".",nm:"Entry"}]},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"locate"},find:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Character"}]},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"find"},notLargerThan:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"other"}]],nm:"notLargerThan"},pad:{$t:{pk:".",nm:"String"},pa:65,mt:"m",an:{doc:["Pad this string with the given [[character]], producing \na string of the given minimum [[size]], centering the\nstring."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"size"},{$t:{pk:".",nm:"Character"},def:1,mt:"prm",an:{doc:["The padding character"]},nm:"character"}]],nm:"pad"},startsWith:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"List"},mt:"prm",nm:"substring"}]],nm:"startsWith"},largerThan:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"other"}]],nm:"largerThan"},padLeading:{$t:{pk:".",nm:"String"},pa:65,mt:"m",an:{doc:["Left pad this string with the given [[character]], \nproducing a string of the given minimum [[size]]."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"size"},{$t:{pk:".",nm:"Character"},def:1,mt:"prm",an:{doc:["The padding character"]},nm:"character"}]],nm:"padLeading"},equalsIgnoringCase:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"m",an:{see:["Character.lowercased","Character.uppercased"],doc:["Compare this string with the given string, ignoring the \ncase of the characters. That is, by considering two \ncharacters `x` and `y` as equal if:\n\n- `x == y`,\n- `x.uppercased == y.uppercased`, or\n- `x.lowercased == y.lowercased`."]},ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"that"}]],nm:"equalsIgnoringCase"},join:{$t:{pk:".",nm:"String"},pa:65,mt:"m",an:{doc:["Join the [[string representations|Object.string]] of \nthe given [[objects]], using this string as a separator."]},ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Object"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"objects"}]],nm:"join"},occursAt:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"},{$t:{pk:".",nm:"Anything"},mt:"prm",nm:"element"}]],nm:"occursAt"},smallerThan:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"other"}]],nm:"smallerThan"},replace:{$t:{pk:".",nm:"String"},pa:65,mt:"m",an:{doc:["Returns a string formed by replacing every occurrence \nin this string of the given [[substring]] with the \ngiven [[replacement]] string, working from the start of\nthis string to the end."]},ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"substring"},{$t:{pk:".",nm:"String"},mt:"prm",nm:"replacement"}]],nm:"replace"},notSmallerThan:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"other"}]],nm:"notSmallerThan"},replaceLast:{$t:{pk:".",nm:"String"},pa:65,mt:"m",an:{doc:["Returns a string formed by replacing the last \noccurrence in this string of the given [[substring]], \nif any, with the given [[replacement]] string."]},ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"substring"},{$t:{pk:".",nm:"String"},mt:"prm",nm:"replacement"}]],nm:"replaceLast"},shorterThan:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",an:{see:["size"],doc:["Determines if this string is shorter than the given\n[[length]]. This is a more efficient operation than\n`string.size>length`."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"shorterThan"},lastInclusion:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:67,mt:"m",ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"List"},mt:"prm",nm:"sublist"}]],nm:"lastInclusion"},trimTrailing:{$t:{pk:".",nm:"String"},pa:67,mt:"m",an:{doc:["A string containing the characters of this string, \nafter discarding the characters matching the given \n[[predicate function|trimming]] from the end of the \nstring.\n\nA character is removed from the string if it matches\nthe given predicate and every character occurring \nlater in the string also matches the predicate."]},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The predicate function that determines whether\na character should be trimmed"]},$pt:"f",ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"element"}]],nm:"trimming"}]],nm:"trimTrailing"},includesAt:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"},{$t:{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"List"},mt:"prm",nm:"sublist"}]],nm:"includesAt"},slice:{$t:{tp:[{comp:"u",mt:"tp",l:[{pk:".",nm:"String"},{comp:"u",l:[{pk:".",nm:"String"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",pk:".",nm:"String"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{pk:".",nm:"String"},{pk:".",nm:"Nothing"}]},{mt:"tp",pk:".",nm:"String"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}],pk:".",nm:"Tuple"},pa:67,mt:"m",an:{doc:["Return two strings, the first containing the characters\nthat occur before the given [[index]], the second with\nthe characters that occur after the given `index`. If \nthe given `index` is outside the range of indices of \nthis string, one of the returned strings will be empty."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"slice"},endsWith:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"List"},mt:"prm",nm:"substring"}]],nm:"endsWith"}},$at:{normalized:{$t:{pk:".",nm:"String"},pa:65,mt:"a",an:{doc:["A string containing the characters of this string after \ncollapsing strings of [[whitespace|Character.whitespace]] \ninto single space characters and discarding whitespace \nfrom the beginning and end of the string."]},nm:"normalized"},last:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Character"}]},pa:67,mt:"a",an:{doc:["The last character in the string."]},nm:"last"},hash:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"hash"},lowercased:{$t:{pk:".",nm:"String"},pa:65,mt:"a",an:{doc:["This string, with all characters in lowercase.\n\nConversion of uppercase characters to lowercase is\nperformed according to a locale-independent mapping\nthat produces incorrect results in certain locales\n(e.g. `tr-TR`).\n\nThe resulting string may not have the same number of\ncharacters as this string, since the uppercase \nrepresentation of certain characters comprises multiple\ncharacters, for example the lowercase representation of \n is two \ncharacters wide."]},nm:"lowercased"},keys:{$t:{tp:[{mt:"tp",pk:".",nm:"Integer"}],pk:".",nm:"Sequential"},pa:67,mt:"g",an:{doc:["A sequence containing all indexes of this string."]},nm:"keys"},linesWithBreaks:{$t:{tp:[{mt:"tp",pk:".",nm:"String"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:65,mt:"g",an:{see:["lines"],doc:["Split the string into lines of text with line breaks.\nEach line will be terminated by a line break sequence,\n`\\n` or `\\r\\n`."]},nm:"linesWithBreaks"},uppercased:{$t:{pk:".",nm:"String"},pa:65,mt:"a",an:{doc:["This string, with all characters in uppercase.\n\nConversion of lowercase characters to uppercase is\nperformed according to a locale-independent mapping\nthat produces incorrect results in certain locales\n(e.g. `tr-TR`).\n\nThe resulting string may not have the same number of\ncharacters as this string, since the uppercase \nrepresentation of certain characters comprises multiple\ncharacters, for example the uppercase representation of \n is SS."]},nm:"uppercased"},coalesced:{$t:{pk:".",nm:"String"},pa:3,mt:"g",an:{doc:["This string."]},nm:"coalesced"},characters$s4g2uj:{$t:{tp:[{mt:"tp",pk:".",nm:"Character"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"a",an:{doc:["The characters that form this string."]},nm:"characters"},size:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",an:{see:["longerThan","shorterThan"],doc:["The length of the string (the number of characters it \ncontains). In the case of the empty string, the string \nhas length zero. Note that this operation is \npotentially costly for long strings, since the\nunderlying representation of the characters uses a\nUTF-16 encoding. Use of [[longerThan]] or \n[[shorterThan]] is highly recommended."]},nm:"size"},lastIndex:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:3,mt:"g",an:{doc:["The index of the last character in the string, or \n`null` if the string has no characters. Note that this \noperation is potentially costly for long strings, since \nthe underlying representation of the characters uses a \nUTF-16 encoding. For any nonempty string:\n\n    string.lastIndex == string.size-1"]},nm:"lastIndex"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",an:{doc:["This string."]},nm:"string"},empty:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"a",an:{see:["size"],doc:["Determines if this string has no characters, that is, \nif it has zero [[size]]. This is a _much_ more \nefficient operation than `string.size==0`."]},nm:"empty"},lines:{$t:{tp:[{mt:"tp",pk:".",nm:"String"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:65,mt:"g",an:{see:["linesWithBreaks"],doc:["Split the string into lines of text, discarding line\nbreaks. Recognized line break sequences are `\\n` and \n`\\r\\n`."]},nm:"lines"},rest:{$t:{pk:".",nm:"String"},pa:67,mt:"a",an:{doc:["The rest of the string, without its first character."]},nm:"rest"},trimmed:{$t:{pk:".",nm:"String"},pa:65,mt:"g",an:{doc:["A string containing the characters of this string, \nafter discarding [[whitespace|Character.whitespace]] \nfrom the beginning and end of the string."]},nm:"trimmed"},reversed:{$t:{pk:".",nm:"String"},pa:67,mt:"a",an:{doc:["A string containing the characters of this string, with\nthe characters in reverse order."]},nm:"reversed"},first:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Character"}]},pa:67,mt:"a",an:{doc:["The first character in the string."]},nm:"first"}},ps:[{$t:{tp:[{mt:"tp",pk:".",nm:"Character"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",an:{doc:["The characters that form this string."]},$hdn:1,nm:"characters"}],nm:"String"},InitializationError:{super:{pk:".",nm:"AssertionError"},pa:1,mt:"c",an:{see:["late"],doc:["[[Assertion failure|AssertionError]] that occurs when a \nvalue reference could not be initialized, including when:\n\n- a toplevel value could not be initialized due to \n  recursive dependencies upon other toplevel values, \n- an uninitialized [[late]] value is evaluated, \n- an initialized `late` but non-`variable` value is\n  reassigned."]},$at:{description$lsghss:{$t:{pk:".",nm:"String"},mt:"a",nm:"description"}},ps:[{$t:{pk:".",nm:"String"},mt:"prm",nm:"description"}],nm:"InitializationError"},CycledIterator:{super:{pk:".",nm:"Basic"},mt:"c",sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"}],tp:[{nm:"Element"}],$m:{next:{$t:{comp:"u",l:[{nm:"Element"},{pk:".",nm:"Finished"}]},pa:3,mt:"m",nm:"next"}},$at:{iterable$oksliy:{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"a",nm:"iterable"},count$2etvtx:{$t:{pk:".",nm:"Integer"},pa:1024,mt:"a",nm:"count"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},iter$glpg04:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"},pa:1027,mt:"a",nm:"iter"},times$6c4zeu:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"times"}},ps:[{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"iterable"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"times"}],nm:"CycledIterator"},Anything:{of:[{pk:".",nm:"Object"},{pk:".",nm:"Null"}],pa:257,mt:"c",an:{doc:["The abstract supertype of all types. A value of type \n`Anything` may be a definite value of type [[Object]], or \nit may be the [[null]] value. A method declared `void` is \nconsidered to have the return type `Anything`.\n\nNote that the bottom type `Nothing`, representing the \nintersection of all types, is a subtype of all types."],by:["Gavin"]},nm:"Anything"},VariableAnnotation:{super:{pk:".",nm:"Basic"},pa:545,mt:"c",an:{doc:["The annotation class for the [[variable]] annotation."]},sts:[{tp:[{mt:"tp",pk:".",nm:"VariableAnnotation"},{mt:"tp",pk:"ceylon.language.meta.declaration",nm:"ValueDeclaration"},{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"OptionalAnnotation"}],nm:"VariableAnnotation"},parseFloat:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Float"}]},pa:1,mt:"m",an:{see:["parseInteger"],doc:["The [[Float]] value of the given \n[[string representation|string]] of a decimal floating \npoint number, or `null` if the string does not represent a \ndecimal floating point number.\n\nThe syntax accepted by this method is the same as the \nsyntax for a `Float` literal in the Ceylon language \nexcept that it may optionally begin with a sign \ncharacter (`+` or `-`) and may not contain grouping \nunderscore characters."]},ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"string"}]],nm:"parseFloat"},span:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Range"},pa:1,mt:"m",an:{doc:["Produces a [[Range]] of adjacent [[Enumerable]] values \ngenerated by two endpoints: [[first]] and [[last]]. The \nrange includes both endpoints, and all values falling \n_between_ the endpoints.\n\n- For a recursive enumerable type, a value falls between \n  the endpoints if its [[offset|Enumerable.offset]] from \n  `first` is less than the offset of `last` from `first`.\n- For a linear enumerable type, a value falls between the\n  endpoints if the \n  [[sign of its offset|Enumerable.offsetSign]] from `first` \n  is the same as the sign of the offset of `last` from \n  `first` and the sign of its offset from `last` is the \n  opposite of the sign of the offset of `last` from `first`.\n\nMore precisely, if `x`, `first`, and `last` are of \n`Enumerable` type `X`, then `x in first..last` if and \nonly if:\n\n- `X` is recursive and `x.offset(first)<last.offset(first)`,\n or\n- `X` is linear and \n `x.offsetSign(first)==last.offsetSign(first)` and\n `x.offsetSign(last)==-last.offsetSign(first)`.\n\nFor a linear enumerable type, a range is either \n[[increasing|Range.increasing]] or \n[[decreasing|Range.decreasing]]:\n\n- in an increasing range, a value occurs before its \n [[successor|Ordinal.successor]] and after its \n [[predecessor|Ordinal.predecessor]], but\n- in a decreasing range, a value occurs after its \n `successor` and before its `predecessor`.\n\nThe direction of the range depends upon the sign of the\noffset of `last` from `first`: \n\n- if `last.offsetSign(first)>=0` the range is increasing,\n  but\n- if `last.offsetSign(first)<0`, the range is decreasing.\n\nA range for a recursive enumerable type is always \nincreasing.\n\nThe _span operator_ `..` is an abbreviation for `span()`:\n\n    for (i in min..max) { ... }\n    if (char in 'A'..'Z') { ... }\n\nThe span operator accepts the first and last values of \nthe range. It may produce an increasing range:\n\n    0..5    \/\/ [0, 1, 2, 3, 4, 5]\n    0..0    \/\/ [0]\n\nOr it may produce a decreasing range:\n\n    5..0    \/\/ [5, 4, 3, 2, 1, 0]\n    0..-5   \/\/ [0, -1, -2, -3, -4, -5]"]},tp:[{sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Enumerable"}],nm:"Element"}],ps:[[{$t:{nm:"Element"},mt:"prm",nm:"first"},{$t:{nm:"Element"},mt:"prm",nm:"last"}]],nm:"span"},Exception:{super:{pk:".",nm:"Throwable"},pa:65,mt:"c",an:{doc:["The supertype of all unexpected transient failures. An\n`Exception` is usually unrecoverable from the point of view \nof the immediate caller of an operation.\n\nFor example, code that interacts with a relational database \nisn't typically written to recover from transaction \nrollback or loss of network connectivity. However, these \nconditions aren't completely unrecoverable from the point \nof view of the program's generic exception handling \ninfrastructure. Therefore, they are best treated as \n`Exception`s.\n\nA subclass of `Exception` represents a more specific kind \nof problem, and may define additional attributes which \npropagate information about problems of that kind."],by:["Gavin","Tom"]},$at:{description$etadt1:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"String"}]},mt:"a",an:{doc:["A description of the problem."]},nm:"description"},cause$tn7i4g:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Throwable"}]},mt:"a",an:{doc:["The underlying cause of this exception."]},nm:"cause"}},ps:[{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"String"}]},def:1,mt:"prm",an:{doc:["A description of the problem."]},$hdn:1,nm:"description"},{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Throwable"}]},def:1,mt:"prm",an:{doc:["The underlying cause of this exception."]},$hdn:1,nm:"cause"}],nm:"Exception"},foldPairs:{$t:{nm:"Result"},pa:1,mt:"m",an:{doc:["Given two streams, return the result of applying the given \n[[accumulating function|accumulating]] to each pair of \nelements of the given streams in turn. If one of the \nstreams is longer than the other, simply ignore additional \nelements of the longer stream with no pair in the other \nstream.\n\nFor any given streams `xs` and `ys`, initial value `z`, and\ncombining function `f`, `foldPairs()` may be defined in \nterms of [[Iterable.fold]], [[zipPairs]], and [[unflatten]]:\n\n    foldPairs(z, f, xs, ys) == zipPairs(xs, ys).fold(z)(unflatten(f))"]},tp:[{nm:"Result"},{nm:"First"},{nm:"Second"}],$m:{accumulating$wxcgon:{$t:{nm:"Result"},mt:"m",an:{doc:["The accumulating function to apply to each pair of \nelements."]},ps:[[{$t:{nm:"Result"},mt:"prm",nm:"partial"},{$t:{nm:"First"},mt:"prm",nm:"first"},{$t:{nm:"Second"},mt:"prm",nm:"second"}]],nm:"accumulating"}},ps:[[{$t:{nm:"Result"},mt:"prm",nm:"initial"},{$t:{nm:"Result"},mt:"prm",an:{doc:["The accumulating function to apply to each pair of \nelements."]},$pt:"f",ps:[[{$t:{nm:"Result"},mt:"prm",nm:"partial"},{$t:{nm:"First"},mt:"prm",nm:"first"},{$t:{nm:"Second"},mt:"prm",nm:"second"}]],nm:"accumulating"},{$t:{tp:[{mt:"tp",nm:"First"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"firstIterable"},{$t:{tp:[{mt:"tp",nm:"Second"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"secondIterable"}]],nm:"foldPairs"},findPair:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{tp:[{comp:"u",mt:"tp",l:[{nm:"First"},{comp:"u",l:[{nm:"Second"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"First"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"Second"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Second"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}],pk:".",nm:"Tuple"}]},pa:1,mt:"m",an:{doc:["Given two streams, return the first pair of elements in the \ngiven streams that satisfies the given binary [[predicate\nfunction|selecting]], or null if no pair of elements \nsatisfies the predicate. If one of the streams is longer \nthan the other, simply ignore additional elements of the \nlonger stream with no pair in the other stream.\n\nFor any given streams `xs` and `ys`, and predicate function \n`p`, `findPair()` may be defined in terms of \n[[Iterable.find]], [[zipPairs]], and [[unflatten]]:\n\n    findPair(p, xs, ys) == zipPairs(xs, ys).find(unflatten(p))"]},tp:[{nm:"First"},{nm:"Second"}],$m:{selecting$g8bdrb:{$t:{pk:".",nm:"Boolean"},mt:"m",an:{doc:["The binary predicate function to apply to each pair of \nelements."]},ps:[[{$t:{nm:"First"},mt:"prm",nm:"first"},{$t:{nm:"Second"},mt:"prm",nm:"second"}]],nm:"selecting"}},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The binary predicate function to apply to each pair of \nelements."]},$pt:"f",ps:[[{$t:{nm:"First"},mt:"prm",nm:"first"},{$t:{nm:"Second"},mt:"prm",nm:"second"}]],nm:"selecting"},{$t:{tp:[{mt:"tp",nm:"First"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"firstIterable"},{$t:{tp:[{mt:"tp",nm:"Second"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"secondIterable"}]],nm:"findPair"},measure:{$t:{comp:"u",l:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Range"},{pk:".",nm:"Empty"}]},pa:1,mt:"m",an:{doc:["Produces a [[Range]] of adjacent [[Enumerable]] values \ngenerated by a [[first]] element, and a strictly positive \n[[size]], or returns the [[empty sequence|empty]] if \n`size <= 0`. The range includes all values whose offset \nfrom `first` is non-negative and less than the `size`.\n\nMore precisely, if `x` and `first` are of `Enumerable` \ntype `X`, and `size` is an integer, then `x in first:size` \nif and only if `0 <= x.offset(first) < size`.\n\nThe _measure operator_ `:` is an abbreviation for\n`measure()`:\n\n    for (i in start:size) { ... }\n    for (char in '0':10) { ... }\n\nThe measure operator accepts the first index and size of \nthe range:\n\n    0:5     \/\/ [0, 1, 2, 3, 4]\n\nIf the size is nonpositive, the range is empty:\n\n    0:0     \/\/ []\n    5:0     \/\/ []\n    0:-5    \/\/ []"]},tp:[{sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Enumerable"}],nm:"Element"}],ps:[[{$t:{nm:"Element"},mt:"prm",nm:"first"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"size"}]],nm:"measure"},parseInteger:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:1,mt:"m",an:{see:["formatInteger","parseFloat"],throws:["AssertionError","if [[radix]] is not between [[minRadix]] and \n[[maxRadix]]"],doc:["The [[Integer]] value of the given \n[[string representation|string]] of an integer value in the \nbase given by [[radix]], or `null` if the string does not \nrepresent an integer in that base, or if the mathematical \ninteger it represents is too large in magnitude to be \nrepresented by an instance of the class `Integer`.\n\nThe syntax accepted by this function is the same as the \nsyntax for an `Integer` literal in the Ceylon language \nexcept that it may optionally begin with a sign character \n(`+` or `-`) and may not contain grouping underscore \ncharacters.\n\nThe given `radix` specifies the base of the string \nrepresentation. The list of available digits starts from \n`0` to `9`, followed by `a` to `z`. When parsing in a \nspecific base, the first `radix` digits from the available \ndigits list is used. This function is not case sensitive; \n`a` and `A` both correspond to the digit `a` whose decimal \nvalue is `10`."]},ps:[[{$t:{pk:".",nm:"String"},mt:"prm",an:{doc:["The string representation to parse."]},nm:"string"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The base, between [[minRadix]] and [[maxRadix]] \ninclusive."]},nm:"radix"}]],nm:"parseInteger"},sum:{$t:{nm:"Value"},pa:1,mt:"m",an:{see:["product"],doc:["Given a nonempty stream of [[Summable]] values, return the \nsum of the values."]},tp:[{sts:[{tp:[{mt:"tp",nm:"Value"}],pk:".",nm:"Summable"}],nm:"Value"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Value"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Iterable"},mt:"prm",nm:"values"}]],nm:"sum"},infinity:{$t:{pk:".",nm:"Float"},pa:1,mt:"a",an:{doc:["An instance of [[Float]] representing positive infinity, \n, the result of dividing a positive number by zero. \nNegative infinity, -, the result of dividing a\nnegative number by zero, is the additive inverse `-infinity`.\n\nNote that any floating-point computation that results in a\npositive value too large to be represented as a `Float` is \n\"rounded up\" to `infinity`. Likewise, any floating-point \ncomputation that yields a negative value whose magnitude is\ntoo large to be represented as a `Float` is \"rounded down\" \nto `-infinity`."]},nm:"infinity"},DefaultAnnotation:{super:{pk:".",nm:"Basic"},pa:545,mt:"c",an:{doc:["The annotation class for the [[default]] annotation."]},sts:[{tp:[{mt:"tp",pk:".",nm:"DefaultAnnotation"},{comp:"u",mt:"tp",l:[{pk:"ceylon.language.meta.declaration",nm:"FunctionOrValueDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ClassOrInterfaceDeclaration"}]},{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"OptionalAnnotation"}],nm:"DefaultAnnotation"},Iterable:{pa:1,mt:"i",an:{see:["Collection"],doc:["Abstract supertype of [[categories|Category]] whose\nelements may be iterated. Iterable categories are often\ncalled _streams_. A stream need not be finite, but its\nelements must be countable. That is, for any given\nelement of the stream, every iterator of the stream must\neventually return the element, even if the iterator\nitself is not exhaustible.\n\nA stream may have null elements. That is, an iterator for\nthe stream may produce the value [[null]] one or more\ntimes. For every non-null `element` of a given stream\n`it`, the expression `element in it` must evaluate to\n`true`. Thus, a stream is a category of its non-null\nelements.\n\nA given stream might not have a well-defined order, and\nso the order in which elements are produced by the\nstream's iterator may not be _stable_. That is, the order\nmay be different for two different iterators of the\nstream. However, a stream has a well-defined set of\nelements, and any two iterators for an immutable finite\nstream should eventually return the same elements.\nFurthermore, any two iterators for an immutable finite\nstream should eventually return exactly the same number\nof elements, which must be the [[size]] of the stream.\n\nA given stream may not be _finite_, in which case an\niterator for the stream is never exhaustible, and certain\noperations of this interface either never terminate or\nresult in an [[AssertionError]]. It may not, in general,\nbe possible to even determine if an `Iterable` is finite.\n\nThe type `Iterable<Element,Null>`, usually abbreviated\n`{Element*}`, represents a possibly-empty iterable\ncontainer. The type `Iterable<Element,Nothing>`, usually\nabbreviated `{Element+}`, represents a nonempty iterable\ncontainer.\n\nA value list in braces produces a new instance of \n`Iterable`:\n\n    {String+} words = { \"hello\", \"world\" };\n\nAn instance of `Iterable` may be iterated using a `for`\nloop:\n\n    for (c in \"hello world\") { ... }\n\nComprehensions provide a convenient syntax for \ntransforming streams:\n\n    {Integer+} lengths = { for (w in words) w.size };\n\n`Iterable` and its subtypes define various operations\nthat return other iterable objects. Such operations come \nin two flavors:\n\n- _Lazy_ operations return a *view* of the receiving\n  iterable object. If the underlying iterable object is\n  mutable, then changes to the underlying object will be \n  reflected in the resulting view. Lazy operations are \n  usually efficient, avoiding memory allocation or\n  iteration of the receiving iterable object.\n- _Eager_ operations return an immutable object. If the\n  receiving iterable object is mutable, changes to this\n  object will not be reflected in the resulting immutable\n  object. Eager operations are often expensive, involving\n  memory allocation and iteration of the receiving \n  iterable object.\n\nLazy operations are generally preferred, because they can \nbe efficiently chained. For example:\n\n    string.filter((c) => c.letter||c.digit)\n          .map(Character.uppercased)\n\nis much less expensive than:\n\n    string.select((c) => c.letter||c.digit)\n          .collect(Character.uppercased)\n\nFurthermore, it is always easy to produce a new \nimmutable iterable object given the view produced by a\nlazy operation. For example:\n\n    [ *string.filter((c) => c.letter||c.digit)\n             .map(Character.uppercased) ]\n\nHowever, there are certain scenarios where an eager \noperation is more useful, more convenient, or no more \nexpensive than a lazy operation, including:\n\n- sorting operations, for example [[sort]], which are \n  eager by nature,\n- operations which result in a subset or subrange of the \n  receiving stream, where structural sharing would or\n  could result in unnecessary memory retention.\n\nCertain operations come in both lazy and eager flavors,\nfor example:\n\n- [[map]] vs [[collect]],\n- [[filter]] vs [[select]],\n- [[List.sublist]] vs [[List.measure]].\n\nLazy operations normally return an instance of `Iterable`, \nor even a [[List]], [[Map]], or [[Set]]. Eager operations \nusually return a [[sequence|Sequential]]. The method\n[[sequence]] materializes the current elements of a\nstream into a sequence.\n\nUnlike [[Collection]], `Iterable` does not define or \nrequire any form of [[value equality|Object.equals]], and \nsome streams do not support value equality. Therefore, \nthe use of the `==` operator to compare generic iterables \nis extremely fragile and strongly discouraged."],by:["Gavin"]},sts:[{tp:[{mt:"tp",pk:".",nm:"Object"}],pk:".",nm:"Category"}],tp:[{dv:"out",def:{pk:".",nm:"Anything"},nm:"Element"},{dv:"out",def:{pk:".",nm:"Null"},sts:[{pk:".",nm:"Null"}],nm:"Absent"}],$m:{flatMap:{$t:{tp:[{mt:"tp",nm:"Result"},{comp:"u",mt:"tp",l:[{nm:"Absent"},{nm:"OtherAbsent"}]}],pk:".",nm:"Iterable"},pa:9,mt:"m",an:{see:["expand"],doc:["Given a [[mapping function|collecting]] that accepts an \n[[Element]] and returns a stream of [[Result]]s, \nproduces a new stream containing all elements of every \n`Result` stream that results from applying the function \nto the elements of this stream.\n\nFor example, the expression\n\n    { \"Hello\", \"World\" }.flatMap(String.lowercased)\n\nresults in this stream:\n\n    { 'h', 'e', 'l', 'l', 'o', 'w', 'o', 'r,' 'l', 'd' }\n\nThe expression\n    \n    { \"hello\"->\"hola\", \"world\"->\"mundo\" }\n            .flatMap(Entry<String,String>.pair)\n\nproduces this stream:\n\n    { \"hello\", \"hola\", \"world\", \"mundo\" }"]},tp:[{nm:"Result"},{sts:[{pk:".",nm:"Null"}],nm:"OtherAbsent"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Result"},{mt:"tp",nm:"OtherAbsent"}],pk:".",nm:"Iterable"},mt:"prm",an:{doc:["The mapping function to apply to the elements \nof this stream, that produces a new stream of \n[[Result]]s."]},$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"collecting"}]],nm:"flatMap"},sort:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:9,mt:"m",an:{see:["increasing","decreasing","byIncreasing","byDecreasing"],doc:["Produce a new [[sequence|Sequential]] containing the \nelements of this stream, sorted according to the given \n[[comparator function|comparing]] imposing a partial \norder upon the elements of the stream.\n\nFor convenience, the functions [[byIncreasing]] and \n[[byDecreasing]] produce suitable comparator functions.\n\nFor example, this expression\n\n    \"Hello World!\".sort(byIncreasing(Character.lowercased))\n\nevaluates to the sequence \n`[ , !, d, e, H, l, l, l, o, o, r, W].`\n\nThis operation is eager by nature.\n\nNote that the toplevel function [[ceylon.language::sort]] \nmay be used to sort a stream of [[Comparable]] values \naccording to the natural order of its elements."]},$m:{comparing$6qhk6z:{$t:{pk:".",nm:"Comparison"},mt:"m",an:{doc:["The function comparing pairs of elements."]},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],nm:"comparing"}},ps:[[{$t:{pk:".",nm:"Comparison"},mt:"prm",an:{doc:["The function comparing pairs of elements."]},$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],nm:"comparing"}]],nm:"sort"},count:{$t:{pk:".",nm:"Integer"},pa:9,mt:"m",an:{doc:["Produces the number of elements in this stream that \nsatisfy the [[given predicate function|selecting]].\nFor an infinite stream, this method never terminates."]},$m:{selecting$wa5l0i:{$t:{pk:".",nm:"Boolean"},mt:"m",an:{doc:["The predicate satisfied by the elements to be \ncounted."]},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"selecting"}},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The predicate satisfied by the elements to be \ncounted."]},$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"count"},skipWhile:{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:9,mt:"m",an:{see:["skip","takeWhile"],doc:["Produces a stream containing the elements of this \nstream, after skipping the leading elements until the \ngiven [[predicate function|skipping]] returns `false`."]},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The function that returns `false` when the \nresulting stream should stop skipping\nelements from the stream."]},$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"skipping"}]],nm:"skipWhile"},locateLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",nm:"Element"}],pk:".",nm:"Entry"}]},pa:9,mt:"m",an:{doc:["The last element of this stream which satisfies the \n[[given predicate function|selecting]], if any, \ntogether with its position in the stream, or `null` \nif there is no such element. For an infinite stream, \nthis method might not terminate.\n\nFor example, the expression\n\n    (-10..10).locateLast(3.divides)\n\nevaluates to `19->9`."]},$m:{selecting$u7lwbh:{$t:{pk:".",nm:"Boolean"},mt:"m",an:{doc:["The predicate the element must satisfy."]},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"}},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The predicate the element must satisfy."]},$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"locateLast"},longerThan:{$t:{pk:".",nm:"Boolean"},pa:9,mt:"m",an:{see:["size"],doc:["Determines if this stream has more elements than the \ngiven [[length]]. This is an efficient operation for\nstreams with many elements."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"longerThan"},by:{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},pa:9,mt:"m",an:{throws:["AssertionError","if the given step size is nonpositive, \ni.e. `step<1`"],doc:["Produces a stream containing every [[step]]th element \nof this stream. If the step size is `1`, the resulting\nstream contains the same elements as this stream.\n\nFor example, the expression\n\n    (0..10).by(3)\n\nresults in the stream `{ 0, 3, 6, 9 }`.\n\nThe step size must be greater than zero."]},$c:{anon$15$yx2e77:{super:{pk:".",nm:"Basic"},$anon:1,mt:"c",sts:[{tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"}],nm:"anon$15$yx2e77"}},$o:{$m:{iterator:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"},pa:3,mt:"m",nm:"iterator"}},$at:{string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"}}},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"step"}]],nm:"by"},contains:{$t:{pk:".",nm:"Boolean"},pa:11,mt:"m",an:{doc:["Returns `true` if the iterator for this stream produces\nthe given element, or `false` otherwise. In the case of \nan infinite stream, this operation might never terminate;\nfurthermore, this default implementation iterates all\nthe elements until found (or not), which might be very\nexpensive."]},ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],nm:"contains"},repeat:{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:9,mt:"m",an:{see:["cycled"],doc:["Produces a stream formed by repeating the elements of \nthis stream the given [[number of times|times]], or an \nempty stream if `times<=0`.\n\nFor example, the expression\n\n    { 1, 2 }.repeat(3)\n\nevaluates to the stream `{ 1, 2, 1, 2, 1, 2 }`."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"times"}]],nm:"repeat"},skip:{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:9,mt:"m",an:{see:["List.sublistFrom","skipWhile","take"],doc:["Produces a stream containing the elements of this \nstream, after skipping the first [[skipping]] elements\nproduced by its iterator.\n\nIf this stream does not contain more elements than the \nspecified number of elements to skip, the resulting \nstream has no elements. If the specified number of \nelements to skip is zero or fewer, the resulting stream \ncontains the same elements as this stream."]},$c:{anon$7$v2s8e6:{super:{pk:".",nm:"Basic"},$anon:1,mt:"c",sts:[{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"}],nm:"anon$7$v2s8e6"}},$o:{$m:{iterator:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"},pa:3,mt:"m",nm:"iterator"}},$at:{string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"}}},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"skipping"}]],nm:"skip"},every:{$t:{pk:".",nm:"Boolean"},pa:9,mt:"m",an:{see:["any"],doc:["Determines if all elements of this stream satisfy the \ngiven [[predicate function|selecting]]. If the stream\nis empty, return `true`. For an infinite stream, this \noperation might not terminate."]},$m:{selecting$uznjta:{$t:{pk:".",nm:"Boolean"},mt:"m",an:{doc:["The predicate that all elements must satisfy."]},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"selecting"}},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The predicate that all elements must satisfy."]},$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"every"},partition:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},pa:9,mt:"m",an:{throws:["AssertionError","if `length<=0`"],doc:["Produces a stream of sequences of the given [[length]],\ncontaining elements of this stream. Each sequence in \nthe stream contains the next [[length]] elements of \nthis sequence that have not yet been assigned to a \nprevious sequence, in the same order that they occur\nin this stream. The very last sequence in the stream\nmay be shorter than the given `length`.\n\nFor example, the expression\n\n    \"hello\".partition(2)\n\nresults in the stream `{ ['h','e'], ['l','l'], ['o'] }.`\n\nFor any `stream` and for any strictly positive integer \n[[length]]:\n\n    expand { stream.partition(length) } == stream"]},$c:{anon$21$79rb1r:{super:{pk:".",nm:"Basic"},$anon:1,mt:"c",sts:[{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"}],nm:"anon$21$79rb1r"}},$o:{$m:{iterator:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"}],pk:".",nm:"Iterator"},pa:3,mt:"m",nm:"iterator"}},$at:{empty:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"g",nm:"empty"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"}}},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"partition"},takeWhile:{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:9,mt:"m",an:{see:["take","skipWhile"],doc:["Produces a stream containing the leading elements of \nthis stream until the given [[predicate function|taking]]\nreturns `false`."]},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The function that returns `false` when the \nresulting stream should stop taking elements\nfrom this stream."]},$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"taking"}]],nm:"takeWhile"},any:{$t:{pk:".",nm:"Boolean"},pa:9,mt:"m",an:{see:["every"],doc:["Determines if there is at least one element of this \nstream that satisfies the given [[predicate \nfunction|selecting]]. If the stream is empty, returns \n`false`. For an infinite stream, this operation might \nnot terminate."]},$m:{selecting$2wzmxl:{$t:{pk:".",nm:"Boolean"},mt:"m",an:{doc:["The predicate that at least one element must \nsatisfy."]},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"selecting"}},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The predicate that at least one element must \nsatisfy."]},$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"any"},map:{$t:{tp:[{mt:"tp",nm:"Result"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},pa:9,mt:"m",an:{see:["collect"],doc:["Produces a stream containing the results of applying \nthe given [[mapping|collecting]] to the elements of \nthis stream.\n\nFor any empty stream, `map()` returns an empty stream:\n\n    {}.map(f) == {}\n\nFor any nonempty stream `it`, and mapping function `f`,\nthe result of `map()` may be obtained according to this\nrecursive definition:\n\n    it.map(f).first == f(it.first)\n    it.map(f).rest == it.rest.map(f)\n\nAlternatively, and in practice, `map()` may be defined \nby this comprehension:\n\n    it.map(f) == { for (e in it) f(e) }\n\nFor example, the expression\n\n    (0..4).map(10.power)\n\nresults in the stream `{ 1, 10, 100, 1000, 10000 }`."]},tp:[{nm:"Result"}],ps:[[{$t:{nm:"Result"},mt:"prm",an:{doc:["The mapping to apply to the elements."]},$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"collecting"}]],nm:"map"},locate:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",nm:"Element"}],pk:".",nm:"Entry"}]},pa:9,mt:"m",an:{doc:["The first element of this stream which satisfies the \n[[given predicate function|selecting]], if any, \ntogether with its position in the stream, or `null` \nif there is no such element. For an infinite stream, \nthis method might not terminate.\n\nFor example, the expression\n\n    (-10..10).locate(Integer.positive)\n\nevaluates to `11->1`."]},$m:{selecting$xxnpkt:{$t:{pk:".",nm:"Boolean"},mt:"m",an:{doc:["The predicate the element must satisfy."]},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"}},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The predicate the element must satisfy."]},$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"locate"},find:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:9,mt:"m",an:{doc:["The first element of this stream which satisfies the \n[[given predicate function|selecting]], if any, or \n`null` if there is no such element. For an infinite \nstream, this method might not terminate.\n\nFor example, the expression\n\n    (-10..10).find(Integer.positive)\n\nevaluates to `1`."]},$m:{selecting$7invh8:{$t:{pk:".",nm:"Boolean"},mt:"m",an:{doc:["The predicate the element must satisfy."]},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"}},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The predicate the element must satisfy."]},$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"find"},follow:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Iterable"},pa:9,mt:"m",an:{see:["chain"],doc:["Produces a stream with a given [[initial element|head]], \nfollowed by the elements of this stream, in the order \nin which they occur in this stream.\n\nFor example, the expression\n\n    (1..3).follow(0)\n\nevaluates to the stream `{ 0, 1, 2, 3 }`.\n\nNote that the expression `stream.follow(head)` eagerly \nevaluates `head`, and therefore is not precisely the \nsame as this enumeration expression, where `head` is\nevaluated lazily:\n\n    { head, *stream }"]},tp:[{nm:"Other"}],ps:[[{$t:{nm:"Other"},mt:"prm",nm:"head"}]],nm:"follow"},iterator:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"},pa:5,mt:"m",an:{doc:["An iterator for the elements belonging to this stream."]},nm:"iterator"},interpose:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},pa:9,mt:"m",an:{see:["interleave"],throws:["AssertionError","if `step<1`"],doc:["A stream that contains the given [[element]] interposed\nbetween blocks of [[step]] elements of this stream. The\nresulting stream starts with the [[first]] element of \nthis stream and ends with the [[last]] element of this\nstream. Elements of this stream occur in the resulting\nstream in the same order they occur in this stream.\n\nFor example, the expression\n\n    String(\"hello\".interpose(' '))\n\nevaluates to the string `\"h e l l o\"`."]},tp:[{nm:"Other"}],$c:{anon$26$jkxvgz:{super:{pk:".",nm:"Basic"},$anon:1,mt:"c",sts:[{tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"}],nm:"anon$26$jkxvgz"}},$o:{$m:{iterator:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],pk:".",nm:"Iterator"},pa:3,mt:"m",nm:"iterator"}},$at:{last:{$t:{comp:"u",l:[{nm:"Absent"},{nm:"Element"},{nm:"Other"}]},pa:3,mt:"g",nm:"last"},empty:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"g",nm:"empty"},first:{$t:{comp:"u",l:[{nm:"Absent"},{nm:"Element"},{nm:"Other"}]},pa:3,mt:"g",nm:"first"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"}}},ps:[[{$t:{nm:"Other"},mt:"prm",an:{doc:["The value to interpose between blocks of \nelements of this stream."]},nm:"element"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The step size that determines how often the \ngiven [[element]] occurs in the resulting \nstream. The `element` occurs after each block \nof size `step` of elements of this stream. If \n`step==1`, the `element` occurs at every second \nposition."]},nm:"step"}]],nm:"interpose"},max:{$t:{comp:"u",l:[{nm:"Element"},{nm:"Absent"}]},pa:9,mt:"m",an:{doc:["Return the largest value in the stream, as measured by\nthe given [[comparator function|comparing]] imposing a \npartial order upon the elements of the stream, or `null`\nif this stream is empty.\n\nFor example, the expression\n\n    {-10.0, -1.0, 5.0}.max(byIncreasing(Float.magnitude))\n\nevaluates to `-10`.\n\nFor any nonempty stream `it`, and comparator function \n`c`, `it.max(c)` evaluates to the first element of `it` \nsuch that for every element `e` of `it`, \n`c(e, it.max(c)) != larger`.\n\nNote that the toplevel functions [[ceylon.language::max]]\nand [[ceylon.language::min]] may be used to find the  \nlargest and smallest values in a stream of [[Comparable]] \nvalues, according to the natural order of its elements."]},$m:{comparing$iit3az:{$t:{pk:".",nm:"Comparison"},mt:"m",an:{doc:["The function comparing pairs of elements."]},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],nm:"comparing"}},ps:[[{$t:{pk:".",nm:"Comparison"},mt:"prm",an:{doc:["The function comparing pairs of elements."]},$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],nm:"comparing"}]],nm:"max"},select:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:9,mt:"m",an:{see:["filter"],doc:["Produce a new [[sequence|Sequential]] containing all \nelements of this stream that satisfy the given \n[[predicate function|selecting]], in the order in \nwhich they occur in this stream.\n\nThis operation is an eager counterpart to [[filter]]. \nFor any stream `it`, and predicate `p`:\n\n    it.select(p) == [*it.filter(p)]"]},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The predicate the elements must satisfy."]},$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"select"},fold:{$t:{nm:"Result"},pa:9,mt:"m",an:{see:["reduce","scan"],doc:["Beginning with a given [[initial value|initial]], apply \nthe given [[combining function|accumulating]] to each \nelement of this stream in turn, progressively \naccumulating a single result.\n\nFor an empty stream, `fold()` returns the given initial \nvalue `z`:\n\n    {}.fold(z)(f) == z\n\nFor a given nonempty stream `it`, initial value `z`, \nand combining function `f`, the result of `fold()` is \nobtained according to the following recursive \ndefinition:\n\n    it.fold(z)(f) == f(it.exceptLast.fold(z)(f), it.last)\n\nFor example, the expression\n\n    (1..100).fold(0)(plus<Integer>)\n\nresults in the integer `5050`."]},tp:[{nm:"Result"}],$m:{accumulating$s830c5:{$t:{nm:"Result"},mt:"m",an:{doc:["The accumulating function that accepts an\nintermediate result, and the next element."]},ps:[[{$t:{nm:"Result"},mt:"prm",nm:"partial"},{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"accumulating"}},ps:[[{$t:{nm:"Result"},mt:"prm",nm:"initial"}],[{$t:{nm:"Result"},mt:"prm",an:{doc:["The accumulating function that accepts an\nintermediate result, and the next element."]},$pt:"f",ps:[[{$t:{nm:"Result"},mt:"prm",nm:"partial"},{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"accumulating"}]],nm:"fold"},defaultNullElements:{$t:{tp:[{comp:"u",mt:"tp",l:[{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},{nm:"Default"}]},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},pa:9,mt:"m",an:{see:["coalesced"],doc:["Produces a stream containing the elements of this \nstream, in the order in which they occur in this stream, \nafter replacing every `null` element in the stream with \nthe [[given default value|defaultValue]]. The value \n`null` does not ocur in the resulting stream.\n\nFor example, the expression\n\n    { \"123\", \"abc\", \"456\" }.map(parseInteger).defaultNullElements(0)\n\nresults in the stream `{ 123, 0, 456 }`."]},tp:[{sts:[{pk:".",nm:"Object"}],nm:"Default"}],ps:[[{$t:{nm:"Default"},mt:"prm",an:{doc:["A default value that replaces `null` elements."]},nm:"defaultValue"}]],nm:"defaultNullElements"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:9,mt:"m",an:{doc:["The [[index]]th element returned by an iterator of this \nstream, or `null` if there are fewer than `index+1`\nelements in the stream. For a stream with an unstable \niteration order, a different value might be produced \neach time `getFromFirst(index)` is called for a given\ninteger `index`."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromFirst"},reduce:{$t:{comp:"u",l:[{nm:"Result"},{nm:"Element"},{nm:"Absent"}]},pa:9,mt:"m",an:{see:["fold"],doc:["Beginning with the [[first]] element of this stream,\napply the given [[combining function|accumulating]] to \neach element of this stream in turn, progressively\naccumulating a single result.\n\nFor an empty stream, `reduce()` always returns `null`.\n\nFor a stream with one element, `reduce()` returns that\nelement:\n\n    { first }.reduce(f) == first\n\nFor a given stream `it` with more than one element, \nand combining function `f`, the result of `reduce()` is \nobtained according to the following recursive \ndefinition:\n\n    it.reduce(f) == f(it.exceptLast.reduce(f), it.last)\n\nFor example, the expression\n\n    (1..100).reduce(plus<Integer>)\n\nresults in the integer `5050`."]},tp:[{nm:"Result"}],$m:{accumulating$tag08u:{$t:{nm:"Result"},mt:"m",an:{doc:["The accumulating function that accepts an\nintermediate result, and the next element."]},ps:[[{$t:{comp:"u",l:[{nm:"Result"},{nm:"Element"}]},mt:"prm",nm:"partial"},{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"accumulating"}},ps:[[{$t:{nm:"Result"},mt:"prm",an:{doc:["The accumulating function that accepts an\nintermediate result, and the next element."]},$pt:"f",ps:[[{$t:{comp:"u",l:[{nm:"Result"},{nm:"Element"}]},mt:"prm",nm:"partial"},{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"accumulating"}]],nm:"reduce"},product:{$t:{tp:[{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{comp:"u",l:[{nm:"Other"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"Element"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"Other"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Other"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}],pk:".",nm:"Tuple"},{comp:"u",mt:"tp",l:[{nm:"Absent"},{nm:"OtherAbsent"}]}],pk:".",nm:"Iterable"},pa:9,mt:"m",an:{doc:["A stream of pairs of elements of this stream and the \nthe given stream, where for each element `x` of this\nstream, and element `y` of the given stream, the\npair `[x,y]` belongs to the resulting stream. The pairs\nare sorted first by the position of `x` in this stream,\nand then by the position of `y` in the given stream.\n\nFor example, this expression\n\n    (1..3).product(\"ab\")\n\nevaluates to the stream \n`{ [1,'a'], [1,'b'], [2,'a'], [2,'b'], [3,'a'], [3,'b'] }`."]},tp:[{nm:"Other"},{sts:[{pk:".",nm:"Null"}],nm:"OtherAbsent"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Other"},{mt:"tp",nm:"OtherAbsent"}],pk:".",nm:"Iterable"},mt:"prm",nm:"other"}]],nm:"product"},narrow:{$t:{tp:[{comp:"i",mt:"tp",l:[{nm:"Element"},{nm:"Type"}]},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:9,mt:"m",an:{doc:["Produces a stream containing the elements of this \nstream that are instances of the given [[type|Type]].\n\nFor example, the expression\n\n    { 1, 2, null, 3 }.narrow<Object>()\n\nresults in the stream `{ 1, 2, 3 }` of type `{Integer*}`.\n\nIf the type argument `Type` is not explicitly specified,\n[[Nothing]] is inferred, and the resulting stream is \nempty."]},tp:[{nm:"Type"}],nm:"narrow"},chain:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]},{comp:"i",mt:"tp",l:[{nm:"Absent"},{nm:"OtherAbsent"}]}],pk:".",nm:"Iterable"},pa:9,mt:"m",an:{see:["expand"],doc:["The elements of this stream, in the order in which they \noccur in this stream, followed by the elements of the \n[[given stream|other]] in the order in which they occur \nin the given stream.\n\nFor example, the expression\n\n    (1..3).chain(\"abc\")\n\nevaluates to the stream `{ 1, 2, 3, 'a', 'b', 'c' }`."]},tp:[{nm:"Other"},{sts:[{pk:".",nm:"Null"}],nm:"OtherAbsent"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Other"},{mt:"tp",nm:"OtherAbsent"}],pk:".",nm:"Iterable"},mt:"prm",nm:"other"}]],nm:"chain"},shorterThan:{$t:{pk:".",nm:"Boolean"},pa:9,mt:"m",an:{see:["size"],doc:["Determines if this stream has fewer elements than the \ngiven [[length]]. This is an efficient operation for \nstreams with many elements."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"shorterThan"},take:{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:9,mt:"m",an:{see:["List.sublistTo","List.initial","takeWhile","skip"],doc:["Produces a stream containing the first [[taking]]\nelements of this stream.\n\nIf the specified number of elements to take is larger \nthan the number of elements of this stream, the \nresulting stream contains the same elements as this \nstream. If the specified number of elements to take is\nfewer than one, the resulting stream has no elements."]},$c:{anon$8$ox8tqr:{super:{pk:".",nm:"Basic"},$anon:1,mt:"c",sts:[{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"}],nm:"anon$8$ox8tqr"}},$o:{$m:{iterator:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"},pa:3,mt:"m",$c:{anon$9$kcsx3m:{super:{pk:".",nm:"Basic"},$anon:1,mt:"c",sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"}],nm:"anon$9$kcsx3m"}},$o:{$m:{next:{$t:{comp:"u",l:[{nm:"Element"},{pk:".",nm:"Finished"}]},pa:3,mt:"m",nm:"next"}},$at:{i$ywcod6:{$t:{pk:".",nm:"Integer"},pa:1024,mt:"a",nm:"i"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"}}},nm:"iterator"}},$at:{first:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,mt:"g",nm:"first"}}},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"taking"}]],nm:"take"},sequence:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:9,mt:"m",an:{doc:["A [[sequence|Sequential]] containing all the elements \nof this stream, in the same order they occur in this\nstream. This operation eagerly evaluates and collects \nevery element of the stream."]},nm:"sequence"},scan:{$t:{tp:[{mt:"tp",nm:"Result"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Iterable"},pa:9,mt:"m",an:{see:["fold"],doc:["The stream of intermediate results obtained by \nbeginning with a given [[initial value|initial]] and\niteratively applying the given \n[[combining function|accumulating]] to each element of \nthis stream in turn.\n\nFor an empty stream, `scan()` returns a stream \ncontaining just the given initial value `z`:\n\n    {}.scan(z)(f) == { z }\n\nFor a given nonempty stream `it`, initial value `z`, \nand combining function `f`, the result of `scan()` is \nobtained according to the following recursive \ndefinition:\n\n    it.scan(z)(f).last == f(it.exceptLast.scan(z)(f).last, it.last)\n    it.scan(z)(f).exceptLast == it.exceptLast.scan(z)(f)\n\nThe following identities explain the relationship \nbetween `scan` and [[fold]]:\n\n    it.scan(z)(f).getFromFirst(n) == it.taking(n).fold(z)(f)\n    it.scan(z)(f).last == it.fold(z)(f)\n    it.scan(z)(f).first == {}.fold(z)(f) == z\n\nFor example, the expression\n\n    (1..4).scan(0)(plus<Integer>)\n\nresults in the stream `{ 0, 1, 3, 6, 10 }`."]},tp:[{nm:"Result"}],ps:[[{$t:{nm:"Result"},mt:"prm",nm:"initial"}],[{$t:{nm:"Result"},mt:"prm",an:{doc:["The accumulating function that accepts\nthe running total and the next element."]},$pt:"f",ps:[[{$t:{nm:"Result"},mt:"prm",nm:"partial"},{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"accumulating"}]],nm:"scan"},each:{$t:{pk:".",nm:"Anything"},pa:9,mt:"m",an:{doc:["Call the given [[function|step]] for each element of \nthis stream, passing the elements in the order they \noccur in this stream.\n\nFor example:\n\n    words.each(void (word) {\n        print(word.lowercased);\n        print(word.uppercased);\n    });\n\nHas the same effect as the following `for` loop:\n\n    for (word in words) {\n        print(word.lowercased);\n        print(word.uppercased);\n    }\n\n_For certain streams this method is highly efficient,\nsurpassing the performance of `for` loops on the JVM.\nThus, `each()` is sometimes preferred in highly \nperformance-critical low-level code._"]},$m:{step$mutwiu:{$t:{pk:".",nm:"Anything"},mt:"m",an:{doc:["The function to be called for each element in the\nstream."]},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"step"}},ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",an:{doc:["The function to be called for each element in the\nstream."]},$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"step"}]],nm:"each"},findLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:9,mt:"m",an:{doc:["The last element of this stream which satisfies the \n[[given predicate function|selecting]], if any, or \n`null` if there is no such element. For an infinite \nstream, this method will not terminate.\n\nFor example, the expression\n\n    (-10..10).findLast(3.divides)\n\nevaluates to `9`."]},$m:{selecting$fbqcn6:{$t:{pk:".",nm:"Boolean"},mt:"m",an:{doc:["The predicate the element must satisfy."]},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"}},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The predicate the element must satisfy."]},$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"findLast"},spread:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Result"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},{mt:"tp",nm:"Args"}],pk:".",nm:"Callable"},pa:9,mt:"m",an:{doc:["Given a [[method]] of the element type [[Element]], \nreturn a function that, when supplied with a list of \nmethod arguments, produces a new iterable object that \napplies the `method` to each element of this iterable \nobject in turn.\n\n    {Boolean+}(Object) fun = (-1..1).spread(Object.equals);\n    print(fun(0)); \/\/prints { false, true, false }"]},tp:[{nm:"Result"},{sts:[{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"Sequential"}],nm:"Args"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Result"},{mt:"tp",nm:"Args"}],pk:".",nm:"Callable"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"method"}]],nm:"spread"},filter:{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:9,mt:"m",an:{see:["select"],doc:["Produces a stream containing the elements of this \nstream that satisfy the given [[predicate \nfunction|selecting]].\n\nFor any empty stream, `filter()` returns an empty \nstream:\n\n    {}.filter(p) == {}\n\nFor any nonempty stream `it`, and predicate `p`, the \nresult of `filter()` may be obtained according to this\nrecursive definition:\n\n    it.filter(p) == { if (p(it.first)) it.first }.chain(it.rest.filter(f))\n\nAlternatively, and in practice, `filter()` may be \ndefined by this comprehension:\n\n    it.filter(p) == { for (e in it) if (p(e)) e };\n\nFor example, the expression\n\n    (1..100).filter(13.divides)\n\nresults in the stream `{ 13, 26, 39, 52, 65, 78, 91 }`."]},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The predicate the elements must satisfy."]},$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"filter"},collect:{$t:{tp:[{mt:"tp",nm:"Result"}],pk:".",nm:"Sequential"},pa:9,mt:"m",an:{see:["map"],doc:["Produce a new [[sequence|Sequential]] containing the \nresults of applying the given [[mapping|collecting]] to\nthe elements of this stream.\n\nThis operation is an eager counterpart to [[map]]. For\nany stream `it`, and mapping `f`:\n\n    it.collect(f) == [*it.map(f)]"]},tp:[{nm:"Result"}],ps:[[{$t:{nm:"Result"},mt:"prm",an:{doc:["The transformation applied to the elements."]},$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"collecting"}]],nm:"collect"}},$c:{anon$17$izouad:{super:{pk:".",nm:"Basic"},$anon:1,mt:"c",sts:[{tp:[{mt:"tp",tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",nm:"Element"}],pk:".",nm:"Entry"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"}],nm:"anon$17$izouad"},anon$19$izowef:{super:{pk:".",nm:"Basic"},$anon:1,mt:"c",sts:[{tp:[{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{comp:"u",l:[{nm:"Element"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"Element"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}],pk:".",nm:"Tuple"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"}],nm:"anon$19$izowef"},anon$2$d11xxn:{super:{pk:".",nm:"Basic"},$anon:1,mt:"c",sts:[{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"}],nm:"anon$2$d11xxn"},anon$24$izpnv5:{super:{pk:".",nm:"Basic"},$anon:1,mt:"c",sts:[{tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"}],nm:"anon$24$izpnv5"}},$at:{paired:{$t:{tp:[{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{comp:"u",l:[{nm:"Element"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"Element"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}],pk:".",nm:"Tuple"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:9,mt:"g",an:{doc:["A stream containing whose elements are pairs (2-tuples)\ncomprising an element of this stream paired with the \nnext element in the stream. The resulting stream has\none fewer elements than this stream.\n\nFor example, the expression\n\n    (1..5).paired\n\nresults in the stream \n`{ [1, 2], [2, 3], [3, 4], [4, 5] }`.\n\nThis expression determines if a stream is monotonically\nincreasing:\n\n    every { for ([x, y] in nums.paired) x < y }\n\nFor any stable `stream`, this operation is equivalent \nto `zipPairs(stream,stream.rest)`."]},nm:"paired"},cycled:{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},pa:9,mt:"g",an:{see:["repeat"],doc:["An infinite stream that produces the elements of this \nstream, repeatedly.\n\nFor example, the expression\n\n    {6, 9}.cycled.taking(5)\n\nevaluates to the stream `{ 6, 9, 6, 9, 6 }`."]},nm:"cycled"},last:{$t:{comp:"u",l:[{nm:"Absent"},{nm:"Element"}]},pa:9,mt:"g",an:{doc:["The last element returned by the iterator, if any, or \n`null` if this stream is empty. In the case of an \ninfinite stream, this operation never terminates;\nfurthermore, this default implementation iterates all \nelements, which might be very expensive."]},nm:"last"},indexed:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",nm:"Element"}],pk:".",nm:"Entry"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},pa:9,mt:"g",an:{doc:["A stream containing all [[entries|Entry]] of form\n`index->element` where `element` is an element of this\nstream, and `index` is the position at which `element`\noccurs in this stream, ordered by increasing `index`.\n\nFor example, the expression\n\n    { \"hello\", null, \"world\" }.indexed\n\nresults in the stream `{ 0->\"hello\", 1->null, 2->\"world\" }`."]},nm:"indexed"},string:{$t:{pk:".",nm:"String"},pa:11,mt:"g",an:{doc:["A string of form `\"{ x, y, z }\"` where `x`, `y`, and \n`z` are the `string` representations of the elements of \nthis collection, as produced by the iterator of the \nstream, or the string `\"{}\"` if this stream is empty. \nIf the stream is very long, the list of elements might \nbe truncated, as indicated by an ellipse."]},nm:"string"},coalesced:{$t:{tp:[{comp:"i",mt:"tp",l:[{nm:"Element"},{pk:".",nm:"Object"}]},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:9,mt:"g",an:{see:["defaultNullElements"],doc:["The non-null elements of this stream, in the order in\nwhich they occur in this stream. For null elements of \nthe original stream, there is no entry in the resulting \nstream.\n\nFor example, the expression\n\n    { \"123\", \"abc\", \"456\"}.map(parseInteger).coalesced\n\nresults in the stream `{ 123, 456 }`."]},nm:"coalesced"},empty:{$t:{pk:".",nm:"Boolean"},pa:9,mt:"g",an:{doc:["Determines if the stream is empty, that is to say, if \nthe iterator returns no elements."]},nm:"empty"},exceptLast:{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:9,mt:"g",an:{doc:["A stream containing all but the last element of this \nstream. For a stream with an unstable iteration order, \na different stream might be produced each time \n`exceptLast` is evaluated."]},nm:"exceptLast"},rest:{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:9,mt:"g",an:{see:["first"],doc:["A stream containing all but the first element of this \nstream. For a stream with an unstable iteration order, \na different stream might be produced each time `rest` \nis evaluated.\n\nTherefore, if the stream `i` has an unstable iteration\norder, the stream `{ i.first, *i.rest }` might not have\nthe same elements as `i`."]},nm:"rest"},first:{$t:{comp:"u",l:[{nm:"Absent"},{nm:"Element"}]},pa:9,mt:"g",an:{doc:["The first element returned by the iterator, if any, or \n`null` if this stream is empty. For a stream with an\nunstable iteration order, a different value might be\nproduced each time `first` is evaluated."]},nm:"first"},size:{$t:{pk:".",nm:"Integer"},pa:9,mt:"g",an:{doc:["The number of elements returned by the [[iterator]] of \nthis stream, if the iterator terminates. In the case of \nan infinite stream, this operation never terminates."]},nm:"size"}},$o:{$m:{iterator:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"},pa:3,mt:"m",nm:"iterator"}},$at:{orig$j7aae3:{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},mt:"g",nm:"orig"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},empty:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"g",nm:"empty"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"}}},nm:"Iterable"},mapPairs:{$t:{tp:[{mt:"tp",nm:"Result"},{comp:"u",mt:"tp",l:[{nm:"FirstAbsent"},{nm:"SecondAbsent"}]}],pk:".",nm:"Iterable"},pa:1,mt:"m",an:{doc:["Given two streams, form a new stream by applying a binary\n[[mapping function|collecting]] to pairs of elements in the \ngiven streams.  If one of the streams is longer than the \nother, simply ignore additional elements of the longer \nstream with no pair in the other stream. The length of the \nresulting stream is the length of the shorter of the two \ngiven streams.\n\nFor any given streams `xs` and `ys`, and mapping function \n`f`, `mapPairs()` may be defined in terms of \n[[Iterable.map]], [[zipPairs]], and [[unflatten]]:\n\n    mapPairs(f, xs, ys) == zipPairs(xs, ys).map(unflatten(f))\n\nFor example the expression\n\n    mapPairs((Float x, Float y) => (x^2+y^2)^0.5, \n            {1.0, 2.0, 1.0}, {1.0, 1.0, 2.0})\n    \nevaluates to the stream `{ 1.0, 3.0, 3.0 }`."]},tp:[{nm:"Result"},{nm:"First"},{nm:"Second"},{sts:[{pk:".",nm:"Null"}],nm:"FirstAbsent"},{sts:[{pk:".",nm:"Null"}],nm:"SecondAbsent"}],$m:{collecting$tyqi0b:{$t:{nm:"Result"},mt:"m",an:{doc:["The mapping function to apply to the pair of elements."]},ps:[[{$t:{nm:"First"},mt:"prm",nm:"first"},{$t:{nm:"Second"},mt:"prm",nm:"second"}]],nm:"collecting"}},$o:{iterable$x16jqt:{super:{pk:".",nm:"Basic"},mt:"o",sts:[{tp:[{mt:"tp",nm:"Result"},{comp:"u",mt:"tp",l:[{nm:"FirstAbsent"},{nm:"SecondAbsent"}]}],pk:".",nm:"Iterable"}],$m:{iterator:{$t:{tp:[{mt:"tp",nm:"Result"}],pk:".",nm:"Iterator"},pa:3,mt:"m",$o:{iterator$5i9ypz:{super:{pk:".",nm:"Basic"},mt:"o",sts:[{tp:[{mt:"tp",nm:"Result"}],pk:".",nm:"Iterator"}],$m:{next:{$t:{comp:"u",l:[{nm:"Result"},{pk:".",nm:"Finished"}]},pa:3,mt:"m",nm:"next"}},$at:{secondIter$6wrzi8:{$t:{tp:[{mt:"tp",nm:"Second"}],pk:".",nm:"Iterator"},mt:"a",nm:"secondIter"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},firstIter$ruc02k:{$t:{tp:[{mt:"tp",nm:"First"}],pk:".",nm:"Iterator"},mt:"a",nm:"firstIter"}},nm:"iterator"}},nm:"iterator"}},nm:"iterable"}},ps:[[{$t:{nm:"Result"},mt:"prm",an:{doc:["The mapping function to apply to the pair of elements."]},$pt:"f",ps:[[{$t:{nm:"First"},mt:"prm",nm:"first"},{$t:{nm:"Second"},mt:"prm",nm:"second"}]],nm:"collecting"},{$t:{tp:[{mt:"tp",nm:"First"},{mt:"tp",nm:"FirstAbsent"}],pk:".",nm:"Iterable"},mt:"prm",nm:"firstIterable"},{$t:{tp:[{mt:"tp",nm:"Second"},{mt:"tp",nm:"SecondAbsent"}],pk:".",nm:"Iterable"},mt:"prm",nm:"secondIterable"}]],nm:"mapPairs"},OptionalAnnotation:{of:[{nm:"Value"}],pa:1,mt:"i",an:{see:["Annotation"],doc:["An annotation that may occur at most once at a given \nprogram element and only on certain program elements.\n\nAn optional annotation is declared simply by having the \nannotation class satisfy `OptionalAnnotation` instead of \n[[Annotation]]. For example the following would only be \nallowed on `class` declarations:\n\n    final annotation class ExampleClass() \n            satisfies OptionalAnnotation<Example, ClassDeclaration> {}\n\nAt runtime a [[ceylon.language.meta.declaration::Declaration]] \ninstance can be queried for its `OptionalAnnotation`s of a \ncertain type using [[ceylon.language.meta::annotations]] or \n[[ceylon.language.meta::optionalAnnotation]]."]},sts:[{tp:[{mt:"tp",nm:"Value"},{comp:"u",mt:"tp",l:[{pk:".",nm:"Null"},{nm:"Value"}]},{mt:"tp",nm:"ProgramElement"},{mt:"tp",nm:"Type"}],pk:".",nm:"ConstrainedAnnotation"}],tp:[{dv:"out",sts:[{tp:[{mt:"tp",nm:"Value"},{mt:"tp",nm:"ProgramElement"},{mt:"tp",nm:"Type"}],pk:".",nm:"OptionalAnnotation"}],nm:"Value"},{dv:"in",def:{pk:".",nm:"Annotated"},sts:[{pk:".",nm:"Annotated"}],nm:"ProgramElement"},{dv:"out",def:{pk:".",nm:"Anything"},nm:"Type"}],st:"Value",nm:"OptionalAnnotation"},className:{$t:{pk:".",nm:"String"},pa:65,mt:"m",an:{doc:["Return the name of the concrete class of the given object, \nin a format native to the virtual machine."]},ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"obj"}]],nm:"className"},serializable:{$t:{pk:".",nm:"SerializableAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to specify that a class is serializable.\n \nA serializable class may have instances that cannot be \nserialized if those instances have reachable references to \ninstances of non-serializable classes."]},nm:"serializable"},List:{pa:1,mt:"i",an:{see:["Sequence","Empty","Array"],doc:["Represents a collection in which every element has a \nunique non-negative integer index. The elements of a\nnonempty list are indexed starting with `0` at the \n[[first]] element of the list, and ending with the index\n[[lastIndex]] at the [[last]] element of the list.\n\n- For any nonempty list, `lastIndex==size-1`. \n- For an empty list, `size==0` and the `lastIndex` is \n  `null`.\n\nThus, the range of indexes of the list is formed by the \nexpression `0:list.size`.\n\nA `List` is a [[Collection]] of its elements, and a \n[[Correspondence]] from indices to elements.\n\nEvery list has a well-defined and stable iteration order.\nAn [[iterator]] of a nonempty list is required to return \nthe elements of the list in order of increasing index, \nbeginning with the element at index `0`, and ending with\nthe element at index `lastIndex`. Thus, every iterator of \nan immutable list produces exactly the same elements in \nexactly the same order.\n\nDirect access to a list element by index produces a value \nof optional type. The following idiom may be used instead \nof upfront bounds-checking, as long as the list element \ntype is a non-`null` type:\n\n    if (exists char = \"hello world\"[index]) { \n        \/\/do something with char\n    }\n    else {\n        \/\/out of bounds\n    }\n\nWhen an algorithm guarantees that a list contains a given \nindex, the following idiom may be used:\n\n    assert (exists char = \"hello world\"[index]);\n    \/\/do something with char\n\nTo iterate the indices of a `List`, use the following\nidiom:\n\n    for (i->char in \"hello world\".indexed) { ... }\n\n[[Strings|String]], [[sequences|Sequential]], \n[[tuples|Tuple]], and [[arrays|Array]] are all `List`s,\nand are all of fixed length. Variable-length mutable\n`List`s are also possible."]},sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Collection"},{tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",nm:"Element"}],pk:".",nm:"Correspondence"},{tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",nm:"Element"},{mt:"tp",tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"}],pk:".",nm:"Ranged"}],tp:[{dv:"out",def:{pk:".",nm:"Anything"},nm:"Element"}],$m:{measure:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:11,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"measure"},longerThan:{$t:{pk:".",nm:"Boolean"},pa:11,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"longerThan"},trimLeading:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:9,mt:"m",an:{doc:["Trim the elements satisfying the given [[predicate \nfunction|trimming]], along with any null elements, from\nthe start of this list, returning a list no longer than \nthis list.\n\nThis is an eager operation."]},$m:{trimming$yvqbbg:{$t:{pk:".",nm:"Boolean"},mt:"m",an:{doc:["The predicate function that the trimmed \nelements satisfy."]},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"elem"}]],nm:"trimming"}},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The predicate function that the trimmed \nelements satisfy."]},$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"elem"}]],nm:"trimming"}]],nm:"trimLeading"},contains:{$t:{pk:".",nm:"Boolean"},pa:11,mt:"m",an:{see:["occurs"],doc:["Determines if this list contains the given value.\nReturns `true` for every element of this list."]},ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],nm:"contains"},getElement$v2oaho:{$t:{nm:"Element"},mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getElement"},repeat:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:11,mt:"m",an:{doc:["A list containing the elements of this list repeated \nthe [[given number of times|times]], or an empty list\nif `times<=0`. For every `index` of a repeated `list`:\n\n    list.repeat(n)[index]==list[index%n]\n\nThis is a lazy operation returning a view of this list."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"times"}]],nm:"repeat"},includes:{$t:{pk:".",nm:"Boolean"},pa:9,mt:"m",an:{doc:["Determine if the given [[list|sublist]] occurs as a \nsublist at some index in this list."]},ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"List"},mt:"prm",nm:"sublist"}]],nm:"includes"},firstInclusion:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:9,mt:"m",an:{doc:["The first index in this list at which the given \n[[list|sublist]] occurs as a sublist."]},ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"List"},mt:"prm",nm:"sublist"}]],nm:"firstInclusion"},occurs:{$t:{pk:".",nm:"Boolean"},pa:9,mt:"m",an:{doc:["Determines if the given [[value|element]] occurs as an \nelement of this list."]},ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",an:{doc:["The value. If null, it is considered to occur\nat any index in this list with a null element."]},nm:"element"}]],nm:"occurs"},getFromLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:9,mt:"m",an:{doc:["Returns the element of this list with the given \n[[index]], where the list is indexed from the _end_ of \nthe list instead of from the start, if the index refers\nto an element of this list, or `null` otherwise. The\nlast element of the list has index `0`, and the first\nelement has index [[lastIndex]]."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromLast"},firstOccurrence:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:9,mt:"m",an:{doc:["The first index in this list at which the given \n[[value|element]] occurs."]},ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",an:{doc:["The value. If null, it is considered to occur\nat any index in this list with a null element."]},nm:"element"}]],nm:"firstOccurrence"},terminal:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:9,mt:"m",an:{see:["initial"],doc:["Select the last elements of the list, returning a list \nno longer than the given length. If this list is \nshorter than the given length, return this list. \nOtherwise return a list of the given length.\n\nFor any `list`, and for any integer `length`:\n\n    list.terminal(length) == list[size-length...]\n\nThis is an eager operation."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"terminal"},spanTo:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:11,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"spanTo"},initial:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:9,mt:"m",an:{see:["terminal","sublistTo","take"],doc:["Select the first elements of this list, returning a \nlist no longer than the given length. If this list is \nshorter than the given length, return this list. \nOtherwise return a list of the given length.\n\nFor any `list`, and for any integer `length`:\n\n    list.initial(length) == list[...length-1] == list[0:length]\n\nThis is an eager operation."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"initial"},occurrences:{$t:{tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:9,mt:"m",an:{doc:["The indexes in this list at which the given \n[[value|element]] occurs."]},ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",an:{doc:["The value. If null, it is considered to occur\nat any index in this list with a null element."]},nm:"element"}]],nm:"occurrences"},inclusions:{$t:{tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:9,mt:"m",an:{doc:["The indexes in this list at which the given \n[[list|sublist]] occurs as a sublist."]},ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"List"},mt:"prm",nm:"sublist"}]],nm:"inclusions"},trim:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:9,mt:"m",an:{doc:["Trim the elements satisfying the given [[predicate \nfunction|trimming]], along with any null elements, from \nthe start and end of this list, returning a list no \nlonger than this list.\n\nThis is an eager operation."]},$m:{trimming$68e1qa:{$t:{pk:".",nm:"Boolean"},mt:"m",an:{doc:["The predicate function that the trimmed \nelements satisfy."]},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"elem"}]],nm:"trimming"}},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The predicate function that the trimmed \nelements satisfy."]},$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"elem"}]],nm:"trimming"}]],nm:"trim"},spanFrom:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:11,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],nm:"spanFrom"},find:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:11,mt:"m",$m:{selecting$98r208:{$t:{pk:".",nm:"Boolean"},mt:"m",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"elem"}]],nm:"selecting"}},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"elem"}]],nm:"selecting"}]],nm:"find"},sublistFrom:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:9,mt:"m",an:{see:["skip"],doc:["A sublist of this list, starting at the element with\nthe given [[index|from]].\n\nThis is a lazy operation, returning a view of this list."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],nm:"sublistFrom"},clone:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:11,mt:"m",an:{doc:["A shallow copy of this list, that is, a list with the\nsame elements as this list, which do not change if the\nelements of this list change."]},nm:"clone"},indexesWhere:{$t:{tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:9,mt:"m",an:{doc:["The indexes in this list for which the element is not\nnull and satisfies the given \n[[predicate function|selecting]]."]},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The predicate function the indexed elements \nmust satisfy"]},$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"indexesWhere"},iterator:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"},pa:11,mt:"m",$c:{anon$0$cdpswa:{super:{pk:".",nm:"Basic"},$anon:1,mt:"c",sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"}],nm:"anon$0$cdpswa"}},$o:{$m:{next:{$t:{comp:"u",l:[{nm:"Element"},{pk:".",nm:"Finished"}]},pa:3,mt:"m",nm:"next"}},$at:{string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},size$nv92nu:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"size"},index$dvr23n:{$t:{pk:".",nm:"Integer"},pa:1024,mt:"a",nm:"index"}}},nm:"iterator"},startsWith:{$t:{pk:".",nm:"Boolean"},pa:9,mt:"m",an:{see:["endsWith"],doc:["Determine if the given [[list|sublist]] occurs at the \nstart of this list."]},ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"List"},mt:"prm",nm:"sublist"}]],nm:"startsWith"},get:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,mt:"m",an:{doc:["Returns the element of this list with the given \n[[index]] if the index refers to an element of this\nlist, that is, if `0<=index<=list.lastIndex`, or `null` \notherwise. The first element of the list has index `0`,\nand the last element has index [[lastIndex]]."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"get"},equals:{$t:{pk:".",nm:"Boolean"},pa:11,mt:"m",an:{doc:["Two `List`s are considered equal iff they have the \nsame `size` and _entry sets_. The entry set of a list \n`list` is the set of elements of `list.indexed`. This \ndefinition is equivalent to the more intuitive notion \nthat two lists are equal iff they have the same `size` \nand for every index either:\n\n- the lists both have the element `null`, or\n- the lists both have a non-null element, and the\n  two elements are equal.\n\nAs a special exception, a [[String]] is not equal to \nany list which is not also a [[String]]."]},ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],nm:"equals"},firstIndexWhere:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:9,mt:"m",an:{doc:["The first index in this list for which the element is\nnot null and satisfies the given \n[[predicate function|selecting]]."]},$m:{selecting$xlulik:{$t:{pk:".",nm:"Boolean"},mt:"m",an:{doc:["The predicate function the indexed elements \nmust satisfy"]},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"}},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The predicate function the indexed elements \nmust satisfy"]},$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"firstIndexWhere"},occursAt:{$t:{pk:".",nm:"Boolean"},pa:9,mt:"m",an:{doc:["Determines if the given [[value|element]] occurs at the \ngiven index in this list."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",an:{doc:["The index at which the value might occur."]},nm:"index"},{$t:{pk:".",nm:"Anything"},mt:"prm",an:{doc:["The value. If null, it is considered to occur\nat any index in this list with a null element."]},nm:"element"}]],nm:"occursAt"},sublist:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:9,mt:"m",an:{doc:["A sublist of this list, starting at the element with\nindex [[from]], ending at the element with the index \n[[to]].\n\nThis is a lazy operation, returning a view of this list."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"sublist"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:7,mt:"m",an:{see:["getFromLast"],doc:["Returns the element of this list with the given \n[[index]] if the index refers to an element of this\nlist, that is, if `0<=index<=list.lastIndex`, or \n`null` otherwise. The first element of the list has \nindex `0`, and the last element has index [[lastIndex]]."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromFirst"},defines:{$t:{pk:".",nm:"Boolean"},pa:11,mt:"m",an:{doc:["Determines if the given index refers to an element of \nthis list, that is, if `0<=index<=list.lastIndex`."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"defines"},lastInclusion:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:9,mt:"m",an:{doc:["The last index in this list at which the given \n[[list|sublist]] occurs as a sublist."]},ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"List"},mt:"prm",nm:"sublist"}]],nm:"lastInclusion"},shorterThan:{$t:{pk:".",nm:"Boolean"},pa:11,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"shorterThan"},sublistTo:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:9,mt:"m",an:{see:["take","initial"],doc:["A sublist of this list, ending at the element with the \ngiven [[index|to]].\n\nThis is a lazy operation, returning a view of this list."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"sublistTo"},trimTrailing:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:9,mt:"m",an:{doc:["Trim the elements satisfying the given [[predicate \nfunction|trimming]], along with any null elements, from \nthe end of this list, returning a list no longer than \nthis list.\n\nThis is an eager operation."]},$m:{trimming$uacsrm:{$t:{pk:".",nm:"Boolean"},mt:"m",an:{doc:["The predicate function that the trimmed \nelements satisfy."]},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"elem"}]],nm:"trimming"}},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The predicate function that the trimmed \nelements satisfy."]},$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"elem"}]],nm:"trimming"}]],nm:"trimTrailing"},lastIndexWhere:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:9,mt:"m",an:{doc:["The last index in this list for which the element is\nnot null and satisfies the given \n[[predicate function|selecting]]."]},$m:{selecting$j3xxzq:{$t:{pk:".",nm:"Boolean"},mt:"m",an:{doc:["The predicate function the indexed elements \nmust satisfy."]},ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"}},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The predicate function the indexed elements \nmust satisfy."]},$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"lastIndexWhere"},includesAt:{$t:{pk:".",nm:"Boolean"},pa:9,mt:"m",an:{doc:["Determine if the given [[list|sublist]] occurs as a \nsublist at the given index of this list."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",an:{doc:["The index at which the [[sublist]] might occur."]},nm:"index"},{$t:{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"List"},mt:"prm",nm:"sublist"}]],nm:"includesAt"},lastOccurrence:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:9,mt:"m",an:{doc:["The last index in this list at which the given \n[[value|element]] occurs."]},ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",an:{doc:["The value. If null, it is considered to occur\nat any index in this list with a null element."]},nm:"element"}]],nm:"lastOccurrence"},slice:{$t:{tp:[{comp:"u",mt:"tp",l:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},{comp:"u",l:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},{pk:".",nm:"Nothing"}]},{mt:"tp",tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}],pk:".",nm:"Tuple"},pa:9,mt:"m",an:{doc:["Return two lists, the first containing the elements\nthat occur before the given [[index]], the second with\nthe elements that occur after the given `index`. If the\ngiven `index` is outside the range of indices of this\nlist, one of the returned lists will be empty.\n\nFor any `list`, and for any integer `index`:\n\n    list.slice(index) == [list[...index-1], list[index...]]\n\nThis is an eager operation."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"slice"},findLast:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:11,mt:"m",$m:{selecting$h1tj66:{$t:{pk:".",nm:"Boolean"},mt:"m",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"elem"}]],nm:"selecting"}},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{comp:"i",l:[{nm:"Element"},{pk:".",nm:"Object"}]},mt:"prm",nm:"elem"}]],nm:"selecting"}]],nm:"findLast"},endsWith:{$t:{pk:".",nm:"Boolean"},pa:9,mt:"m",an:{see:["startsWith"],doc:["Determine if the given [[list|sublist]] occurs at the \nend of this list."]},ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"List"},mt:"prm",nm:"sublist"}]],nm:"endsWith"},patch:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],pk:".",nm:"List"},pa:9,mt:"m",an:{doc:["Return a list formed by patching the given [[list]] \nin place of a segment of this list identified by the\ngiven [[starting index|from]] and [[length]].\n\nThis is a lazy operations, returning a view over this \nlist and the given list.\n\nFour special cases are interesting:\n\n- If `length==0`, the patched list has the given values \n  \"inserted\" into this list at the given index `from`.\n- If the given `list` is empty, the patched list has \n  the measure of this list identified by `from:length` \n  \"deleted\".\n- If `from==size`, the patched list is formed by\n  appending the given list.\n- If `from==0`, the patched list is formed by \n  prepending the given list.\n\nFor example:\n\n- `(-2..2).patch([],1,3)` produces the list `{-2,2}`, \n  and\n- `[-2, 2].patch(-1..1,1)` produces the list \n  `{-2,-1,0,1,2}`.'\n- `0:3`.patch(2..0) produces the list `{0,1,2,2,1,0}`.\n\nIf `length<0`, or if `from` is outside the range \n`0..size`, return this list."]},tp:[{nm:"Other"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"List"},mt:"prm",an:{doc:["The list of new elements."]},nm:"list"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The index at which the elements will occur, and\nthe start index of the segment to replace."]},nm:"from"},{$t:{pk:".",nm:"Integer"},def:1,mt:"prm",an:{doc:["The length of the segment to replace."]},nm:"length"}]],nm:"patch"},collect:{$t:{tp:[{mt:"tp",nm:"Result"}],pk:".",nm:"Sequential"},pa:11,mt:"m",an:{doc:["A nonempty sequence containing the results of applying \nthe given mapping to the elements of this sequence."]},tp:[{nm:"Result"}],$m:{collecting$rpkv6r:{$t:{nm:"Result"},mt:"m",an:{doc:["The transformation applied to the elements."]},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"collecting"}},$o:{list$98kifc:{super:{pk:".",nm:"Object"},mt:"o",sts:[{tp:[{mt:"tp",nm:"Result"}],pk:".",nm:"List"}],$m:{getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Result"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromFirst"}},$at:{lastIndex:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:3,mt:"g",nm:"lastIndex"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"a",nm:"size"}},nm:"list"}},ps:[[{$t:{nm:"Result"},mt:"prm",an:{doc:["The transformation applied to the elements."]},$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"collecting"}]],nm:"collect"},span:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:11,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"span"}},$c:{Sublist$elvxw4:{super:{pk:".",nm:"Object"},mt:"c",sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"}],$m:{clone:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:3,mt:"m",nm:"clone"},iterator:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},measure:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"measure"},spanTo:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"spanTo"},spanFrom:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],nm:"spanFrom"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromFirst"},span:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"span"}},$at:{lastIndex:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:3,mt:"g",nm:"lastIndex"},to$1d4wke:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"to"}},ps:[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}],nm:"Sublist$elvxw4"},Reversed$ijs9g8:{super:{pk:".",nm:"Object"},mt:"c",sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"}],$m:{clone:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:3,mt:"m",nm:"clone"},iterator:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},measure:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"measure"},spanTo:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"spanTo"},spanFrom:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],nm:"spanFrom"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromFirst"},span:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"span"}},$at:{lastIndex:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:3,mt:"g",nm:"lastIndex"},last:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,mt:"g",nm:"last"},reversed:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:3,mt:"g",nm:"reversed"},first:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,mt:"g",nm:"first"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"}},nm:"Reversed$ijs9g8"},Rest$fyp886:{super:{pk:".",nm:"Object"},mt:"c",sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"}],$m:{clone:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:3,mt:"m",nm:"clone"},iterator:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},measure:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"measure"},spanTo:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"spanTo"},spanFrom:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],nm:"spanFrom"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromFirst"},span:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"span"}},$at:{lastIndex:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:3,mt:"g",nm:"lastIndex"},from$8r4afz:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"from"}},ps:[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}],nm:"Rest$fyp886"},Indexes$1g59zu:{super:{pk:".",nm:"Object"},mt:"c",sts:[{tp:[{mt:"tp",pk:".",nm:"Integer"}],pk:".",nm:"List"}],$m:{clone:{$t:{tp:[{mt:"tp",pk:".",nm:"Integer"}],pk:".",nm:"List"},pa:3,mt:"m",nm:"clone"},iterator:{$t:{tp:[{mt:"tp",pk:".",nm:"Integer"}],pk:".",nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},measure:{$t:{tp:[{mt:"tp",pk:".",nm:"Integer"}],pk:".",nm:"List"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"measure"},spanTo:{$t:{tp:[{mt:"tp",pk:".",nm:"Integer"}],pk:".",nm:"List"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"spanTo"},spanFrom:{$t:{tp:[{mt:"tp",pk:".",nm:"Integer"}],pk:".",nm:"List"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],nm:"spanFrom"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromFirst"},span:{$t:{tp:[{mt:"tp",pk:".",nm:"Integer"}],pk:".",nm:"List"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"span"}},$at:{lastIndex:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:3,mt:"g",nm:"lastIndex"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"}},nm:"Indexes$1g59zu"},Patch$xht1ke:{super:{pk:".",nm:"Object"},mt:"c",sts:[{tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],pk:".",nm:"List"}],tp:[{nm:"Other"}],$m:{clone:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],pk:".",nm:"List"},pa:3,mt:"m",nm:"clone"},iterator:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],pk:".",nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"},{nm:"Other"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromFirst"}},$at:{lastIndex:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:3,mt:"g",nm:"lastIndex"},list$cbomfb:{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"List"},mt:"a",nm:"list"},length$x539u7:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"length"},from$8gxpyr:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"from"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"}},ps:[{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"List"},mt:"prm",nm:"list"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}],nm:"Patch$xht1ke"},Repeat$59m2x5:{super:{pk:".",nm:"Object"},mt:"c",sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"}],$m:{clone:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:3,mt:"m",nm:"clone"},iterator:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromFirst"}},$at:{lastIndex:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:3,mt:"g",nm:"lastIndex"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},times$219c9m:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"times"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"}},ps:[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"times"}],nm:"Repeat$59m2x5"}},$at:{lastIndex:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:5,mt:"a",an:{see:["List.size"],doc:["The index of the last element of the list, or `null` if \nthe list is empty."]},nm:"lastIndex"},last:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:11,mt:"g",an:{doc:["The last element of this `List`, if any."]},nm:"last"},hash:{$t:{pk:".",nm:"Integer"},pa:11,mt:"g",nm:"hash"},keys:{$t:{tp:[{mt:"tp",pk:".",nm:"Integer"}],pk:".",nm:"List"},pa:11,mt:"g",an:{doc:["A list containing all indexes of this list.\n\nThis is a lazy operation."]},nm:"keys"},reversed:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:9,mt:"g",an:{doc:["A list containing the elements of this list in reverse \norder to the order in which they occur in this list. \nFor every `index` of a reversed `list`:\n\n    list.reversed[index]==list[size-1-index]\n\nThis is a lazy operation returning a view of this list."]},nm:"reversed"},rest:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"List"},pa:11,mt:"g",an:{doc:["The rest of the list, without the first element.\n\nThis is a lazy operation returning a view of this list."]},nm:"rest"},first:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:11,mt:"g",an:{doc:["The first element of this `List`, if any."]},nm:"first"},size:{$t:{pk:".",nm:"Integer"},pa:11,mt:"g",an:{see:["List.lastIndex"],doc:["The number of elements in this list, always\n`list.lastIndex+1`."]},nm:"size"}},nm:"List"},AssertionError:{super:{pk:".",nm:"Throwable"},pa:65,mt:"c",an:{doc:["An error that occurs due to an incorrectly written program. \nAn instance is thrown when an assertion fails, that is, \nwhen a condition in an `assert` statement evaluates to \nfalse at runtime.\n\nThe assertion\n\n    \"x must be positive\"\n    assert (x>0);\n\nhas almost the same effect as this `if` statement\n    \n    if (!x>0) {\n        throw AssertionError(\"x must be positive\");\n    }"]},$at:{message$9g6fel:{$t:{pk:".",nm:"String"},mt:"a",an:{doc:["A message describing the assertion that failed. In the\ncase of an `assert` statement, it is the text specified\nby the `doc` annotation.\n\nCertain tools interpret this message as \nmarkdown-formatted text."]},nm:"message"}},ps:[{$t:{pk:".",nm:"String"},mt:"prm",an:{doc:["A message describing the assertion that failed. In the\ncase of an `assert` statement, it is the text specified\nby the `doc` annotation.\n\nCertain tools interpret this message as \nmarkdown-formatted text."]},$hdn:1,nm:"message"}],nm:"AssertionError"},Resource:{pa:1,mt:"i",an:{see:["Module.resourceByPath"],doc:["A file packaged within a module. A `Resource` may be \nobtained by calling [[Module.resourceByPath]], passing\na path that identifies the resource file.\n\nThe resource file itself must be placed in a _resource \ndirectory_ at compilation time, in a subdirectory \ncorresponding to the module to which the resource belongs.\nThe compiler is responsible for packaging the resource \nfile in a location accessible to the program at runtime:\n\n- In the case of a module compiled for execution on the \n  JVM, the resource file will be included in the `.car` \n  archive.\n- In the case of compilation to JavaScript, the resource\n  file will be copied to a `module-resources` directory\n  in the module repository.\n\nSuppose the following code occurs in a module named\n`com.redhat.example`:\n    \n    assert (exists resource \n       = `module`.resourceByPath(\"file.txt\"));\n    print(resource.textContent());\n\nThen the resource named `file.text` should be placed in \nthe subdirectory `com\/redhat\/example\/` of the resource \ndirectory.\n\nPaths with no leading `\/` are relative to the module's\nsubdirectory of the resource directory. Alternatively, a \nresource may be identified by a fully-qualified path \nbeginning with `\/`, for example:\n\n    assert (exists resource \n       = `module`.resourceByPath(\"\/com\/redhat\/example\/file.txt\"));\n    print(resource.textContent());"],by:["Enrique Zamudio"]},$m:{textContent:{$t:{pk:".",nm:"String"},pa:5,mt:"m",an:{doc:["Retrieves the contents of the resource as a [[String]],\nusing the specified encoding."]},ps:[[{$t:{pk:".",nm:"String"},def:1,mt:"prm",nm:"encoding"}]],nm:"textContent"}},$at:{string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},name:{$t:{pk:".",nm:"String"},pa:9,mt:"g",an:{doc:["The name of the resource; usually the filename."]},nm:"name"},uri:{$t:{pk:".",nm:"String"},pa:5,mt:"a",an:{doc:["The full path to the resource, expressed as a URI. For\na resource packaged within a module archive, this \nincludes both the path to the module archive file, and\nthe path of the resource within the module archive."]},nm:"uri"},size:{$t:{pk:".",nm:"Integer"},pa:5,mt:"a",an:{doc:["The size of the resource, in bytes."]},nm:"size"}},nm:"Resource"},equal:{super:{pk:".",nm:"Comparison"},pa:1,mt:"o",an:{doc:["The value is exactly equal to the given value."]},$at:{reversed:{$t:{pk:".",nm:"Comparison"},pa:3,mt:"g",nm:"reversed"}},nm:"equal"},finished:{super:{pk:".",nm:"Finished"},pa:1,mt:"o",an:{see:["Iterator"],doc:["A value that indicates that an [[Iterator]] is exhausted \nand has no more values to return."]},$at:{string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"}},nm:"finished"},Boolean:{super:{pk:".",nm:"Basic"},of:[{pk:".",nm:"true"},{pk:".",nm:"false"}],pa:257,mt:"c",an:{see:["parseBoolean"],doc:["A type capable of representing the values [[true]] and \n[[false]] of Boolean logic."],by:["Gavin"]},nm:"Boolean"},Basic:{super:{pk:".",nm:"Object"},pa:257,mt:"c",an:{doc:["The default superclass when no superclass is explicitly\nspecified using `extends`. For the sake of convenience, \nthis class inherits [[Identifiable]] along with its\n[[default definition|Identifiable.equals]] of value \nequality. Classes which aren't `Identifiable` should \ndirectly extend [[Object]]."],by:["Gavin"]},sts:[{pk:".",nm:"Identifiable"}],nm:"Basic"},DocAnnotation:{super:{pk:".",nm:"Basic"},pa:545,mt:"c",an:{doc:["The annotation class for the [[doc]] annotation."]},sts:[{tp:[{mt:"tp",pk:".",nm:"DocAnnotation"},{mt:"tp",pk:".",nm:"Annotated"},{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"OptionalAnnotation"}],$at:{description:{$t:{pk:".",nm:"String"},pa:1,mt:"a",an:{doc:["Documentation, in Markdown syntax, about the annotated \nprogram element"]},nm:"description"}},ps:[{$t:{pk:".",nm:"String"},pa:1,mt:"prm",an:{doc:["Documentation, in Markdown syntax, about the annotated \nprogram element"]},nm:"description"}],nm:"DocAnnotation"},Category:{pa:1,mt:"i",an:{doc:["Abstract supertype of objects that contain other values, \ncalled *elements*, where it is possible to efficiently \ndetermine if a given value is an element.\n\n`Category` models a mathematical set, but is distinct \nfrom the [[Set]] collection type.\n\nThe `in` operator may be used to determine if a value\nbelongs to a `Category`:\n\n    if (69 in 0..100) { ... }\n    assert (key->item in { for (n in 0..100) n.string->n**2 });\n\nAn object may be a `Category` of two different disjoint\nelement types. For example, [[String]] is a `Category`\nof its `Character`s and of its substrings.\n\n    if (\"hello\" in \"hello world\") { ... }\n    assert ('.' in string);\n\nEvery meaningful `Category` is formed from elements with\nsome equivalence relation. Ordinarily, that equivalence\nrelation is [[value equality|Object.equals]]. Thus,\nordinarily, `x==y` implies that `x in cat == y in cat`.\nBut this contract is not required since it is possible to \nform a meaningful `Category` using a different \nequivalence relation. For example, an `IdentitySet` is a \nmeaningful `Category`, where the equivalence relation is\n[[identity equality|Identifiable]].\n\nSince [[Null]] is not considered to have any meaningful\nequivalence relation, a `Category` may not contain the\n[[null value|null]].\n\nNote that even though `Category<Element>` is declared\ncontravariant in its [[element type|Element]], most types\nthat inherit `Category` are covariant in their element\ntype, and therefore satisfy `Category<Object>`, resulting\nin some loss of typesafety. For such types, [[contains]] \nshould return `false` for any value that is not an \ninstance of the element type. For example, `String` is a \n`Category<Object>`, not a `Category<Character|String>`,\nand `x in string` evaluates to `false` for every `x` that\nis not a `String` or `Character`."],by:["Gavin"]},tp:[{dv:"in",def:{pk:".",nm:"Object"},sts:[{pk:".",nm:"Object"}],nm:"Element"}],$m:{containsAny:{$t:{pk:".",nm:"Boolean"},pa:9,mt:"m",an:{see:["contains","containsEvery"],doc:["Returns `true` if any one of the given values belongs \nto this `Category`, or `false` otherwise."]},ps:[[{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"elements"}]],nm:"containsAny"},contains:{$t:{pk:".",nm:"Boolean"},pa:5,mt:"m",an:{see:["containsEvery","containsAny"],doc:["Returns `true` if the given value belongs to this\n`Category`, that is, if it is an element of this\n`Category`, or `false` otherwise.\n\nFor most `Category`s the following relationship is \nsatisfied by every pair of elements `x` and `y`:\n\n- if `x==y`, then `x in category == y in category`\n\nHowever, it is possible to form a useful `Category` \nconsistent with some other equivalence relation, for \nexample `===`. Therefore implementations of `contains()` \nwhich do not satisfy this relationship are tolerated."]},ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"contains"},containsEvery:{$t:{pk:".",nm:"Boolean"},pa:9,mt:"m",an:{see:["contains","containsAny"],doc:["Returns `true` if every one of the given values belongs \nto this `Category`, or `false` otherwise."]},ps:[[{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"elements"}]],nm:"containsEvery"}},nm:"Category"},see:{$t:{pk:".",nm:"SeeAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to specify references to other program elements\nrelated to the annotated API."]},ps:[[{$t:{tp:[{mt:"tp",pk:"ceylon.language.meta.declaration",nm:"Declaration"}],pk:".",nm:"Sequential"},mt:"prm",an:{doc:["The program elements being referred to."]},seq:1,nm:"programElements"}]],nm:"see"},actual:{$t:{pk:".",nm:"ActualAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to mark a member of a type as refining a member \nof a supertype."]},nm:"actual"},SharedAnnotation:{super:{pk:".",nm:"Basic"},pa:545,mt:"c",an:{doc:["The annotation class for the [[shared]] annotation."]},sts:[{tp:[{mt:"tp",pk:".",nm:"SharedAnnotation"},{comp:"u",mt:"tp",l:[{pk:"ceylon.language.meta.declaration",nm:"FunctionOrValueDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ClassOrInterfaceDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ConstructorDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"Package"},{pk:"ceylon.language.meta.declaration",nm:"Import"}]},{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"OptionalAnnotation"}],nm:"SharedAnnotation"},Integer:{super:{pk:".",nm:"Object"},pa:97,mt:"c",an:{see:["runtime.integerSize","parseInteger"],doc:["An exact representation of a positive whole number, \nnegative whole number, or zero. The largest and smallest \nrepresentable values are platform-dependent:\n\n- For the JVM runtime, integer values between\n  -2<sup>63<\/sup> and 2<sup>63<\/sup>-1 may be represented \n  without overflow.\n- For the JavaScript runtime, integer values with a\n  magnitude no greater than 2<sup>53<\/sup> may be\n  represented without loss of precision.\n\nOverflow or loss of precision occurs silently (with no \nexception raised).\n\nAn integer is considered equal to its [[float]] \nrepresentation. That is, for every integer `int`, the \nexpression `int.float==int` evaluates to `true`.\n\nAn integer is represented as a sequence of bits. Not all of \nthe bits in the representation may be addressed by the \nmethods inherited from [[Binary]]:\n\n- For the JVM runtime, the bits at all indices (0 to 63) \n  are addressable.\n- For the JavaScript runtime, the bits at indices 0 to 31 \n  are addressable.\n\nLiteral integers may be written in decimal, hexadecimal, or\nbinary notation:\n\n    8660\n    #21D4\n    $10000111010100\n\nUnderscores may be used to group digits:\n\n    8660\n    #21_D4\n    $10_0001_1101_0100"]},sts:[{tp:[{mt:"tp",pk:".",nm:"Integer"}],pk:".",nm:"Integral"},{tp:[{mt:"tp",pk:".",nm:"Integer"}],pk:".",nm:"Binary"},{tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",pk:".",nm:"Integer"}],pk:".",nm:"Exponentiable"}],$m:{offsetSign:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],nm:"offsetSign"},set:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",an:{doc:["If the `index` is for an addressable bit, an instance \nwith the same addressable bits as this instance, but \nwith that bit set to `bit`. Otherwise an instance with \nthe same addressable bits as this instance."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"},{$t:{pk:".",nm:"Boolean"},def:1,mt:"prm",nm:"bit"}]],nm:"set"},clear:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",an:{doc:["If the `index` is for an addressable bit, an instance \nwith the same addressable bits as this instance, but \nwith that bit cleared. Otherwise an instance with the \nsame addressable bits as this instance."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"clear"},remainder:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],nm:"remainder"},times:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],nm:"times"},rightArithmeticShift:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",an:{doc:["If shift is in the range of addressable bits \n(`0..runtime.integerAddressableSize-1`), shift the \naddressable bits to the right by `shift` positions, \nwith sign extension. Otherwise shift the addressable \nbits to the right by `(bits + (shift % bits)) % bits` \nwhere `bits=runtime.integerAddressableSize`."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"shift"}]],nm:"rightArithmeticShift"},power:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],nm:"power"},rightLogicalShift:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",an:{doc:["If shift is in the range of addressable bits \n(`0..runtime.integerAddressableSize-1`), shift the \naddressable bits to the right by `shift` positions, \nwith zero extension. Otherwise shift the addressable \nbits to the right by `(bits + (shift % bits)) % bits` \nwhere `bits=runtime.integerAddressableSize`."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"shift"}]],nm:"rightLogicalShift"},neighbour:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"offset"}]],nm:"neighbour"},offset:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],nm:"offset"},flip:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",an:{doc:["If the `index` is for an addressable bit, an instance \nwith the same addressable bits as this instance, but \nwith that bit flipped. Otherwise an instance with the \nsame addressable bits as this instance."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"flip"},notLargerThan:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],nm:"notLargerThan"},plus:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],nm:"plus"},largerThan:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],nm:"largerThan"},xor:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],nm:"xor"},minus:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],nm:"minus"},get:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",an:{doc:["If the `index` is for an addressable bit, the value of \nthat bit. Otherwise false."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"get"},equals:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",an:{doc:["Determines if the given object is equal to this `Integer`,\nthat is, if:\n\n- the given object is an `Integer` representing the \n  same whole number.\n\nOr if:\n\n- the given object is a [[Float]],\n- its value is neither [[Float.undefined]], nor [[infinity]],\n- the [[fractional part|Float.fractionalPart]] of its \n  value equals `0.0`, and\n- the [[integer part|Float.integer]] part of its value \n  equals this integer."]},ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],nm:"equals"},or:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],nm:"or"},compare:{$t:{pk:".",nm:"Comparison"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],nm:"compare"},divides:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],nm:"divides"},smallerThan:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],nm:"smallerThan"},and:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],nm:"and"},plusInteger:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"integer"}]],nm:"plusInteger"},notSmallerThan:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],nm:"notSmallerThan"},leftLogicalShift:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",an:{doc:["If shift is in the range of addressable bits \n(`0..runtime.integerAddressableSize-1`), shift the \naddressable bits to the left by `shift` positions.\nOtherwise shift the addressable bits to the left by \n`(bits + (shift % bits)) % bits` where \n`bits=runtime.integerAddressableSize`."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"shift"}]],nm:"leftLogicalShift"},powerOfInteger:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"integer"}]],nm:"powerOfInteger"},timesInteger:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"integer"}]],nm:"timesInteger"},divided:{$t:{pk:".",nm:"Integer"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"other"}]],nm:"divided"}},$at:{successor:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"successor"},hash:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"hash"},magnitude:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"magnitude"},zero:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"a",nm:"zero"},fractionalPart:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"fractionalPart"},float:{$t:{pk:".",nm:"Float"},pa:65,mt:"a",an:{throws:["OverflowException","if the number cannot be represented as a `Float`\nwithout loss of precision"],doc:["The number, represented as a [[Float]], if such a \nrepresentation is possible."]},nm:"float"},integer$woput0:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"integer"},character:{$t:{pk:".",nm:"Character"},pa:65,mt:"a",an:{throws:["OverflowException","if this integer is not in the range \n`0..#10FFFF` of legal Unicode code points"],doc:["The UTF-32 character with this UCS code point."]},nm:"character"},not:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"not"},predecessor:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"predecessor"},sign:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"sign"},unit:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"a",nm:"unit"},byte:{$t:{pk:".",nm:"Byte"},pa:65,mt:"a",an:{doc:["A [[Byte]] whose [[signed|Byte.signed]] and\n[[unsigned|Byte.unsigned]] interpretations are \ncongruent modulo 256 to this integer."]},nm:"byte"},string:{$t:{pk:".",nm:"String"},pa:67,mt:"a",nm:"string"},wholePart:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"wholePart"},even:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Determine if this integer is even.\n\nAn integer `i` is even if there exists an integer `k` \nsuch that:\n\n    i == 2*k\n\nThus, `i` is even if and only if `i%2 == 0`."]},nm:"even"},negative:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"a",nm:"negative"},positive:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"a",nm:"positive"},negated:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"negated"}},ps:[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"integer"}],nm:"Integer"},zeroInt:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"zeroInt"},Callable:{pa:65,mt:"i",an:{see:["Tuple"],doc:["A reference to a function. The type arguments encode the \n[[return type|Return]] of the function along with its \n[[parameter types|Arguments]]. The parameter types are \nrepresented by a tuple type. Functions declared `void`\nare considered to have the return type `Anything`.\n\nFor example, the type of the anonymous function\n`(Float x, Integer y) => x^y+1` is:\n\n    Callable<Float, [Float,Integer]>\n\nwhich we usually abbreviate to `Float(Float,Integer)`.\n\nLikewise, the type of the function reference `plus<Float>` \nto the function [[plus]] is:\n\n    Callable<Float, [Float,Float]>\n\nwhich we abbreviate as `Float(Float,Float)`.\n\nA variadic function is represented using an unterminated \ntuple type. For example, the type of the function reference\n`concatenate<Object>` to the function [[concatenate]] is:\n\n    Callable<Object[], [{Object*}*]>\n\nwhich we usually abbreviate `Object({Object*}*)`.\n\nA function with defaulted parameters is represented using\na union type. For example, the type of the method reference\n`process.writeLine` to the method [[process.writeLine]] is:\n\n    Callable<Anything, [String]|[]>\n\nwhich we usually abbreviate `Anything(String=)`.\n\nAny instance of `Callable` may be _invoked_ by supplying a \npositional argument list:\n\n    Float(Float,Float) add = plus<Float>;\n    value four = add(2.0, 2.0);\n\nor by supplying a tuple containing the arguments:\n\n    Float(Float,Float) add = plus<Float>;\n    [Float,Float] twoAndTwo = [2.0, 2.0];\n    value four = add(*twoAndTwo);\n\nThe type of the tuple must be assignable to the type \nargument of `Arguments`.\n\nThis interface may not be implemented by user code."]},tp:[{dv:"out",nm:"Return"},{dv:"in",sts:[{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"Sequential"}],nm:"Arguments"}],nm:"Callable"},Empty:{of:[{pk:".",nm:"empty"}],pa:1,mt:"i",an:{see:["Sequence"],doc:["A sequence with no elements. The type `Empty` may be\nabbreviated `[]`, and an instance is produced by the \nexpression `[]`. That is, in the following expression,\n`none` has type `[]` and refers to the value `[]`:\n\n    [] none = [];\n\n(Whether the syntax `[]` refers to the type or the value \ndepends upon how it occurs grammatically.)"]},sts:[{tp:[{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Sequential"},{tp:[{mt:"tp",pk:".",nm:"Integer"},{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Ranged"}],$m:{flatMap:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",tp:[{nm:"Result"},{sts:[{pk:".",nm:"Null"}],nm:"OtherAbsent"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Result"},{mt:"tp",nm:"OtherAbsent"}],pk:".",nm:"Iterable"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],nm:"collecting"}]],nm:"flatMap"},count:{$t:{pk:".",nm:"Integer"},pa:3,mt:"m",an:{doc:["Returns 0 for any given predicate."]},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"count"},contains:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",an:{doc:["Returns `false` for any given element."]},ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],nm:"contains"},by:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"step"}]],nm:"by"},every:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"every"},skip:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"skipping"}]],nm:"skip"},getFromLast:{$t:{pk:".",nm:"Null"},pa:3,mt:"m",an:{doc:["Returns `null` for any given index."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromLast"},terminal:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"terminal"},takeWhile:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"elem"}]],nm:"taking"}]],nm:"takeWhile"},initial:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"initial"},any:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"any"},spanFrom:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",an:{doc:["Returns an `Empty` for any given span."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],nm:"spanFrom"},follow:{$t:{tp:[{mt:"tp",nm:"Other"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Iterable"},pa:3,mt:"m",tp:[{nm:"Other"}],ps:[[{$t:{nm:"Other"},mt:"prm",nm:"head"}]],nm:"follow"},clone:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",an:{doc:["Returns an `Empty`."]},nm:"clone"},append:{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Sequential"},pa:3,mt:"m",tp:[{nm:"Other"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Sequential"},mt:"prm",nm:"elements"}]],nm:"append"},iterator:{$t:{tp:[{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Iterator"},pa:3,mt:"m",an:{doc:["Returns an iterator that is already exhausted."]},nm:"iterator"},select:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"select"},firstIndexWhere:{$t:{pk:".",nm:"Null"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"firstIndexWhere"},sublist:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"sublist"},defaultNullElements:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Default"}],ps:[[{$t:{nm:"Default"},mt:"prm",nm:"defaultValue"}]],nm:"defaultNullElements"},reduce:{$t:{pk:".",nm:"Null"},pa:3,mt:"m",tp:[{nm:"Result"}],ps:[[{$t:{nm:"Result"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Result"},mt:"prm",nm:"partial"},{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],nm:"accumulating"}]],nm:"reduce"},getFromFirst:{$t:{pk:".",nm:"Null"},pa:3,mt:"m",an:{doc:["Returns `null` for any given index."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromFirst"},defines:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",an:{doc:["Returns `false` for any given index."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"defines"},sublistTo:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"sublistTo"},each:{$t:{pk:".",nm:"Anything"},pa:3,mt:"m",$m:{step$522jkt:{$t:{pk:".",nm:"Anything"},mt:"m",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],nm:"step"}},ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],nm:"step"}]],nm:"each"},filter:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"filter"},collect:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",tp:[{nm:"Result"}],ps:[[{$t:{nm:"Result"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],nm:"collecting"}]],nm:"collect"},span:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",an:{doc:["Returns an `Empty` for any given span."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"span"},sort:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Comparison"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"a"},{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"b"}]],nm:"comparing"}]],nm:"sort"},measure:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",an:{doc:["Returns an `Empty` for any given measure."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"measure"},skipWhile:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"elem"}]],nm:"skipping"}]],nm:"skipWhile"},trimLeading:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"elem"}]],nm:"trimming"}]],nm:"trimLeading"},repeat:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",an:{doc:["Returns an `Empty`."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"times"}]],nm:"repeat"},includes:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"List"},mt:"prm",nm:"sublist"}]],nm:"includes"},withTrailing:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Other"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Other"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"},pa:3,mt:"m",tp:[{nm:"Other"}],ps:[[{$t:{nm:"Other"},mt:"prm",nm:"element"}]],nm:"withTrailing"},spanTo:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",an:{doc:["Returns an `Empty` for any given span."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"spanTo"},map:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",tp:[{nm:"Result"}],ps:[[{$t:{nm:"Result"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],nm:"collecting"}]],nm:"map"},trim:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"elem"}]],nm:"trimming"}]],nm:"trim"},find:{$t:{pk:".",nm:"Null"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"find"},sublistFrom:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],nm:"sublistFrom"},indexesWhere:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"indexesWhere"},prepend:{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Sequential"},pa:3,mt:"m",tp:[{nm:"Other"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Sequential"},mt:"prm",nm:"elements"}]],nm:"prepend"},fold:{$t:{nm:"Result"},pa:3,mt:"m",tp:[{nm:"Result"}],ps:[[{$t:{nm:"Result"},mt:"prm",nm:"initial"}],[{$t:{nm:"Result"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Result"},mt:"prm",nm:"partial"},{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],nm:"accumulating"}]],nm:"fold"},chain:{$t:{tp:[{mt:"tp",nm:"Other"},{mt:"tp",nm:"OtherAbsent"}],pk:".",nm:"Iterable"},pa:3,mt:"m",an:{doc:["Returns the given [[other]] iterable object."]},tp:[{nm:"Other"},{sts:[{pk:".",nm:"Null"}],nm:"OtherAbsent"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Other"},{mt:"tp",nm:"OtherAbsent"}],pk:".",nm:"Iterable"},mt:"prm",nm:"other"}]],nm:"chain"},trimTrailing:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"elem"}]],nm:"trimming"}]],nm:"trimTrailing"},sequence:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",an:{doc:["Returns an `Empty`."]},nm:"sequence"},take:{$t:{pk:".",nm:"Empty"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"taking"}]],nm:"take"},lastIndexWhere:{$t:{pk:".",nm:"Null"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"lastIndexWhere"},slice:{$t:{tp:[{comp:"u",mt:"tp",l:[{pk:".",nm:"Empty"},{comp:"u",l:[{pk:".",nm:"Empty"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",pk:".",nm:"Empty"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{pk:".",nm:"Empty"},{pk:".",nm:"Nothing"}]},{mt:"tp",pk:".",nm:"Empty"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}],pk:".",nm:"Tuple"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"slice"},spread:{$t:{tp:[{mt:"tp",pk:".",nm:"Empty"},{mt:"tp",nm:"Args"}],pk:".",nm:"Callable"},pa:3,mt:"m",tp:[{nm:"Result"},{sts:[{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"Sequential"}],nm:"Args"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Result"},{mt:"tp",nm:"Args"}],pk:".",nm:"Callable"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],nm:"method"}]],nm:"spread"},withLeading:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Other"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Other"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"},pa:3,mt:"m",tp:[{nm:"Other"}],ps:[[{$t:{nm:"Other"},mt:"prm",nm:"element"}]],nm:"withLeading"}},$at:{paired:{$t:{pk:".",nm:"Empty"},pa:3,mt:"g",an:{doc:["Returns an `Empty`."]},nm:"paired"},last:{$t:{pk:".",nm:"Null"},pa:3,mt:"g",an:{doc:["Returns `null`."]},nm:"last"},keys:{$t:{pk:".",nm:"Empty"},pa:3,mt:"g",an:{doc:["Returns an `Empty`."]},nm:"keys"},indexed:{$t:{pk:".",nm:"Empty"},pa:3,mt:"g",an:{doc:["Returns an `Empty`."]},nm:"indexed"},coalesced:{$t:{pk:".",nm:"Empty"},pa:3,mt:"g",an:{doc:["Returns an `Empty`."]},nm:"coalesced"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",an:{doc:["Returns 0."]},nm:"size"},lastIndex:{$t:{pk:".",nm:"Null"},pa:3,mt:"g",an:{doc:["Returns `null`."]},nm:"lastIndex"},cycled:{$t:{pk:".",nm:"Empty"},pa:3,mt:"g",an:{doc:["Returns an `Empty`."]},nm:"cycled"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",an:{doc:["Returns a string description of the empty sequence: \n`[]`."]},nm:"string"},empty:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"g",an:{doc:["Returns `true`."]},nm:"empty"},reversed:{$t:{pk:".",nm:"Empty"},pa:3,mt:"g",an:{doc:["Returns an `Empty`."]},nm:"reversed"},rest:{$t:{pk:".",nm:"Empty"},pa:3,mt:"g",an:{doc:["Returns an `Empty`."]},nm:"rest"},first:{$t:{pk:".",nm:"Null"},pa:3,mt:"g",an:{doc:["Returns `null`."]},nm:"first"}},nm:"Empty"},annotation:{$t:{pk:".",nm:"AnnotationAnnotation"},pa:513,mt:"m",an:{see:["Annotation"],doc:["Annotation to mark a class as an *annotation class*, or a \ntop-level function as an *annotation constructor*."]},nm:"annotation"},Enumerable:{of:[{nm:"Other"}],pa:1,mt:"i",an:{see:["Range","span","measure"],doc:["Abstraction of [[ordinal types|Ordinal]] whose values may \nbe used as endpoints of a [[span]] or [[measure]].\n\nAn `Enumerable` type is characterized by each element \nhaving well-defined [[offset]] and [[neighbour]] functions.\nGiven an instance `x` of an enumerable type `X`:\n\n- for any integer-valued offset, there is a unique \n  _neighbour_ `y` of `X` with that offset, and\n- if `y` is an instance of `X`, then there is a\n  well-defined integer-valued _offset_ of `x` from `y`.\n\nThe offset function must satisfy:\n\n- `x.offset(x) == 0`, and\n- `x.successor.offset(x) == 1` if `x!=x.successor`.\n\nThe neighbour function must satisfy:\n\n- `x.neighbour(0) == x`,\n- `x.neighbour(n-1) == x.neighbour(n).predecessor`, and\n- `x.neighbour(n+1) == x.neighbour(n).successor`.\n\nOf course, it follows that:\n\n- `x.neighbour(-1) == x.predecessor`, and\n- `x.neighbour(1) == x.successor`.\n\nAn enumerable type may be _linear_ or _recursive_. If `X` \nis a linear enumerable type, then the offset function \nsatisfies:\n\n- `x.predecessor.offset(x) == -1` if `x!=x.predecessor`,\n- `x.offset(y) == -y.offset(x)` for any instance `y` of `X`, \n  and\n- `x.offset(y) == x.offset(z) + z.offset(y)`.\n\nOtherwise, `X` is a recursive enumerable type with a finite\nlist of enumerated instances of size `count`, and its \noffset and neighbour functions must satisfy:\n\n- `x.neighbour(count)==x`,\n- `x.offset(y) >= 0` for any instance `y` of `X`, and \n- `x.predecessor.offset(x) == count - 1`.\n\nA range of values of an enumerable type may be specified \nusing:\n\n- the _span operator_, written `first..last`, or \n- the _segment operator_, written `first:length`."]},sts:[{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Ordinal"}],tp:[{sts:[{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Enumerable"}],nm:"Other"}],st:"Other",$m:{offsetSign:{$t:{pk:".",nm:"Integer"},pa:9,mt:"m",an:{doc:["The sign of the offset from the given value."]},ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],nm:"offsetSign"},offset:{$t:{pk:".",nm:"Integer"},pa:5,mt:"m",an:{throws:["OverflowException","if the offset cannot be represented as an \ninteger"],doc:["Compute the offset from the given value, where:\n\n- `x.offset(x) == 0`, and\n- `x.successor.offset(x) == 1` if `x!=x.successor`."]},ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],nm:"offset"},neighbour:{$t:{nm:"Other"},pa:5,mt:"m",an:{throws:["OverflowException","if the neighbour cannot be represented as an \ninstance of the type"],doc:["The indirect successor or predecessor at the given\n[[offset]], where:\n\n- `x.neighbour(0) == x`,\n- `x.neighbour(i+1) == x.neighbour(i).successor`, and\n- `x.neighbour(i-1) == x.neighbour(i).predecessor`."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"offset"}]],nm:"neighbour"}},$at:{predecessor:{$t:{nm:"Other"},pa:11,mt:"g",nm:"predecessor"},successor:{$t:{nm:"Other"},pa:11,mt:"g",nm:"successor"}},nm:"Enumerable"},empty:{super:{pk:".",nm:"Object"},pa:1,mt:"o",an:{doc:["A sequence with no elements, abbreviated `[]`. The unique \ninstance of the type `[]`."],by:["Tako Schotanus"]},sts:[{pk:".",nm:"Empty"}],nm:"empty"},false:{super:{pk:".",nm:"Boolean"},pa:65,mt:"o",an:{doc:["A value representing falsity in Boolean logic."]},$at:{string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"}},nm:"false"},digitOrSign:{$t:{tp:[{mt:"tp",pk:".",nm:"Boolean"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{pk:".",nm:"Character"},{pk:".",nm:"Nothing"}]},{mt:"tp",pk:".",nm:"Character"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}],pk:".",nm:"Callable"},mt:"a",nm:"digitOrSign"},final:{$t:{pk:".",nm:"FinalAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to mark a class as final. A `final` class may \nnot be extended. Marking a class as `final` affects disjoint\ntype analysis."]},nm:"final"},plus:{$t:{nm:"Value"},pa:1,mt:"m",an:{see:["times","sum"],doc:["Add the given [[Summable]] values.\n\n    (1..100).by(2).fold(0)(plus<Integer>)"]},tp:[{sts:[{tp:[{mt:"tp",nm:"Value"}],pk:".",nm:"Summable"}],nm:"Value"}],ps:[[{$t:{nm:"Value"},mt:"prm",nm:"x"},{$t:{nm:"Value"},mt:"prm",nm:"y"}]],nm:"plus"},Entry:{super:{pk:".",nm:"Object"},pa:33,mt:"c",an:{doc:["A pair containing a _key_ and an associated value called \nthe _item_. Used primarily to represent the elements of a \n[[Map]]. The type `Entry<Key,Item>` may be abbreviated \n`Key->Item`. An instance of `Entry` may be constructed \nusing the `->` operator:\n\n    String->Person entry = person.name->person;"],by:["Gavin"],serializable:[]},tp:[{dv:"out",sts:[{pk:".",nm:"Object"}],nm:"Key"},{dv:"out",nm:"Item"}],$m:{equals:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",an:{doc:["Determines if this entry is equal to the given entry. \nTwo entries are equal if they have the same key and \nthe same item. \n\n- The keys are considered the same if they are equal,\n  in the sense of [[value equality|Object.equals]].\n- Two items are considered the same if they are both \n  null or if neither is null and they are equal."]},ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],nm:"equals"}},$at:{hash:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"hash"},pair:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Key"},{comp:"u",l:[{nm:"Item"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"Key"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"Item"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Item"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}],pk:".",nm:"Tuple"},pa:1,mt:"g",an:{doc:["A pair (2 element tuple) with the key and item of this \nentry. For any `entry`:\n\n    entry.pair == [entry.key,entry.item]"]},nm:"pair"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",an:{doc:["A description of the entry in the form `key->item`. If \n[[item]] is `null`, its string representation is the \nstring `\"<null>\"`."]},nm:"string"},item:{$t:{nm:"Item"},pa:1,mt:"a",an:{doc:["The item associated with the key."]},nm:"item"},coalesced:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{tp:[{mt:"tp",nm:"Key"},{comp:"i",mt:"tp",l:[{nm:"Item"},{pk:".",nm:"Object"}]}],pk:".",nm:"Entry"}]},pa:1,mt:"g",an:{doc:["An `Entry` with the key and item of this entry if this \nentry's item is non-null, or `null` otherwise."]},nm:"coalesced"},key:{$t:{nm:"Key"},pa:1,mt:"a",an:{doc:["The key used to access the entry."]},nm:"key"}},ps:[{$t:{nm:"Key"},pa:1,mt:"prm",an:{doc:["The key used to access the entry."]},$hdn:1,nm:"key"},{$t:{nm:"Item"},pa:1,mt:"prm",an:{doc:["The item associated with the key."]},$hdn:1,nm:"item"}],nm:"Entry"},or:{$t:{pk:".",nm:"Boolean"},pa:1,mt:"m",an:{doc:["Returns a function which is the logical disjunction of the \ngiven predicate functions."]},tp:[{dv:"in",nm:"Value"}],ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Boolean"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Value"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}],pk:".",nm:"Callable"},mt:"prm",an:{doc:["The first predicate function"]},nm:"p"},{$t:{tp:[{mt:"tp",pk:".",nm:"Boolean"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Value"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}],pk:".",nm:"Callable"},mt:"prm",an:{doc:["The second predicate function"]},nm:"q"}],[{$t:{nm:"Value"},mt:"prm",nm:"val"}]],nm:"or"},largest:{$t:{nm:"Element"},pa:1,mt:"m",an:{see:["Comparable","smallest","max"],doc:["Given two [[Comparable]] values, return largest of the two."]},tp:[{sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Comparable"}],nm:"Element"}],ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],nm:"largest"},not:{$t:{pk:".",nm:"Boolean"},pa:1,mt:"m",an:{doc:["Returns a function which is the logical negation of the \ngiven predicate function."]},tp:[{dv:"in",nm:"Value"}],ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Boolean"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"Value"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Value"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}],pk:".",nm:"Callable"},mt:"prm",an:{doc:["The predicate function to negate"]},nm:"p"}],[{$t:{nm:"Value"},mt:"prm",nm:"val"}]],nm:"not"},aIntUpper:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"aIntUpper"},Destroyable:{pa:1,mt:"i",an:{see:["Obtainable"],doc:["Abstract supertype of resources which are created at the \nbeginning of a `try` statement and destroyed when the \nstatement completes. Unlike an [[Obtainable]] resource, a \nsingle instance of `Destroyable` may not be reused between \nmultiple `try` statements or multiple executions of the \nsame `try` statement. \n\n    try (tx = Transaction()) {\n        ...\n    }\n\n- The resource is instantiated before the body of the `try` \n  statement is executed, and\n- [[destroy]] is called when execution of the body of the \n  `try` statement ends, even if an exception propagates out \n  of the body of the `try`."]},sts:[{pk:".",nm:"Usable"}],$m:{destroy:{$t:{pk:".",nm:"Anything"},pa:5,mt:"m",an:{doc:["Destroy this resource. Called when execution of the \nbody of the `try` statement ends, even if an exception \npropagates out of the body of the `try`."]},ps:[[{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Throwable"}]},mt:"prm",an:{doc:["The exception propagating out of the body of the \n`try` statement, or `null` if no exception was\npropagated."]},nm:"error"}]],nm:"destroy"}},nm:"Destroyable"},language:{super:{pk:".",nm:"Basic"},pa:65,mt:"o",an:{see:["process","runtime","system","operatingSystem"],doc:["Contains information about the Ceylon language version."]},$at:{majorVersion:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{doc:["The Ceylon language major version."]},nm:"majorVersion"},majorVersionBinary:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{doc:["The major version of the code generated for the \nunderlying runtime."]},nm:"majorVersionBinary"},string:{$t:{pk:".",nm:"String"},pa:67,mt:"a",nm:"string"},minorVersion:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{doc:["The Ceylon language minor version."]},nm:"minorVersion"},versionName:{$t:{pk:".",nm:"String"},pa:65,mt:"a",an:{doc:["The Ceylon language release name."]},nm:"versionName"},releaseVersion:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{doc:["The Ceylon language release version."]},nm:"releaseVersion"},minorVersionBinary:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{doc:["The minor version of the code generated for the \nunderlying runtime."]},nm:"minorVersionBinary"},version:{$t:{pk:".",nm:"String"},pa:65,mt:"a",an:{doc:["The Ceylon language version."]},nm:"version"}},nm:"language"},emptySet:{super:{pk:".",nm:"Object"},pa:1,mt:"o",an:{doc:["An immutable [[Set]] with no elements."]},sts:[{tp:[{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Set"}],$m:{intersection:{$t:{tp:[{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Set"},pa:3,mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Other"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Set"},mt:"prm",nm:"set"}]],nm:"intersection"},clone:{$t:{tp:[{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Set"},pa:3,mt:"m",nm:"clone"},iterator:{$t:{tp:[{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},containsAny:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Object"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"elements"}]],nm:"containsAny"},superset:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Object"}],pk:".",nm:"Set"},mt:"prm",nm:"set"}]],nm:"superset"},count:{$t:{pk:".",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"count"},by:{$t:{tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"step"}]],nm:"by"},contains:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],nm:"contains"},skip:{$t:{tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"skipping"}]],nm:"skip"},every:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"every"},complement:{$t:{tp:[{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Set"},pa:3,mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Other"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Set"},mt:"prm",nm:"set"}]],nm:"complement"},subset:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Object"}],pk:".",nm:"Set"},mt:"prm",nm:"set"}]],nm:"subset"},exclusiveUnion:{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Set"},pa:3,mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Other"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Set"},mt:"prm",nm:"set"}]],nm:"exclusiveUnion"},take:{$t:{tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"taking"}]],nm:"take"},any:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"any"},union:{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Set"},pa:3,mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Other"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Set"},mt:"prm",nm:"set"}]],nm:"union"},each:{$t:{pk:".",nm:"Anything"},pa:3,mt:"m",$m:{step$b54ftw:{$t:{pk:".",nm:"Anything"},mt:"m",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],nm:"step"}},ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],nm:"step"}]],nm:"each"},findLast:{$t:{pk:".",nm:"Null"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"findLast"},find:{$t:{pk:".",nm:"Null"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"find"},containsEvery:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Object"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"elements"}]],nm:"containsEvery"}},$at:{empty:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"g",nm:"empty"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"}},nm:"emptySet"},SuppressWarningsAnnotation:{super:{pk:".",nm:"Basic"},pa:545,mt:"c",an:{doc:["The annotation class for the [[suppressWarnings]] \nannotation."]},sts:[{tp:[{mt:"tp",pk:".",nm:"SuppressWarningsAnnotation"},{comp:"u",mt:"tp",l:[{pk:"ceylon.language.meta.declaration",nm:"FunctionOrValueDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ClassOrInterfaceDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ConstructorDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"Module"},{pk:"ceylon.language.meta.declaration",nm:"Package"},{pk:"ceylon.language.meta.declaration",nm:"Import"}]},{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"OptionalAnnotation"}],$at:{warnings$ayjax6:{$t:{tp:[{mt:"tp",pk:".",nm:"String"}],pk:".",nm:"Sequential"},mt:"a",an:{doc:["The warning types to suppress."]},nm:"warnings"}},ps:[{$t:{tp:[{mt:"tp",pk:".",nm:"String"}],pk:".",nm:"Sequential"},mt:"prm",an:{doc:["The warning types to suppress."]},nm:"warnings"}],nm:"SuppressWarningsAnnotation"},stringify:{$t:{pk:".",nm:"String"},mt:"m",ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",nm:"val"}]],nm:"stringify"},Ranged:{of:[{nm:"Subrange"}],pa:1,mt:"i",an:{see:["List","Sequence","String"],doc:["Abstract supertype of _ranged streams_ mapping a range of \ndiscrete indices to elements of the stream, and supporting \noperations that produce a subrange of indexed elements. The \ntype parameter [[Subrange]] abstracts the type of the \nresulting subrange. A subrange may be obtained from an \ninstance of `Ranged` using the _span_ and _measure_ \noperators.\n\nOften, in a [[List]] or sorted map for example, an index\nand its element are distinct values. Sometimes, in a sorted \nset for example, the index and element are identical.\n\nThe _span_ operator accepts the first and last indices of \nthe subrange.\n\n    print(\"hello world\"[0..5]); \/\/prints \"hello\"\n    print(\"hello world\"[6..6]); \/\/prints \"w\"\n\nIf the last index is smaller than the first index, the\nsubrange is reversed.\n\n    print(\"hello world\"[5..0]); \/\/prints \"olleh\"\n\nIf the range of indices identified by the first and last\nindices is outside the range of indices of this object, an\nempty subrange is produced.\n\n    print(\"hello world\"[-5..-1]); \/\/prints \"\"\n    print(\"hello world\"[11..11]); \/\/prints \"\"\n\nThe first index may be omitted, implying that the subrange\nextends forward from the smallest possible index (in this\ncase `runtime.minIntegerValue-1`) to the given index.\n\n    print(\"hello world\"[...5]) \/\/prints \"hello\"\n\nIf the first index is before the first index of this object, \nan empty subrange is produced. (A reversed subrange is \nnever produced.)\n\n    print(\"hello world\"[-5...]); \/\/prints \"\"\n\nThe last index may be omitted, implying that the subrange \nextends forward from the given index to the largest \npossible index (in this case `runtime.maxIntegerValue+1`).\n\n    print(\"hello world\"[6...]) \/\/prints \"world\"\n\nIf the last index is after the last index of this object, \nan empty subrange is produced. (A reversed subrange is \nnever produced.)\n\n    print(\"hello world\"[11...]); \/\/prints \"\"\n\nThe _measure_ operator accepts the first index and maximum \nlength of the subrange.\n\n    print(\"hello world\"[6:5]) \/\/prints \"world\"\n    print(\"hello world\"[6:0]) \/\/prints \"\"\n\nIf the length is nonpositive, the subrange is empty. If the\nrange of indices identified by the first index and length\nis outside the range of indices of this object, an empty\nsubrange is produced. (A reversed subrange is never \nproduced.)\n\n    print(\"hello world\"[-3:3]) \/\/prints \"\"\n    print(\"hello world\"[11:3]) \/\/prints \"\"\n    print(\"hello world\"[6:-3]) \/\/prints \"\"\n\nThe span and measure operations must be consistent. That is, \nfor every pair of indices `x` and `y` in the ranged object \n`ranged` such that `y` does not occur before `x` and the \nspan `ranged[x..y]` has length `n`:\n\n- `ranged[x..y]==ranged[x:n]`."]},sts:[{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"}],tp:[{dv:"in",nm:"Index"},{dv:"out",nm:"Element"},{dv:"out",sts:[{tp:[{mt:"tp",nm:"Index"},{mt:"tp",nm:"Element"},{mt:"tp",nm:"Subrange"}],pk:".",nm:"Ranged"}],nm:"Subrange"}],st:"Subrange",$m:{measure:{$t:{nm:"Subrange"},pa:5,mt:"m",an:{doc:["Obtain a measure containing the mapped values starting \nfrom the given [[starting index|from]], with the given \n[[length]]. If `length<=0`, the resulting measure is \nempty.\n\nThe measure should contain the given [[number|length]] \nof elements of this stream, starting from the element \nat the given [[starting index|from]], in the same order \nas they are produced by the [[iterator]] of the stream. \nIn the case where the iterator would be exhausted \nbefore [[length]] elements are produced, the resulting \nmeasure contains only those elements which were \nproduced before the iterator was exhausted, and the \nlength of the measure is less then the given `length`.\n\nWhen the given index does not belong to this ranged \nobject, the behavior is implementation dependent."]},ps:[[{$t:{nm:"Index"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"measure"},spanTo:{$t:{nm:"Subrange"},pa:5,mt:"m",an:{doc:["Obtain a span containing the elements between the first \nindex of this ranged stream and given [[end index|to]].\n\nThe span should contain elements of this stream, up to \nthe element at the given [[ending index|to]], in the \nsame order as they are produced by the [[iterator]] of\nthe stream.\n\nWhen the given index does not belong to this ranged \nstream, the behavior is implementation dependent."]},ps:[[{$t:{nm:"Index"},mt:"prm",nm:"to"}]],nm:"spanTo"},spanFrom:{$t:{nm:"Subrange"},pa:5,mt:"m",an:{doc:["Obtain a span containing the elements between the given\n[[starting index|from]] and the last index of this \nranged object.\n\nThe span should contain elements of this stream, \nstarting from the element at the given [[starting \nindex|from]], in the same order as they are produced by \nthe [[iterator]] of the stream.\n\nWhen the given index does not belong to this ranged \nstream, the behavior is implementation dependent."]},ps:[[{$t:{nm:"Index"},mt:"prm",nm:"from"}]],nm:"spanFrom"},span:{$t:{nm:"Subrange"},pa:5,mt:"m",an:{doc:["Obtain a span containing the elements between the two \ngiven indices. \n\nThe span should contain elements of this stream, \nstarting from the element at the given [[starting \nindex|from]], and ending with the element at the given \n[[ending index|to]], in the same order as they are \nproduced by the [[iterator]] of the stream, except when \nthe ending index occurs earlier than the starting index, \nin which case they occur in the opposite order.\n\nWhen one or both of the given indices does not belong \nto this ranged stream, the behavior is implementation \ndependent."]},ps:[[{$t:{nm:"Index"},mt:"prm",nm:"from"},{$t:{nm:"Index"},mt:"prm",nm:"to"}]],nm:"span"}},nm:"Ranged"},identity:{$t:{nm:"Value"},pa:1,mt:"m",an:{doc:["The identity function that always returns its argument."]},tp:[{nm:"Value"}],ps:[[{$t:{nm:"Value"},mt:"prm",nm:"argument"}]],nm:"identity"},FormalAnnotation:{super:{pk:".",nm:"Basic"},pa:545,mt:"c",an:{doc:["The annotation class for the [[formal]] annotation."]},sts:[{tp:[{mt:"tp",pk:".",nm:"FormalAnnotation"},{comp:"u",mt:"tp",l:[{pk:"ceylon.language.meta.declaration",nm:"FunctionOrValueDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ClassOrInterfaceDeclaration"}]},{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"OptionalAnnotation"}],nm:"FormalAnnotation"},Span:{super:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Range"},pa:32,mt:"c",an:{see:["Measure","Enumerable"],doc:["A [[Range]] of adjacent [[Enumerable]] values generated by \ntwo endpoints: [[first]] and [[last]]. The range includes \nboth endpoints, and all values falling _between_ the \nendpoints."],by:["Gavin"],serializable:[]},tp:[{sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Enumerable"}],nm:"Element"}],$m:{iterator:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"},pa:3,mt:"m",an:{doc:["An iterator for the elements of the range. The returned \niterator produces elements from [[first]] and continues \nproducing elements until it reaches an element whose \n`offset` from [[last] is zero."]},nm:"iterator"},next$xciqj1:{$t:{nm:"Element"},mt:"m",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"}]],nm:"next"},measure:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"measure"},count:{$t:{pk:".",nm:"Integer"},pa:3,mt:"m",$m:{selecting$nzgblm:{$t:{pk:".",nm:"Boolean"},mt:"m",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"selecting"}},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"count"},equals:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],nm:"equals"},includesRange:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Range"},mt:"prm",nm:"range"}]],nm:"includesRange"},longerThan:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"longerThan"},by:{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Iterable"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"step"}]],nm:"by"},includes:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"List"},mt:"prm",nm:"sublist"}]],nm:"includes"},beforeFirst$3osfad:{$t:{pk:".",nm:"Boolean"},mt:"m",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"}]],nm:"beforeFirst"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,mt:"m",an:{doc:["The element of the range that occurs [[index]] values \nafter the start of the range."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromFirst"},shifted:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Range"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"shift"}]],nm:"shifted"},spanTo:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"spanTo"},shorterThan:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"shorterThan"},each:{$t:{pk:".",nm:"Anything"},pa:3,mt:"m",$m:{step$v5j5xq:{$t:{pk:".",nm:"Anything"},mt:"m",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"step"}},ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"step"}]],nm:"each"},beforeLast$sti0n5:{$t:{pk:".",nm:"Boolean"},mt:"m",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"}]],nm:"beforeLast"},afterFirst$upgk2i:{$t:{pk:".",nm:"Boolean"},mt:"m",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"}]],nm:"afterFirst"},containsElement:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"}]],nm:"containsElement"},spanFrom:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],nm:"spanFrom"},nextStep$sxlqah:{$t:{nm:"Element"},mt:"m",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"step"}]],nm:"nextStep"},fromFirst$otuqgo:{$t:{nm:"Element"},mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"offset"}]],nm:"fromFirst"},afterLast$dudvro:{$t:{pk:".",nm:"Boolean"},mt:"m",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"}]],nm:"afterLast"},span:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"span"}},$c:{By$ry6enl:{super:{pk:".",nm:"Basic"},mt:"c",sts:[{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Iterable"}],$m:{iterator:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"},pa:3,mt:"m",$c:{anon$2$s5n2ng:{super:{pk:".",nm:"Basic"},$anon:1,mt:"c",sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"}],nm:"anon$2$s5n2ng"},anon$1$m4vs6j:{super:{pk:".",nm:"Basic"},$anon:1,mt:"c",sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"}],nm:"anon$1$m4vs6j"}},$o:{$m:{next:{$t:{comp:"u",l:[{nm:"Element"},{pk:".",nm:"Finished"}]},pa:3,mt:"m",nm:"next"}},$at:{current$nxhyw:{$t:{comp:"u",l:[{nm:"Element"},{pk:".",nm:"Finished"}]},pa:1027,mt:"a",nm:"current"},firstTime$d2tu8c:{$t:{pk:".",nm:"Boolean"},pa:1027,mt:"a",nm:"firstTime"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},current$xkyyld:{$t:{nm:"Element"},pa:1027,mt:"a",nm:"current"},count$zhc9mv:{$t:{pk:".",nm:"Integer"},pa:1024,mt:"a",nm:"count"}}},nm:"iterator"}},$at:{step$axxwpk:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"step"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},first:{$t:{nm:"Element"},pa:3,mt:"g",nm:"first"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"}},ps:[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"step"}],nm:"By$ry6enl"}},$at:{lastIndex:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"lastIndex"},recursive$1gdd1o:{$t:{pk:".",nm:"Boolean"},mt:"a",an:{doc:["Determines if the range is of recursive values, that \nis, if successors wrap back on themselves. All \nrecursive ranges are [[increasing]]."]},nm:"recursive"},decreasing:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"g",nm:"decreasing"},last:{$t:{nm:"Element"},pa:3,mt:"a",an:{doc:["The end of the range."]},nm:"last"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},increasing:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"a",nm:"increasing"},reversed:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequence"},pa:3,mt:"g",an:{doc:["This range in reverse, with [[first]] and [[last]]\ninterchanged.\n\nFor any two range endpoints, `x` and `y`: \n\n    `(x..y).reversed == y..x`\n\nexcept for [[recursive]] ranges, where the elements are\nevaluated and collected into a new sequence."]},nm:"reversed"},rest:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"g",nm:"rest"},first:{$t:{nm:"Element"},pa:3,mt:"a",an:{doc:["The start of the range."]},nm:"first"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"}},ps:[{$t:{nm:"Element"},pa:3,mt:"prm",an:{doc:["The start of the range."]},$hdn:1,nm:"first"},{$t:{nm:"Element"},pa:3,mt:"prm",an:{doc:["The end of the range."]},$hdn:1,nm:"last"}],nm:"Span"},LicenseAnnotation:{super:{pk:".",nm:"Basic"},pa:545,mt:"c",an:{doc:["The annotation class for the [[license]] annotation."]},sts:[{tp:[{mt:"tp",pk:".",nm:"LicenseAnnotation"},{mt:"tp",pk:"ceylon.language.meta.declaration",nm:"Module"},{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"OptionalAnnotation"}],$at:{description:{$t:{pk:".",nm:"String"},pa:1,mt:"a",an:{doc:["The name, text, or URL of the license."]},nm:"description"}},ps:[{$t:{pk:".",nm:"String"},pa:1,mt:"prm",an:{doc:["The name, text, or URL of the license."]},nm:"description"}],nm:"LicenseAnnotation"},null:{super:{pk:".",nm:"Null"},pa:1,mt:"o",an:{doc:["The null value."],by:["Gavin"]},nm:"null"},Object:{super:{pk:".",nm:"Anything"},pa:257,mt:"c",an:{see:["Basic","Null"],doc:["The abstract supertype of all types representing definite \nvalues. Any two values which are assignable to `Object` \nmay be compared for value equality using the `==` and `!=` \noperators, even if the values are of different concrete \ntype:\n\n    true == false\n    1 == \"hello world\"\n    \"hello\"+\" \"+\"world\" == \"hello world\"\n    Singleton(\"hello world\") == [\"hello world\"]\n\nHowever, since [[Null]] is not a subtype of `Object`, the\nvalue [[null]] cannot be compared to any other value \nusing the `==` operator. Thus, value equality is not \ndefined for optional types. This neatly bypasses the \nproblem of deciding the value of the expression \n`null==null`, which is simply illegal.\n\nA concrete subclass of `Object` must refine [[equals]] \nand [[hash]] (or inherit concrete refinements), providing \na concrete definition of value equality for the class.\n\nIn extreme cases it is acceptable for two values to be\nequal even when they are not instances of the same class.\nFor example, the [[Integer]] value `1` and the [[Float]]\nvalue `1.0` are considered equal. Except in these extreme\ncases, instances of different classes are considered\nunequal."],by:["Gavin"]},$m:{equals:{$t:{pk:".",nm:"Boolean"},pa:5,mt:"m",an:{doc:["Determine if two values are equal. Implementations\nshould respect the constraints that:\n\n- if `x===y` then `x==y` (reflexivity), \n- if `x==y` then `y==x` (symmetry), \n- if `x==y` and `y==z` then `x==z` (transitivity).\n\nFurthermore it is recommended that implementations\nensure that if `x==y` then `x` and `y` have the same \nconcrete class.\n\nA class which explicitly refines `equals()` is said to \nsupport _value equality_, and the equality operator \n`==` is considered much more meaningful for such \nclasses than for a class which simply inherits the\ndefault implementation of _identity equality_ from\n[[Identifiable]]."]},ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],nm:"equals"}},$at:{hash:{$t:{pk:".",nm:"Integer"},pa:5,mt:"a",an:{doc:["The hash value of the value, which allows the value to \nbe an element of a hash-based set or key of a\nhash-based map. Implementations must respect the\nconstraint that:\n\n- if `x==y` then `x.hash==y.hash`.\n\nTherefore, a class which refines [[equals]] must also\nrefine `hash`.\n\nBecause the [[Integer]] type is platform-dependent \na compiler for a given platform is permitted to\nfurther manipulate the calculated hash for an object,\nand the resulting hash may differ between platforms."]},nm:"hash"},string:{$t:{pk:".",nm:"String"},pa:9,mt:"g",an:{doc:["A developer-friendly string representing the instance. \nConcatenates the name of the concrete class of the \ninstance with the `hash` of the instance. Subclasses \nare encouraged to refine this implementation to produce \na more meaningful representation."]},nm:"string"}},nm:"Object"},Float:{super:{pk:".",nm:"Object"},pa:97,mt:"c",an:{see:["parseFloat"],doc:["An IEEE 754 64-bit [floating point number][]. A `Float` is \ncapable of approximately representing numeric values \nbetween:\n\n- 2<sup>-1022<\/sup>, approximately \n  1.7976910<sup>308<\/sup>, and \n- (2-2<sup>-52<\/sup>)2<sup>1023<\/sup>, \n  approximately 510<sup>-324<\/sup>.\n\nZero is represented by distinct instances `+0.0`, `-0.0`, \nbut these instances are equal.\n\nIn addition, the following special values exist:\n\n- [[infinity]] and `-infinity`, and\n- undefined values.\n\nAs required by the IEEE standard, an undefined value, often\ndenoted [NaN][], is not equal to any other value, nor even\nto itself. Thus, the definition of [[equals]] for `Float`\nviolates the general contract defined by [[Object.equals]].\n\nA floating point value with a zero [[fractionalPart]] is\nconsidered equal to its [[integer]] part.\n\nLiteral floating point values are written with a decimal\npoint and, optionally, a magnitude or exponent:\n\n    1.0\n    1.0E6\n    1.0M\n    1.0E-6\n    1.0u\n\nIn the case of a fractional magnitude, the decimal point is\noptional. Underscores may be used to group digits into \ngroups of three.\n\n[floating point number]: http:\/\/www.validlab.com\/goldberg\/paper.pdf\n[NaN]: http:\/\/en.wikipedia.org\/wiki\/NaN"]},sts:[{tp:[{mt:"tp",pk:".",nm:"Float"}],pk:".",nm:"Number"},{tp:[{mt:"tp",pk:".",nm:"Float"},{mt:"tp",pk:".",nm:"Float"}],pk:".",nm:"Exponentiable"}],$m:{notLargerThan:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Float"},mt:"prm",nm:"other"}]],nm:"notLargerThan"},plus:{$t:{pk:".",nm:"Float"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Float"},mt:"prm",nm:"other"}]],nm:"plus"},largerThan:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Float"},mt:"prm",nm:"other"}]],nm:"largerThan"},minus:{$t:{pk:".",nm:"Float"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Float"},mt:"prm",nm:"other"}]],nm:"minus"},equals:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",an:{doc:["Determines if the given object is equal to this `Float`,\nthat is, if:\n\n- the given object is also a `Float`,\n- neither this value nor the given value is \n  [[undefined]], and either\n- both values are [[infinite]] and have the same \n  [[sign]], or both represent the same finite floating \n  point value as defined by the IEEE specification.\n\nOr if:\n\n- the given object is an [[Integer]],\n- this value is neither [[undefined]], nor [[infinite]],\n- the [[fractionalPart]] of this value equals `0.0`, \n  and\n- the [[integer]] part of this value equals the given \n  integer."]},ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],nm:"equals"},compare:{$t:{pk:".",nm:"Comparison"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Float"},mt:"prm",nm:"other"}]],nm:"compare"},smallerThan:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Float"},mt:"prm",nm:"other"}]],nm:"smallerThan"},plusInteger:{$t:{pk:".",nm:"Float"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"integer"}]],nm:"plusInteger"},notSmallerThan:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Float"},mt:"prm",nm:"other"}]],nm:"notSmallerThan"},times:{$t:{pk:".",nm:"Float"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Float"},mt:"prm",nm:"other"}]],nm:"times"},powerOfInteger:{$t:{pk:".",nm:"Float"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"integer"}]],nm:"powerOfInteger"},timesInteger:{$t:{pk:".",nm:"Float"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"integer"}]],nm:"timesInteger"},power:{$t:{pk:".",nm:"Float"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Float"},mt:"prm",nm:"other"}]],nm:"power"},divided:{$t:{pk:".",nm:"Float"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Float"},mt:"prm",nm:"other"}]],nm:"divided"}},$at:{integer:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{throws:["OverflowException","if the the [[wholePart]] of this value is too large \nor too small to be represented as an `Integer`"],doc:["This value, represented as an [[Integer]], after \ntruncation of its fractional part, if such a \nrepresentation is possible."]},nm:"integer"},hash:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"hash"},magnitude:{$t:{pk:".",nm:"Float"},pa:67,mt:"a",nm:"magnitude"},strictlyPositive:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Determines if this value is a positive number, `+0.0`, \nor `infinity`. Produces `false` for a negative number, \n`-0.0`, or undefined."]},nm:"strictlyPositive"},fractionalPart:{$t:{pk:".",nm:"Float"},pa:67,mt:"a",nm:"fractionalPart"},finite:{$t:{pk:".",nm:"Boolean"},pa:1,mt:"g",an:{see:["infinite","infinity"],doc:["Determines whether this value is finite. Produces\n`false` for `infinity`, `-infinity`, and undefined."]},nm:"finite"},sign:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",an:{doc:["The sign of this value. Produces `1` for a positive \nnumber or `infinity`. Produces `-1` for a negative\nnumber or `-infinity`. Produces `0.0` for `+0.0`, \n`-0.0`, or undefined."]},nm:"sign"},strictlyNegative:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"a",an:{doc:["Determines if this value is a negative number, `-0.0`, \nor `-infinity`. Produces `false` for a positive number, \n`+0.0`, or undefined."]},nm:"strictlyNegative"},infinite:{$t:{pk:".",nm:"Boolean"},pa:1,mt:"g",an:{see:["infinity","finite"],doc:["Determines whether this value is infinite in magnitude. \nProduces `true` for `infinity` and `-infinity`. \nProduces `false` for a finite number, `+0.0`, `-0.0`, \nor undefined."]},nm:"infinite"},undefined:{$t:{pk:".",nm:"Boolean"},pa:1,mt:"g",an:{doc:["Determines whether this value is undefined (that is, \nNot a Number or NaN). The undefined value has the \nproperty that it is not equal (`==`) to itself, and as \na consequence the undefined value cannot sensibly be \nused in most collections."]},nm:"undefined"},string:{$t:{pk:".",nm:"String"},pa:67,mt:"a",nm:"string"},float$oirx2o:{$t:{pk:".",nm:"Float"},mt:"a",nm:"float"},wholePart:{$t:{pk:".",nm:"Float"},pa:67,mt:"a",nm:"wholePart"},negative:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"a",an:{doc:["Determines if this value is a negative number or\n`-infinity`. Produces `false` for a positive number, \n`+0.0`, `-0.0`, or undefined."]},nm:"negative"},positive:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"a",an:{doc:["Determines if this value is a positive number or\n`infinity`. Produces `false` for a negative number, \n`+0.0`, `-0.0`, or undefined."]},nm:"positive"},negated:{$t:{pk:".",nm:"Float"},pa:67,mt:"a",nm:"negated"}},ps:[{$t:{pk:".",nm:"Float"},mt:"prm",nm:"float"}],nm:"Float"},min:{$t:{comp:"u",l:[{nm:"Absent"},{nm:"Value"}]},pa:1,mt:"m",an:{see:["Comparable","max","smallest"],doc:["Given a stream of [[Comparable]] values, return the \nsmallest value in the stream, or `null` if the stream is\nempty.\n\nFor any nonempty stream `it`, `min(it)` evaluates to the \nfirst element of `it` such that for every element `e` of \n`it`, `min(it) <= e`."]},tp:[{sts:[{tp:[{mt:"tp",nm:"Value"}],pk:".",nm:"Comparable"}],nm:"Value"},{sts:[{pk:".",nm:"Null"}],nm:"Absent"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Value"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},mt:"prm",nm:"values"}]],nm:"min"},Collection:{pa:1,mt:"i",an:{see:["List","Map","Set"],doc:["Represents an iterable collection of elements of finite \nsize, with a well-defined notion of value equality. \n`Collection` is the abstract supertype of [[List]], \n[[Map]], and [[Set]].\n\nA `Collection` forms a [[Category]] of its elements, and \nis [[Iterable]]. The elements of a collection are not\nnecessarily distinct when compared using [[Object.equals]].\n\nA `Collection` may be [[cloned|clone]]. If a collection is\nimmutable, it is acceptable that `clone()` produce a\nreference to the collection itself. If a collection is\nmutable, `clone()` should produce a collection containing \nreferences to the same elements, with the same structure as \nthe original collection&mdash;that is, it should produce a \nshallow copy of the collection.\n\nAll `Collection`s are required to support a well-defined\nnotion of [[value equality|Object.equals]], but the\ndefinition of equality depends upon the kind of collection.\nEquality for `Map`s and `Set`s has a quite different\ndefinition to equality for `List`s."]},sts:[{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"}],tp:[{dv:"out",def:{pk:".",nm:"Anything"},nm:"Element"}],$m:{clone:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Collection"},pa:5,mt:"m",an:{doc:["A shallow copy of this collection, that is, a \ncollection with identical elements which does not\nchange if this collection changes. If this collection\nis immutable, it is acceptable to return a reference to\nthis collection. If this collection is mutable, a newly\ninstantiated collection must be returned."]},nm:"clone"},contains:{$t:{pk:".",nm:"Boolean"},pa:11,mt:"m",an:{doc:["Return `true` if the given object is an element of\nthis collection. In this default implementation, and in \nmost refining implementations, return `false` \notherwise. An acceptable refining implementation may \nreturn `true` for objects which are not elements of the \ncollection, but this is not recommended. (For example, \nthe `contains()` method of `String` returns `true` for \nany substring of the string.)"]},ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],nm:"contains"}},$at:{string:{$t:{pk:".",nm:"String"},pa:11,mt:"g",an:{doc:["A string of form `\"{ x, y, z }\"` where `x`, `y`, and \n`z` are the `string` representations of the elements of \nthis collection, as produced by the iterator of the \ncollection, or the string `\"{}\"` if this collection \nis empty. If the collection iterator produces the value \n`null`, the string representation contains the string \n`\"<null>\"`."]},nm:"string"},empty:{$t:{pk:".",nm:"Boolean"},pa:11,mt:"g",an:{doc:["Determine if the collection is empty, that is, if it \nhas no elements."]},nm:"empty"}},nm:"Collection"},larger:{super:{pk:".",nm:"Comparison"},pa:1,mt:"o",an:{doc:["The value is larger than the given value."]},$at:{reversed:{$t:{pk:".",nm:"Comparison"},pa:3,mt:"g",nm:"reversed"}},nm:"larger"},byIncreasing:{$t:{pk:".",nm:"Comparison"},pa:1,mt:"m",an:{see:["byDecreasing","increasing","Iterable.max","Iterable.sort"],doc:["Produces a comparator function which orders elements in \nincreasing order according to the [[Comparable]] value \nreturned by the given [[comparable]] function.\n\n     \"Hello World!\".sort(byIncreasing(Character.lowercased))\n\nThis function is intended for use with [[Iterable.sort]]\nand [[Iterable.max]]."]},tp:[{nm:"Element"},{sts:[{tp:[{mt:"tp",nm:"Value"}],pk:".",nm:"Comparable"}],nm:"Value"}],ps:[[{$t:{nm:"Value"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"e"}]],nm:"comparable"}],[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],nm:"byIncreasing"},NativeAnnotation:{super:{pk:".",nm:"Basic"},pa:545,mt:"c",an:{doc:["The annotation class for the [[native]] annotation."]},sts:[{tp:[{mt:"tp",pk:".",nm:"NativeAnnotation"},{mt:"tp",pk:".",nm:"Annotated"},{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"OptionalAnnotation"}],$at:{backend:{$t:{pk:".",nm:"String"},pa:1,mt:"a",nm:"backend"}},ps:[{$t:{pk:".",nm:"String"},pa:1,mt:"prm",nm:"backend"}],nm:"NativeAnnotation"},smallest:{$t:{nm:"Element"},pa:1,mt:"m",an:{see:["Comparable","largest","min"],doc:["Given two [[Comparable]] values, return smallest of the two."]},tp:[{sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Comparable"}],nm:"Element"}],ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],nm:"smallest"},true:{super:{pk:".",nm:"Boolean"},pa:65,mt:"o",an:{doc:["A value representing truth in Boolean logic."]},$at:{string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"}},nm:"true"},Exponentiable:{of:[{nm:"This"}],pa:1,mt:"i",an:{see:["Integer","Float"],doc:["Abstraction of [[numeric types|Numeric]] that may be raised \nto a power using the _exponentiation_ operator ^.\n\n    function exp(Float x) => e^x;\n\nThe exponentiation operation should obey the usual index\nlaws, including:\n\n- `x^0 = 1`,\n- `x^1 = x`,\n- `x^(-1) = 1\/x` \n- `x^(m+n) = x^m * x^n`\n- `x^(m-n) = x^m \/ x^n`\n- `x^(m*n) = (x^m)^n`\n- `(x*y)^n = x^n * y^n`\n\nwhere `0` is the additive identity, and `1` is the \nmultiplicative identity.\n\nNote that in general, the type of the exponent may be \ndifferent to the numeric type which is exponentiated. For\nexample, a `Rational` number class might be a subtype of\n`Exponentiable<Rational,Integer>`, thus accepting only\nwhole-number exponents."]},sts:[{tp:[{mt:"tp",nm:"This"}],pk:".",nm:"Numeric"}],tp:[{sts:[{tp:[{mt:"tp",nm:"This"},{mt:"tp",nm:"Other"}],pk:".",nm:"Exponentiable"}],nm:"This"},{sts:[{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Numeric"}],nm:"Other"}],st:"This",$m:{power:{$t:{nm:"This"},pa:5,mt:"m",an:{doc:["The result of raising this number to the given power."]},ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],nm:"power"}},nm:"Exponentiable"},curry:{$t:{tp:[{mt:"tp",nm:"Return"},{mt:"tp",nm:"Rest"}],pk:".",nm:"Callable"},pa:1,mt:"m",an:{see:["uncurry","compose"],doc:["Curries a function, returning a function with two parameter \nlists, given a function with at least one parameter. The \nfirst parameter list of the returned function has just the \nfirst parameter of the original function, and the second \nparameter list has the remaining parameters.\n\nThat is, if `fun` has type `W(X,Y,Z)` then \n`curry(fun)` has type `W(Y,Z)(X)`."]},tp:[{nm:"Return"},{nm:"Argument"},{sts:[{nm:"Argument"}],nm:"First"},{sts:[{tp:[{mt:"tp",nm:"Argument"}],pk:".",nm:"Sequential"}],nm:"Rest"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Return"},{mt:"tp",tp:[{mt:"tp",nm:"Argument"},{mt:"tp",nm:"First"},{mt:"tp",nm:"Rest"}],pk:".",nm:"Tuple"}],pk:".",nm:"Callable"},mt:"prm",nm:"f"}],[{$t:{nm:"First"},mt:"prm",nm:"first"}]],nm:"curry"},forKey:{$t:{nm:"Result"},pa:1,mt:"m",an:{see:["forItem"],doc:["A function that returns the result of applying the given \n[[function|resulting]] to the [[key|Entry.key]] of\na given [[Entry]], discarding its `item`.\n    \n    Map<String,List<Item>> map = ... ;\n    {String*} uppercaseKeys = map.map(forKey(String.uppercased));"]},tp:[{sts:[{pk:".",nm:"Object"}],nm:"Key"},{nm:"Result"}],ps:[[{$t:{nm:"Result"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Key"},mt:"prm",nm:"key"}]],nm:"resulting"}],[{$t:{tp:[{mt:"tp",nm:"Key"},{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"Entry"},mt:"prm",nm:"entry"}]],nm:"forKey"},process:{super:{pk:".",nm:"Basic"},pa:65,mt:"o",an:{see:["language","runtime","system","operatingSystem"],doc:["Represents the current process (instance of the virtual\nmachine)."],by:["Gavin","Tako"]},$m:{flushError:{$t:{pk:".",nm:"Anything"},pa:65,mt:"m",an:{doc:["Flush the standard error of the \nvirtual machine process."]},nm:"flushError"},environmentVariableValue:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"String"}]},pa:65,mt:"m",an:{doc:["The value of the given environment variable defined \nfor the current virtual machine process."]},ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"name"}]],nm:"environmentVariableValue"},flush:{$t:{pk:".",nm:"Anything"},pa:65,mt:"m",an:{doc:["Flush the standard output of the virtual machine \nprocess."]},nm:"flush"},readLine:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"String"}]},pa:65,mt:"m",an:{doc:["Read a line of input text from the standard input of \nthe virtual machine process. Returns a line of text \nafter removal of line-termination characters, or `null`\nto indicate the standard input has been closed."]},nm:"readLine"},writeErrorLine:{$t:{pk:".",nm:"Anything"},pa:1,mt:"m",an:{doc:["Print a line to the standard error of the virtual \nmachine process."]},ps:[[{$t:{pk:".",nm:"String"},def:1,mt:"prm",nm:"line"}]],nm:"writeErrorLine"},writeError:{$t:{pk:".",nm:"Anything"},pa:65,mt:"m",an:{doc:["Print a string to the standard error of the virtual \nmachine process."]},ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"string"}]],nm:"writeError"},propertyValue:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"String"}]},pa:65,mt:"m",an:{doc:["The value of the given system property of the virtual\nmachine, if any."]},ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"name"}]],nm:"propertyValue"},namedArgumentValue:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"String"}]},pa:65,mt:"m",an:{doc:["The value of the first argument of form `-name=value`, \n`--name=value`, or `-name value` specified among the \ncommand line arguments to the virtual machine, if\nany."]},ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"name"}]],nm:"namedArgumentValue"},write:{$t:{pk:".",nm:"Anything"},pa:65,mt:"m",an:{doc:["Print a string to the standard output of the virtual\nmachine process."]},ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"string"}]],nm:"write"},namedArgumentPresent:{$t:{pk:".",nm:"Boolean"},pa:65,mt:"m",an:{doc:["Determine if an argument of form `-name` or `--name` \nwas specified among the command line arguments to \nthe virtual machine."]},ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"name"}]],nm:"namedArgumentPresent"},writeLine:{$t:{pk:".",nm:"Anything"},pa:1,mt:"m",an:{see:["print"],doc:["Print a line to the standard output of the virtual \nmachine process."]},ps:[[{$t:{pk:".",nm:"String"},def:1,mt:"prm",nm:"line"}]],nm:"writeLine"},exit:{$t:{pk:".",nm:"Anything"},pa:65,mt:"m",an:{doc:["Force the virtual machine to terminate with the given\nexit code."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"code"}]],nm:"exit"}},$at:{arguments:{$t:{tp:[{mt:"tp",pk:".",nm:"String"}],pk:".",nm:"Sequential"},pa:65,mt:"a",an:{doc:["The command line arguments to the virtual machine."]},nm:"arguments"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"}},nm:"process"},product:{$t:{nm:"Value"},pa:1,mt:"m",an:{see:["sum"],doc:["Given a nonempty stream of [[Numeric]] values, return the \nproduct of the values."]},tp:[{sts:[{tp:[{mt:"tp",nm:"Value"}],pk:".",nm:"Numeric"}],nm:"Value"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Value"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Iterable"},mt:"prm",nm:"values"}]],nm:"product"},shuffle:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Result"},{mt:"tp",nm:"FirstArgs"}],pk:".",nm:"Callable"},{mt:"tp",nm:"SecondArgs"}],pk:".",nm:"Callable"},pa:1,mt:"m",an:{see:["curry"],doc:["Given a function with two parameter lists, return a \nfunction with the order of the argument lists reversed. The \nparameter lists may have any number of parameters.\n\nThat is, if `fun` has type `W(A,B)(X,Y,Z)` then \n`shuffle(fun)` has type `W(X,Y,Z)(A,B)`.\n\nThis function is often used in conjunction with `curry()`."]},tp:[{nm:"Result"},{sts:[{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"Sequential"}],nm:"FirstArgs"},{sts:[{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"Sequential"}],nm:"SecondArgs"}],ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Result"},{mt:"tp",nm:"SecondArgs"}],pk:".",nm:"Callable"},{mt:"tp",nm:"FirstArgs"}],pk:".",nm:"Callable"},mt:"prm",nm:"f"}]],nm:"shuffle"},emptyMap:{super:{pk:".",nm:"Object"},pa:1,mt:"o",an:{doc:["An immutable [[Map]] with no entries."]},sts:[{tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Map"}],$m:{clone:{$t:{tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Map"},pa:3,mt:"m",nm:"clone"},iterator:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Entry"}],pk:".",nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},containsAny:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Object"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"elements"}]],nm:"containsAny"},get:{$t:{pk:".",nm:"Null"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"key"}]],nm:"get"},count:{$t:{pk:".",nm:"Integer"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Entry"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"count"},by:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Entry"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"step"}]],nm:"by"},contains:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"element"}]],nm:"contains"},skip:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Entry"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"skipping"}]],nm:"skip"},mapItems:{$t:{tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Map"},pa:3,mt:"m",tp:[{sts:[{pk:".",nm:"Object"}],nm:"Result"}],ps:[[{$t:{nm:"Result"},mt:"prm",$pt:"f",ps:[[{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"key"},{$t:{pk:".",nm:"Nothing"},mt:"prm",nm:"item"}]],nm:"mapping"}]],nm:"mapItems"},every:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Entry"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"every"},defines:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"index"}]],nm:"defines"},take:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Entry"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"taking"}]],nm:"take"},any:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Entry"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"any"},each:{$t:{pk:".",nm:"Anything"},pa:3,mt:"m",$m:{step$t2ndu6:{$t:{pk:".",nm:"Anything"},mt:"m",ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Entry"},mt:"prm",nm:"element"}]],nm:"step"}},ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",$pt:"f",ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Entry"},mt:"prm",nm:"element"}]],nm:"step"}]],nm:"each"},findLast:{$t:{pk:".",nm:"Null"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Entry"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"findLast"},find:{$t:{pk:".",nm:"Null"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",$pt:"f",ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Nothing"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Entry"},mt:"prm",nm:"element"}]],nm:"selecting"}]],nm:"find"},containsEvery:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Object"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"elements"}]],nm:"containsEvery"}},$at:{items:{$t:{tp:[{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Collection"},pa:3,mt:"g",nm:"items"},keys:{$t:{tp:[{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Collection"},pa:3,mt:"g",nm:"keys"},empty:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"g",nm:"empty"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"}},nm:"emptyMap"},tagged:{$t:{pk:".",nm:"TagsAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to categorize an API by tag."]},ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"String"}],pk:".",nm:"Sequential"},mt:"prm",an:{doc:["The tags, in plain text."]},seq:1,nm:"tags"}]],nm:"tagged"},apply:{$t:{nm:"Return"},pa:1,mt:"m",an:{see:["unflatten"],doc:["Applies an arbitrary [[Callable]] to the given \n[[arguments|args]]. The arguments must be packaged into a \n[[Tuple]] whose type is compatible with the `Callable` type. \n\nFor example, given the following argument tuple:\n\n     [Boolean(Character), Boolean, Boolean] tuple\n         = [Character.whitespace, true, false];\n\nWe can apply [[String.split]] to the arguments given in\n`tuple` as follows:\n\n    String string = ... ;\n    {String*} strings = apply(string.split, tuple);\n\nApplication may be abbreviated using the spread operator:\n\n    String string = ... ;\n    {String*} strings = string.split(*tuple)\n\nIn practice, this behaves as if the `Callable` were called \nwith the elements of the tuple as its arguments. The\nexamples above are both equivalent to:\n\n    string.split(Character.whitespace, true, false)"]},tp:[{nm:"Return"},{sts:[{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"Sequential"}],nm:"Args"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Return"},{mt:"tp",nm:"Args"}],pk:".",nm:"Callable"},mt:"prm",nm:"f"},{$t:{nm:"Args"},mt:"prm",nm:"args"}]],nm:"apply"},count:{$t:{pk:".",nm:"Integer"},pa:1,mt:"m",an:{see:["Iterable.count"],doc:["A count of the number of `true` items in the given values.\n\n    Integer negatives = count { for (x in xs) x<0.0 };"]},ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Boolean"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"values"}]],nm:"count"},byItem:{$t:{pk:".",nm:"Comparison"},pa:1,mt:"m",an:{see:["byKey"],doc:["A comparator for [[Entry]]s which compares their items \naccording to the given [[comparing]] function.\n\n    value sortedEntries = map.sort(byItem(byIncreasing(String.lowercased)));\n\nThis function is intended for use with [[Iterable.sort]]\nand [[Iterable.max]]."]},tp:[{sts:[{pk:".",nm:"Object"}],nm:"Item"}],ps:[[{$t:{pk:".",nm:"Comparison"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Item"},mt:"prm",nm:"x"},{$t:{nm:"Item"},mt:"prm",nm:"y"}]],nm:"comparing"}],[{$t:{tp:[{mt:"tp",pk:".",nm:"Object"},{mt:"tp",nm:"Item"}],pk:".",nm:"Entry"},mt:"prm",nm:"x"},{$t:{tp:[{mt:"tp",pk:".",nm:"Object"},{mt:"tp",nm:"Item"}],pk:".",nm:"Entry"},mt:"prm",nm:"y"}]],nm:"byItem"},FinalAnnotation:{super:{pk:".",nm:"Basic"},pa:545,mt:"c",an:{doc:["The annotation class for the [[final]] annotation."]},sts:[{tp:[{mt:"tp",pk:".",nm:"FinalAnnotation"},{mt:"tp",pk:"ceylon.language.meta.declaration",nm:"ClassDeclaration"},{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"OptionalAnnotation"}],nm:"FinalAnnotation"},every:{$t:{pk:".",nm:"Boolean"},pa:1,mt:"m",an:{see:["any","Iterable.every"],doc:["Determines if every one of the given boolean values \n(usually a comprehension) is `true`.\n\n    Boolean allPositive = every { for (x in xs) x>0.0 };\n\nIf there are no boolean values, return `true`."]},ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Boolean"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"values"}]],nm:"every"},Measure:{super:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Range"},pa:32,mt:"c",an:{see:["Span","Enumerable"],doc:["A [[Range]] of adjacent [[Enumerable]] values generated by \na [[first]] element, and a strictly positive [[size]]. The \nrange includes all values whose offset from `first` is \nnon-negative and less than the `size`."],serializable:[]},tp:[{sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Enumerable"}],nm:"Element"}],$m:{iterator:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},measure:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"measure"},equals:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],nm:"equals"},includesRange:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Range"},mt:"prm",nm:"range"}]],nm:"includesRange"},longerThan:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"longerThan"},by:{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Iterable"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"step"}]],nm:"by"},includes:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"List"},mt:"prm",nm:"sublist"}]],nm:"includes"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Element"}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromFirst"},shifted:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Range"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"shift"}]],nm:"shifted"},spanTo:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"spanTo"},shorterThan:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"shorterThan"},each:{$t:{pk:".",nm:"Anything"},pa:3,mt:"m",$m:{step$dxyy5i:{$t:{pk:".",nm:"Anything"},mt:"m",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"step"}},ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"element"}]],nm:"step"}]],nm:"each"},containsElement:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"x"}]],nm:"containsElement"},spanFrom:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"}]],nm:"spanFrom"},span:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"from"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"to"}]],nm:"span"}},$c:{By$d85sth:{super:{pk:".",nm:"Basic"},mt:"c",sts:[{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Iterable"}],$m:{iterator:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Iterator"},pa:3,mt:"m",nm:"iterator"}},$at:{step$ezo16c:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"step"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},first:{$t:{nm:"Element"},pa:3,mt:"g",nm:"first"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"}},ps:[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"step"}],nm:"By$d85sth"}},$at:{lastIndex:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"lastIndex"},decreasing:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"g",nm:"decreasing"},last:{$t:{nm:"Element"},pa:3,mt:"g",nm:"last"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},increasing:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"g",nm:"increasing"},rest:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:3,mt:"g",nm:"rest"},first:{$t:{nm:"Element"},pa:3,mt:"a",an:{doc:["The start of the range."]},nm:"first"},size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"a",an:{doc:["The size of the range."]},nm:"size"}},ps:[{$t:{nm:"Element"},pa:3,mt:"prm",an:{doc:["The start of the range."]},$hdn:1,nm:"first"},{$t:{pk:".",nm:"Integer"},pa:3,mt:"prm",an:{doc:["The size of the range."]},$hdn:1,nm:"size"}],nm:"Measure"},concatenate:{$t:{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"},pa:1,mt:"m",an:{see:["expand","Iterable.chain","Sequential.append"],doc:["Given zero or more argument [[streams|iterables]], return a \nnew sequence containing all elements of every given stream.\nThe elements of the resulting stream are ordered first \naccording to the stream in which they occur, and then \naccording to where they occur in that stream. If there are \nno arguments, or if none of the argument streams contain \nany elements, return the empty sequence.\n\nFor example, the expression\n\n    concatenate(1..3, [0.0], {\"hello\", \"world\"})\n\nresults in the sequence `[1, 2, 3, 0.0, \"hello\", \"world\"]`\nwhich has the type `[Integer|Float|String*]`."]},tp:[{nm:"Element"}],ps:[[{$t:{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"}],pk:".",nm:"Sequential"},mt:"prm",an:{doc:["The streams to concatenate."]},seq:1,nm:"iterables"}]],nm:"concatenate"},SealedAnnotation:{super:{pk:".",nm:"Basic"},pa:545,mt:"c",an:{doc:["The annotation class for the [[sealed]] annotation."]},sts:[{tp:[{mt:"tp",pk:".",nm:"SealedAnnotation"},{comp:"u",mt:"tp",l:[{pk:"ceylon.language.meta.declaration",nm:"ClassOrInterfaceDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"ConstructorDeclaration"}]},{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"OptionalAnnotation"}],nm:"SealedAnnotation"},identityHash:{$t:{pk:".",nm:"Integer"},pa:65,mt:"m",an:{see:["identical"],doc:["Return the system-defined identity hash value of the given \n[[value|identifiable]]. This hash value is consistent with \n[[identity equality|Identifiable.equals]]."]},ps:[[{$t:{pk:".",nm:"Identifiable"},mt:"prm",nm:"identifiable"}]],nm:"identityHash"},maxRadix:{$t:{pk:".",nm:"Integer"},mt:"a",nm:"maxRadix"},uncurry:{$t:{tp:[{mt:"tp",nm:"Return"},{mt:"tp",tp:[{mt:"tp",nm:"Argument"},{mt:"tp",nm:"First"},{mt:"tp",nm:"Rest"}],pk:".",nm:"Tuple"}],pk:".",nm:"Callable"},pa:1,mt:"m",an:{see:["curry","compose"],doc:["Uncurries a function, returning a function with one \nparameter list, given a function with two parameter lists, \nwhere the first parameter list has exactly one parameter. \nThe parameter list of the returned function has the \nparameter of the first parameter list of the original\nfunction, followed by all parameters of the second \nparameter list.\n\nThat is, if `fun` has type `W(Y,Z)(X)` then `uncurry(fun)` \nhas type `W(X,Y,Z)`."]},tp:[{nm:"Return"},{nm:"Argument"},{sts:[{nm:"Argument"}],nm:"First"},{sts:[{tp:[{mt:"tp",nm:"Argument"}],pk:".",nm:"Sequential"}],nm:"Rest"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Return"},{mt:"tp",nm:"Rest"}],pk:".",nm:"Callable"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"First"},mt:"prm",nm:"first"}]],nm:"f"}]],nm:"uncurry"},Summable:{of:[{nm:"Other"}],pa:1,mt:"i",an:{see:["String","Numeric"],doc:["Abstraction of types which support a binary addition\noperator `x + y`. For [[numeric types|Numeric]], this is\njust familiar numeric addition. For [[String]], it is\nstring concatenation.\n\n    Integer next = current + 1;\n    String helloWorld = \"hello\" + \" \" + \"world\";\n\nA concrete class that implements this interface should be \na mathematical _semigroup_. That is, the addition \noperation should be associative, satisfying:\n\n- `(x+y)+z == x+(y+z)`\n\nA `Summable` type might be a _monoid_, that is, a \nsemigroup with an additive identity element, usually \ndenoted `0`, but this is not required. For example:\n\n- `String` is a monoid with identity element `\"\"`, \n- `Float` is a monoid with identity element `0.0`, and \n- `Integer` is a monoid with identity element `0`.\n\nFor any monoid, the addition operation must satisfy:\n\n- `x + 0 == x`"],by:["Gavin"]},tp:[{sts:[{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Summable"}],nm:"Other"}],st:"Other",$m:{plus:{$t:{nm:"Other"},pa:5,mt:"m",an:{doc:["The result of adding the given value to this value. \nThis operation should never perform any kind of \nmutation upon either the receiving value or the \nargument value."]},ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],nm:"plus"}},nm:"Summable"},StringBuilder:{super:{pk:".",nm:"Basic"},pa:97,mt:"c",an:{doc:["Builder utility for constructing [[strings|String]] by \nincrementally appending strings or characters.\n\n    value builder = StringBuilder();\n    builder.append(\"hello\");\n    builder.appendCharacter(' ');\n    builder.append(\"world\");\n    String hello = builder.string; \/\/hello world"]},sts:[{tp:[{mt:"tp",pk:".",nm:"Character"}],pk:".",nm:"List"}],$m:{append:{$t:{pk:".",nm:"StringBuilder"},pa:65,mt:"m",an:{doc:["Append the characters in the given [[string]]."]},ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"string"}]],nm:"append"},iterator:{$t:{tp:[{mt:"tp",pk:".",nm:"Character"}],pk:".",nm:"Iterator"},pa:67,mt:"m",nm:"iterator"},equals:{$t:{pk:".",nm:"Boolean"},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],nm:"equals"},appendSpace:{$t:{pk:".",nm:"StringBuilder"},pa:65,mt:"m",an:{doc:["Append a space character."]},nm:"appendSpace"},deleteInitial:{$t:{pk:".",nm:"StringBuilder"},pa:65,mt:"m",an:{doc:["Deletes the specified [[number of characters|length]] \nfrom the start of the string. If `length` is \nnonpositive, nothing is deleted."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"deleteInitial"},prepend:{$t:{pk:".",nm:"StringBuilder"},pa:65,mt:"m",an:{doc:["Prepend the characters in the given [[string]]."]},ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"string"}]],nm:"prepend"},prependCharacter:{$t:{pk:".",nm:"StringBuilder"},pa:65,mt:"m",an:{doc:["Prepend the given [[character]]."]},ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"character"}]],nm:"prependCharacter"},appendAll:{$t:{pk:".",nm:"StringBuilder"},pa:65,mt:"m",an:{doc:["Append the characters in the given [[strings]]."]},ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"String"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"strings"}]],nm:"appendAll"},appendNewline:{$t:{pk:".",nm:"StringBuilder"},pa:65,mt:"m",an:{doc:["Append a newline character."]},nm:"appendNewline"},getFromFirst:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Character"}]},pa:67,mt:"m",ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"}]],nm:"getFromFirst"},appendCharacter:{$t:{pk:".",nm:"StringBuilder"},pa:65,mt:"m",an:{doc:["Append the given [[character]]."]},ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"character"}]],nm:"appendCharacter"},reverseInPlace:{$t:{pk:".",nm:"StringBuilder"},pa:65,mt:"m",an:{doc:["Reverses the order of the current characters."]},nm:"reverseInPlace"},replace:{$t:{pk:".",nm:"StringBuilder"},pa:65,mt:"m",an:{doc:["Replaces the specified [[number of characters|length]] \nfrom the current content, starting at the specified \n[[index]], with the given [[string]]. If `length` is \nnonpositive, nothing is replaced."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"},{$t:{pk:".",nm:"String"},mt:"prm",nm:"string"}]],nm:"replace"},clear:{$t:{pk:".",nm:"StringBuilder"},pa:65,mt:"m",an:{doc:["Remove all content and return to initial state."]},nm:"clear"},prependAll:{$t:{pk:".",nm:"StringBuilder"},pa:65,mt:"m",an:{doc:["Prepend the characters in the given [[strings]]."]},ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"String"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"strings"}]],nm:"prependAll"},substring:{$t:{pk:".",nm:"String"},pa:65,mt:"m",an:{doc:["Returns a string of the given [[length]] containing\nthe characters beginning at the given [[index]]."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"substring"},delete:{$t:{pk:".",nm:"StringBuilder"},pa:65,mt:"m",an:{doc:["Deletes the specified [[number of characters|length]] \nfrom the current content, starting at the specified \n[[index]]. If `length` is nonpositive, nothing is \ndeleted."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"},{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"delete"},insertCharacter:{$t:{pk:".",nm:"StringBuilder"},pa:65,mt:"m",an:{doc:["Insert a [[character]] at the specified [[index]]."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"},{$t:{pk:".",nm:"Character"},mt:"prm",nm:"character"}]],nm:"insertCharacter"},insert:{$t:{pk:".",nm:"StringBuilder"},pa:65,mt:"m",an:{doc:["Insert a [[string]] at the specified [[index]]."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"index"},{$t:{pk:".",nm:"String"},mt:"prm",nm:"string"}]],nm:"insert"},deleteTerminal:{$t:{pk:".",nm:"StringBuilder"},pa:65,mt:"m",an:{doc:["Deletes the specified [[number of characters|length]] \nfrom the end of the string. If `length` is nonpositive, \nnothing is deleted."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"length"}]],nm:"deleteTerminal"}},$at:{lastIndex:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},pa:67,mt:"a",nm:"lastIndex"},hash:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",nm:"hash"},string:{$t:{pk:".",nm:"String"},pa:67,mt:"a",an:{doc:["The resulting string. If no characters have been\nappended, the empty string."]},nm:"string"},size:{$t:{pk:".",nm:"Integer"},pa:67,mt:"a",an:{doc:["The number characters in the current content, that is, \nthe [[size|String.size]] of the produced [[string]]."]},nm:"size"}},nm:"StringBuilder"},TagsAnnotation:{super:{pk:".",nm:"Basic"},pa:545,mt:"c",an:{doc:["The annotation class for the [[tagged]] annotation."]},sts:[{tp:[{mt:"tp",pk:".",nm:"TagsAnnotation"},{mt:"tp",pk:".",nm:"Annotated"},{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"OptionalAnnotation"}],$at:{tags:{$t:{tp:[{mt:"tp",pk:".",nm:"String"}],pk:".",nm:"Sequential"},pa:1,mt:"a",an:{doc:["The tags, in plain text."]},nm:"tags"}},ps:[{$t:{tp:[{mt:"tp",pk:".",nm:"String"}],pk:".",nm:"Sequential"},pa:1,mt:"prm",an:{doc:["The tags, in plain text."]},seq:1,nm:"tags"}],nm:"TagsAnnotation"},commaList:{$t:{pk:".",nm:"String"},mt:"m",ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Anything"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"elements"}]],nm:"commaList"},Map:{pa:1,mt:"i",an:{see:["Entry","forKey","forItem","byItem","byKey"],doc:["Represents a collection which maps _keys_ to _items_,\nwhere a key can map to at most one item. Each such \nmapping may be represented by an [[Entry]].\n\nA `Map` is a [[Collection]] of its `Entry`s, and a \n[[Correspondence]] from keys to items.\n\nThe presence of an entry in a map may be tested using the \n`in` operator:\n\n    if (\"lang\"->\"en_AU\" in settings) { ... }\n\nThe entries of the map may be iterated using `for`:\n\n    for (key->item in settings) { ... }\n\nThe item for a key may be obtained using the item\noperator:\n\n    String lang = settings[\"lang\"] else \"en_US\";\n\nKeys are compared for equality using [[Object.equals]] or\n[[Comparable.compare]]. There may be at most one entry \nper key."]},sts:[{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"Item"}],pk:".",nm:"Entry"}],pk:".",nm:"Collection"},{tp:[{mt:"tp",pk:".",nm:"Object"},{mt:"tp",nm:"Item"}],pk:".",nm:"Correspondence"}],tp:[{dv:"out",def:{pk:".",nm:"Object"},sts:[{pk:".",nm:"Object"}],nm:"Key"},{dv:"out",def:{pk:".",nm:"Anything"},nm:"Item"}],$m:{clone:{$t:{tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"Item"}],pk:".",nm:"Map"},pa:7,mt:"m",an:{doc:["A shallow copy of this map, that is, a map with the\nsame entries as this map, which do not change if the\nentries in this map change."]},nm:"clone"},defines:{$t:{pk:".",nm:"Boolean"},pa:7,mt:"m",an:{see:["contains"],doc:["Determines if there is an entry in this map with the\ngiven [[key]]."]},ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"key"}]],nm:"defines"},get:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{nm:"Item"}]},pa:7,mt:"m",an:{doc:["Returns the item of the entry with the given [[key]], \nor `null` if there is no entry with the given `key` in\nthis map."]},ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"key"}]],nm:"get"},equals:{$t:{pk:".",nm:"Boolean"},pa:11,mt:"m",an:{doc:["Two maps are considered equal iff they have the same \n_entry sets_. The entry set of a `Map` is the set of \n`Entry`s belonging to the map. Therefore, the maps are \nequal iff they have same set of `keys`, and for every \nkey in the key set, the maps have equal items."]},ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"that"}]],nm:"equals"},contains:{$t:{pk:".",nm:"Boolean"},pa:11,mt:"m",an:{see:["defines"],doc:["Determines if the given [[value|entry]] is an [[Entry]]\nbelonging to this map."]},ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"entry"}]],nm:"contains"},mapItems:{$t:{tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"Result"}],pk:".",nm:"Map"},pa:9,mt:"m",an:{doc:["Produces a map with the same [[keys]] as this map. \nFor every key, the item is the result of applying the \ngiven [[transformation|Map.mapItems.mapping]] function \nto its associated item in this map. This is a lazy \noperation, returning a view of this map."]},tp:[{sts:[{pk:".",nm:"Object"}],nm:"Result"}],ps:[[{$t:{nm:"Result"},mt:"prm",an:{doc:["The function that transforms a key\/item pair of\nthis map, producing the item of the resulting map."]},$pt:"f",ps:[[{$t:{nm:"Key"},mt:"prm",nm:"key"},{$t:{nm:"Item"},mt:"prm",nm:"item"}]],nm:"mapping"}]],nm:"mapItems"},filterKeys:{$t:{tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"Item"}],pk:".",nm:"Map"},pa:9,mt:"m",an:{doc:["Produces a map by applying a [[filtering]] function \nto the [[keys]] of this map. This is a lazy operation, \nreturning a view of this map."]},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The predicate function that filters the keys of \nthis map, determining if there is a corresponding\nentry in the resulting map."]},$pt:"f",ps:[[{$t:{nm:"Key"},mt:"prm",nm:"key"}]],nm:"filtering"}]],nm:"filterKeys"},patch:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Key"},{nm:"OtherKey"}]},{comp:"u",mt:"tp",l:[{nm:"Item"},{nm:"OtherItem"}]}],pk:".",nm:"Map"},pa:9,mt:"m",an:{doc:["Produces a map whose keys are the union of the keys\nof this map, with the keys of the given [[map|other]].\nFor any given key in the resulting map, its associated\nitem is the item associated with the key in the given\nmap, if any, or the item associated with the key in \nthis map otherwise.\n\nThat is, for any `key` in the resulting patched map:\n\n    map.patch(other)[key] == other[key] else map[key]\n\nThis is a lazy operation producing a view of this map\nand the given map."]},tp:[{sts:[{pk:".",nm:"Object"}],nm:"OtherKey"},{sts:[{pk:".",nm:"Object"}],nm:"OtherItem"}],ps:[[{$t:{tp:[{mt:"tp",nm:"OtherKey"},{mt:"tp",nm:"OtherItem"}],pk:".",nm:"Map"},mt:"prm",nm:"other"}]],nm:"patch"}},$c:{anon$1$owsv86:{super:{pk:".",nm:"Basic"},$anon:1,mt:"c",sts:[{tp:[{mt:"tp",nm:"Item"}],pk:".",nm:"Collection"}],nm:"anon$1$owsv86"},anon$5$owszga:{super:{pk:".",nm:"Object"},$anon:1,mt:"c",sts:[{tp:[{mt:"tp",nm:"Key"},{comp:"i",mt:"tp",l:[{nm:"Item"},{pk:".",nm:"Object"}]}],pk:".",nm:"Map"}],nm:"anon$5$owszga"},anon$0$owsu65:{super:{pk:".",nm:"Basic"},$anon:1,mt:"c",sts:[{tp:[{mt:"tp",nm:"Key"}],pk:".",nm:"Collection"}],nm:"anon$0$owsu65"}},$at:{hash:{$t:{pk:".",nm:"Integer"},pa:11,mt:"g",nm:"hash"},items:{$t:{tp:[{mt:"tp",nm:"Item"}],pk:".",nm:"Collection"},pa:9,mt:"g",an:{doc:["A [[Collection]] containing the items stored in this \nmap. An element can be stored under more than one key \nin the map, and so it can occur more than once in the \nresulting collection."]},nm:"items"},keys:{$t:{tp:[{mt:"tp",nm:"Key"}],pk:".",nm:"Collection"},pa:11,mt:"g",an:{doc:["A [[Collection]] containing the keys of this map."]},nm:"keys"},coalescedMap:{$t:{tp:[{mt:"tp",nm:"Key"},{comp:"i",mt:"tp",l:[{nm:"Item"},{pk:".",nm:"Object"}]}],pk:".",nm:"Map"},pa:9,mt:"g",an:{doc:["A map with every entry of this map whose item is\nnon-null."]},nm:"coalescedMap"}},$o:{$m:{clone:{$t:{tp:[{mt:"tp",nm:"Key"},{comp:"i",mt:"tp",l:[{nm:"Item"},{pk:".",nm:"Object"}]}],pk:".",nm:"Map"},pa:3,mt:"m",nm:"clone"},iterator:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Key"},{comp:"i",mt:"tp",l:[{nm:"Item"},{pk:".",nm:"Object"}]}],pk:".",nm:"Entry"}],pk:".",nm:"Iterator"},pa:3,mt:"m",nm:"iterator"},defines:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"key"}]],nm:"defines"},get:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{comp:"i",l:[{nm:"Item"},{pk:".",nm:"Object"}]}]},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"key"}]],nm:"get"},contains:{$t:{pk:".",nm:"Boolean"},pa:3,mt:"m",ps:[[{$t:{pk:".",nm:"Object"},mt:"prm",nm:"item"}]],nm:"contains"}},$at:{size:{$t:{pk:".",nm:"Integer"},pa:3,mt:"g",nm:"size"}}},nm:"Map"},Number:{of:[{nm:"Other"}],pa:1,mt:"i",an:{see:["Integer","Float"],doc:["Abstraction of [[numeric|Numeric]] types with a natural \n[[total order|Comparable]], including the built-in numeric \ntypes [[Integer]] and [[Float]].\n\nA `Number` has a well-defined [[magnitude]] together with a \n[[sign]] of type [[Integer]], defined for any instance `x`\nas follows:\n\n- if `x==0` then `x.sign==0` and `x.magnitude==0`,\n- if `x>0` then `x.sign==1` and `x.magnitude==x`, or\n- if `x<0` then `x.sign==-1` and `x.magnitude==-x`,\n\nwhere `0` is the additive identity of the numeric type.\n\nNot every value commonly considered to be a \"number\" is\na `Number`. For example, complex numbers aren't `Number`s\nsince they don't have a total order."],by:["Gavin"]},sts:[{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Numeric"},{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Comparable"}],tp:[{sts:[{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Number"}],nm:"Other"}],st:"Other",$m:{plusInteger:{$t:{nm:"Other"},pa:5,mt:"m",an:{doc:["The result of adding this number to the given \n[[Integer]]."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"integer"}]],nm:"plusInteger"},powerOfInteger:{$t:{nm:"Other"},pa:5,mt:"m",an:{throws:["AssertionError","if the exponent is a negative power and this is \nan integral numeric type"],doc:["The result of raising this number to the given \nnon-negative [[Integer]] power. For a negative power,\nthe behavior is implementation-dependent."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"integer"}]],nm:"powerOfInteger"},timesInteger:{$t:{nm:"Other"},pa:5,mt:"m",an:{doc:["The result of multiplying this number by the given \n[[Integer]]."]},ps:[[{$t:{pk:".",nm:"Integer"},mt:"prm",nm:"integer"}]],nm:"timesInteger"}},$at:{sign:{$t:{pk:".",nm:"Integer"},pa:9,mt:"g",an:{doc:["The sign of this number: \n\n- `1` if the number is [[positive]], \n- `-1` if it is [[negative]], or \n- `0` if it is the additive identity.\n\nMust satisfy:\n\n    x.magnitude.timesInteger(x.sign) == x"]},nm:"sign"},magnitude:{$t:{nm:"Other"},pa:9,mt:"g",an:{doc:["The magnitude of this number, defined for any instance \n`x` as:\n\n- `-x` if `x<0`, or \n- `x` otherwise,\n\nwhere `0` is the additive identity. Hence:\n\n- `x.magnitude >= 0` for any `x`, and\n- `x.magnitude == 0` if and only if `x==0`."]},nm:"magnitude"},wholePart:{$t:{nm:"Other"},pa:5,mt:"a",an:{doc:["The integral value of the number after truncation of \nthe fractional part. For [[Integral]] numeric types, \nthe integral value of a number is the number itself."]},nm:"wholePart"},negative:{$t:{pk:".",nm:"Boolean"},pa:5,mt:"a",an:{doc:["Determine if the number is strictly negative, that is, \nif `this<0`, where `0` is the additive identity."]},nm:"negative"},positive:{$t:{pk:".",nm:"Boolean"},pa:5,mt:"a",an:{doc:["Determine if the number is strictly positive, that is, \nif `this>0`, where `0` is the additive identity."]},nm:"positive"},fractionalPart:{$t:{nm:"Other"},pa:5,mt:"a",an:{doc:["The fractional part of this number, after truncation of \nthe integral part. For [[Integral]] numeric types, the \nfractional part is always zero."]},nm:"fractionalPart"}},nm:"Number"},throws:{$t:{pk:".",nm:"ThrownExceptionAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to document the exception types thrown by a \nfunction, value, class, or constructor."]},ps:[[{$t:{pk:"ceylon.language.meta.declaration",nm:"Declaration"},mt:"prm",an:{doc:["The [[Exception]] type that is thrown."]},nm:"type"},{$t:{pk:".",nm:"String"},def:1,mt:"prm",an:{doc:["A description, in Markdown syntax, of the circumstances \nthat cause this exception to be thrown."]},nm:"when"}]],nm:"throws"},Numeric:{of:[{nm:"Other"}],pa:1,mt:"i",an:{see:["Number"],doc:["Abstraction of numeric types with the usual binary \noperations:\n\n- addition, `x + y`, \n- subtraction, `x - y`, \n- multiplication, `x * y`, and \n- division, `x \/ y`, along with \n- additive inverse `-x`.\n\nA concrete class which implements this interface should be\na mathematical _ring_. That is:\n\n- both addition, `+`, and multiplication, `*`, should be\n  associative and commutative,\n- there should be additive and multiplicative identities,\n  denoted `0` and `1` respectively, satisfying `x+0 == x`\n  and `x*1 == x`,\n- every instance `x` should have an additive inverse `-x`, \n  satisfying `x + -x == 0`, and\n- multiplication should distribute over addition, \n  satisfying `x*(y+z) == x*y + x*z`.\n\nIt is preferred, but not required, that the class be a\nmathematical _field_. That is, in addition to the above:\n\n- every instance `x` such that `x!=0` should have a \n  multiplicative inverse `1\/x`, satisfying `x * 1\/x == 1`. \n\nFor numeric types which are not fields, for example, \n[[Integer]], there is still a division operation, which is\nunderstood to produce a [[remainder|Integral.remainder]].\nThe division operation should satisfy:\n\n- `x*y \/ y == x`\n\nfor any instance `y` other than `0`.\n\nFor numeric types which _are_ fields, division never\nproduces a remainder, and division should additionally \nsatisfy:\n\n- `x\/y * y == x`\n\nfor any instance `y` other than `0`.\n\nSome numeric types, for example complex numbers, do not \nhave a [[total order|Comparable]]. Numeric types with a \ntotal order also satisfy [[Number]]."],by:["Gavin"]},sts:[{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Invertible"}],tp:[{sts:[{tp:[{mt:"tp",nm:"Other"}],pk:".",nm:"Numeric"}],nm:"Other"}],st:"Other",$m:{times:{$t:{nm:"Other"},pa:5,mt:"m",an:{doc:["The product of this number and the given number."]},ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],nm:"times"},divided:{$t:{nm:"Other"},pa:5,mt:"m",an:{see:["Integral.remainder","infinity"],doc:["The quotient obtained by dividing this number by the \ngiven number. For integral numeric types, this \noperation results in a \n[[remainder|Integral.remainder]].\n\nWhen the given number is `0`, the additive identity,\nthe behavior depends on the numeric type:\n\n- For some numeric types, including [[Integer]], \n  division by `0` results in an exception.\n- For others, including [[Float]], it results in a \n  special value of the type, for example, [[infinity]]."]},ps:[[{$t:{nm:"Other"},mt:"prm",nm:"other"}]],nm:"divided"}},nm:"Numeric"},byDecreasing:{$t:{pk:".",nm:"Comparison"},pa:1,mt:"m",an:{see:["byIncreasing","decreasing","Iterable.max","Iterable.sort"],doc:["Produces a comparator function which orders elements in \ndecreasing order according to the [[Comparable]] value \nreturned by the given [[comparable]] function.\n\n     \"Hello World!\".sort(byDecreasing(Character.lowercased))\n\nThis function is intended for use with [[Iterable.sort]]\nand [[Iterable.max]]."]},tp:[{nm:"Element"},{sts:[{tp:[{mt:"tp",nm:"Value"}],pk:".",nm:"Comparable"}],nm:"Value"}],ps:[[{$t:{nm:"Value"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Element"},mt:"prm",nm:"e"}]],nm:"comparable"}],[{$t:{nm:"Element"},mt:"prm",nm:"x"},{$t:{nm:"Element"},mt:"prm",nm:"y"}]],nm:"byDecreasing"},formal:{$t:{pk:".",nm:"FormalAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to mark a member whose implementation must be \nprovided by subtypes."]},nm:"formal"},default:{$t:{pk:".",nm:"DefaultAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to mark a member whose implementation may be \nrefined by subtypes. Non-`default` declarations may not be \nrefined."]},nm:"default"},AnnotationAnnotation:{super:{pk:".",nm:"Basic"},pa:545,mt:"c",an:{doc:["The annotation class for the [[annotation]] meta-annotation."]},sts:[{tp:[{mt:"tp",pk:".",nm:"AnnotationAnnotation"},{comp:"u",mt:"tp",l:[{pk:"ceylon.language.meta.declaration",nm:"ClassDeclaration"},{pk:"ceylon.language.meta.declaration",nm:"FunctionDeclaration"}]},{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"OptionalAnnotation"}],nm:"AnnotationAnnotation"},SequencedAnnotation:{of:[{nm:"Value"}],pa:1,mt:"i",an:{see:["Annotation"],doc:["An annotation that may occur multiple times at a given \nprogram element, and only on certain program elemenets.\n\nA sequenced annotation is declared simply by having the \nannotation class satisfy `SequencedAnnotation` instead of \n[[Annotation]]. For example the following would only be \nallowed on `class` declarations, functions or methods:\n\n    alias ExecutableDeclaration \n           => ClassOrInterfaceDeclaration|FunctionDeclaration;\n    \"Documents a pattern in which the annotated element \n     particpates.\"\n    shared final annotation class Pattern(String name) \n            satisfies SequencedAnnotation<Pattern, ExecutableDeclaration> {}\n\nAt runtime a [[ceylon.language.meta.declaration::Declaration]] \ninstance can be queried for its `SequencedAnnotation`s of \na certain type using [[ceylon.language.meta::annotations]] \nor [[ceylon.language.meta::sequencedAnnotations]]."]},sts:[{tp:[{mt:"tp",nm:"Value"},{mt:"tp",tp:[{mt:"tp",nm:"Value"}],pk:".",nm:"Sequential"},{mt:"tp",nm:"ProgramElement"},{mt:"tp",nm:"Type"}],pk:".",nm:"ConstrainedAnnotation"}],tp:[{dv:"out",sts:[{tp:[{mt:"tp",nm:"Value"},{mt:"tp",nm:"ProgramElement"},{mt:"tp",nm:"Type"}],pk:".",nm:"SequencedAnnotation"}],nm:"Value"},{dv:"in",def:{pk:".",nm:"Annotated"},sts:[{pk:".",nm:"Annotated"}],nm:"ProgramElement"},{dv:"out",def:{pk:".",nm:"Anything"},nm:"Type"}],st:"Value",nm:"SequencedAnnotation"},late:{$t:{pk:".",nm:"LateAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to disable definite initialization analysis for \na reference."]},nm:"late"},identical:{$t:{pk:".",nm:"Boolean"},pa:1,mt:"m",an:{see:["identityHash"],doc:["Determine if the arguments are [[identical]]. Equivalent to\n`x===y`. Only instances of [[Identifiable]] have \nwell-defined identity."]},ps:[[{$t:{pk:".",nm:"Identifiable"},mt:"prm",an:{doc:["An object with well-defined identity."]},nm:"x"},{$t:{pk:".",nm:"Identifiable"},mt:"prm",an:{doc:["A second object with well-defined identity."]},nm:"y"}]],nm:"identical"},parseBoolean:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Boolean"}]},pa:1,mt:"m",an:{doc:["The `Boolean` value of the given string representation of a \nboolean value, or `null` if the string does not represent a \nboolean value.\n\nRecognized values are \"true\", \"false\"."]},ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"string"}]],nm:"parseBoolean"},emptyIterator:{super:{pk:".",nm:"Basic"},pa:1,mt:"o",an:{doc:["An iterator that returns no elements."]},sts:[{tp:[{mt:"tp",pk:".",nm:"Nothing"}],pk:".",nm:"Iterator"}],$m:{next:{$t:{pk:".",nm:"Finished"},pa:3,mt:"m",nm:"next"}},$at:{string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"}},nm:"emptyIterator"},printStackTrace:{$t:{pk:".",nm:"Anything"},pa:65,mt:"m",an:{doc:["Print the stack trace of the given [[Exception]] using the \ngiven [[function|write]], or to \n[[standard error|process.writeError]] if no function is \nspecified."]},ps:[[{$t:{pk:".",nm:"Throwable"},mt:"prm",nm:"exception"},{$t:{pk:".",nm:"Anything"},def:1,mt:"prm",an:{doc:["A function that prints the given string.\nDefaults to [[process.writeError]]."]},$pt:"f",ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"string"}]],nm:"write"}]],nm:"printStackTrace"},operatingSystem:{super:{pk:".",nm:"Basic"},pa:65,mt:"o",an:{see:["process","runtime","language","system"],doc:["Represents the operating system on which the current \nprocess is running."]},$at:{newline:{$t:{pk:".",nm:"String"},pa:65,mt:"a",an:{doc:["The line ending character sequence on this platform."]},nm:"newline"},fileSeparator:{$t:{pk:".",nm:"String"},pa:65,mt:"a",an:{doc:["The character used on this platform to separate the \nfolder\/file elements of a path."]},nm:"fileSeparator"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},name:{$t:{pk:".",nm:"String"},pa:65,mt:"a",an:{doc:["Returns the name of the operating system this process \nis running on."]},nm:"name"},pathSeparator:{$t:{pk:".",nm:"String"},pa:65,mt:"a",an:{doc:["The character used on this platform to use as a \nseparator between several paths in a list of paths."]},nm:"pathSeparator"},version:{$t:{pk:".",nm:"String"},pa:65,mt:"a",an:{doc:["Returns the version of the operating system this \nprocess is running on."]},nm:"version"}},nm:"operatingSystem"},OverflowException:{super:{pk:".",nm:"Exception"},pa:1,mt:"c",an:{doc:["Thrown when a mathematical operation caused a number to \noverflow from its bounds, or when a numeric narrowing\nconversion fails because the number cannot be represented\nwithin the bounds of the narrower type.\n\nNote that:\n\n- arithmetic operations on [[Integer]]s result in _silent_ \n  overflow (JVM) or loss of precision (JavaScript), and \n  thus never result in an `OverflowException`, and, \n- likewise, arithmetic operations on [[Float]] produce the \n  value [[infinity]] instead of overflowing."]},$at:{message$zh6xok:{$t:{pk:".",nm:"String"},mt:"a",nm:"message"}},ps:[{$t:{pk:".",nm:"String"},def:1,mt:"prm",nm:"message"}],nm:"OverflowException"},noop:{$t:{pk:".",nm:"Anything"},pa:1,mt:"m",an:{doc:["A `void` function that does nothing."]},ps:[[{$t:{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"Sequential"},mt:"prm",seq:1,nm:"arguments"}]],nm:"noop"},unzip:{$t:{tp:[{comp:"u",mt:"tp",l:[{tp:[{mt:"tp",nm:"Head"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},{comp:"u",l:[{tp:[{mt:"tp",nm:"Tail"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",tp:[{mt:"tp",nm:"Head"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{tp:[{mt:"tp",nm:"Tail"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},{pk:".",nm:"Nothing"}]},{mt:"tp",tp:[{mt:"tp",nm:"Tail"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}],pk:".",nm:"Tuple"},pa:1,mt:"m",an:{doc:["Given a stream of tuples, return two streams. The\nfirst stream produces the first elements of the\ngiven tuples, and the second stream produces the\nremaining elements of the given tuples.\n\nThus:\n\n    tuples[i] == [unzip(tuples)[0][i], \n                 *unzip(tuples)[1][i]]"]},tp:[{nm:"Element"},{nm:"Head"},{sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"}],nm:"Tail"},{sts:[{pk:".",nm:"Null"}],nm:"Absent"}],ps:[[{$t:{tp:[{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Head"}]},{mt:"tp",nm:"Head"},{mt:"tp",nm:"Tail"}],pk:".",nm:"Tuple"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},mt:"prm",nm:"tuples"}]],nm:"unzip"},runtime:{super:{pk:".",nm:"Basic"},pa:65,mt:"o",an:{see:["process","language","system","operatingSystem"],doc:["Represents the machine and virtual machine on which the \ncurrent process is executing.\n\nHolds information about runtime name, version and about \ninherent limitations like minimum\/maximum values that can \nbe represented by the runtime."]},$at:{maxArraySize:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{see:["Array"],doc:["The maximum size of an [[Array]] that is possible for \nthis runtime. Note that this is a theoretical limit \nonly. In practice it is usually impossible to allocate \nan array of this size, due to memory constraints."]},nm:"maxArraySize"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},name:{$t:{pk:".",nm:"String"},pa:65,mt:"a",an:{doc:["The name of the runtime \/ virtual machine this process \nis running on."]},nm:"name"},integerSize:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{see:["Integer"],doc:["The number of bits used to represent the value of an \n[[Integer]]."]},nm:"integerSize"},maxIntegerValue:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{see:["Integer"],doc:["The maximum [[Integer]] value that can be represented \nby the runtime.\n\nIt is the maximum `Integer` that can be distinguished \nfrom its predecessor using below formula:\n\n`Integer(n+1) = Integer(n) + 1` with `Integer(0) = 0`"]},nm:"maxIntegerValue"},integerAddressableSize:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{doc:["The number of bits of [[Integer]] instances which may \nbe manipulated via the methods inherited from\n[[Binary]]."]},nm:"integerAddressableSize"},minIntegerValue:{$t:{pk:".",nm:"Integer"},pa:65,mt:"a",an:{see:["Integer"],doc:["The minimum [[Integer]] value that can be represented \nby the runtime.\n\nIt is the minimum `Integer` that can be distinguished \nfrom its successor using below formula:\n\n`Integer(n-1) = Integer(n) - 1` with `Integer(0) = 0`"]},nm:"minIntegerValue"},version:{$t:{pk:".",nm:"String"},pa:65,mt:"a",an:{doc:["The version of the runtime \/ virtual machine this \nprocess is running on."]},nm:"version"}},nm:"runtime"},anyPair:{$t:{pk:".",nm:"Boolean"},pa:1,mt:"m",an:{see:["everyPair"],doc:["Given two streams, return `true` if some pair of elements \nin the given streams satisfies the given binary [[predicate\nfunction|selecting]], or `false` otherwise. If one of the\nstreams is longer than the other, simply ignore additional \nelements of the longer stream with no pair in the other \nstream. If either stream is empty, return `false`.\n\nFor any given streams `xs` and `ys`, and predicate function \n`p`, `anyPair()` may be defined in terms of \n[[Iterable.any]], [[zipPairs]], and [[unflatten]]:\n\n    anyPair(p, xs, ys) == zipPairs(xs, ys).any(unflatten(p))"]},tp:[{nm:"First"},{nm:"Second"}],$m:{selecting$hn51wc:{$t:{pk:".",nm:"Boolean"},mt:"m",an:{doc:["The binary predicate function to apply to each pair of \nelements."]},ps:[[{$t:{nm:"First"},mt:"prm",nm:"first"},{$t:{nm:"Second"},mt:"prm",nm:"second"}]],nm:"selecting"}},ps:[[{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The binary predicate function to apply to each pair of \nelements."]},$pt:"f",ps:[[{$t:{nm:"First"},mt:"prm",nm:"first"},{$t:{nm:"Second"},mt:"prm",nm:"second"}]],nm:"selecting"},{$t:{tp:[{mt:"tp",nm:"First"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"firstIterable"},{$t:{tp:[{mt:"tp",nm:"Second"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"secondIterable"}]],nm:"anyPair"},smaller:{super:{pk:".",nm:"Comparison"},pa:1,mt:"o",an:{doc:["The value is smaller than the given value."]},$at:{reversed:{$t:{pk:".",nm:"Comparison"},pa:3,mt:"g",nm:"reversed"}},nm:"smaller"},flatten:{$t:{tp:[{mt:"tp",nm:"Return"},{mt:"tp",nm:"Args"}],pk:".",nm:"Callable"},pa:65,mt:"m",an:{see:["unflatten"],doc:["Given a function with a single parameter of tuple type \n`[P1, P2, ..., Pn]`, return a function with multiple \nparameters of type `P1`, `P2`, ..., `Pn`.\n\nThat is, if `fun` has type `W([X,Y,Z])` then `flatten(fun)` \nhas type `W(X,Y,Z)`.\n\nIn the case of a function whose parameter type is a \nsequence type or unterminated tuple type, the returned \nfunction is variadic:\n\n- if the given function accepts `[S*]`, the returned \n  function has a single variadic parameter of type `S*`,\n- if the given function accepts `[S+]`, the returned \n  function has a single variadic parameter of type `S+`,\n- if the given function accepts `[P1, P2, ..., Pn, S*]`, \n  the returned function has multiple parameters with types\n  `P1`, `P2`, ..., `Pn`, `S*`, or\n- if the given function accepts `[P1, P2, ..., Pn, S+]`,\n  the returned function has multiple parameters with types\n  `P1`, `P2`, ..., `Pn`, `S+`."]},tp:[{nm:"Return"},{sts:[{tp:[{mt:"tp",pk:".",nm:"Anything"}],pk:".",nm:"Sequential"}],nm:"Args"}],ps:[[{$t:{nm:"Return"},mt:"prm",$pt:"f",ps:[[{$t:{nm:"Args"},mt:"prm",nm:"tuple"}]],nm:"tupleFunction"}]],nm:"flatten"},corresponding:{$t:{pk:".",nm:"Boolean"},pa:1,mt:"m",an:{see:["everyPair"],doc:["Compares corresponding elements of the given streams using \nthe given [[binary predicate function|comparing]]. Two \nelements are considered _corresponding_ if they occupy the\nsame position in their respective streams. Returns `true` \nif and only if:\n\n- the two streams have the same number of elements, and \n- if the predicate is satisfied for every pair of \n  corresponding elements.\n\nReturns `false` otherwise. If both streams are empty, \nreturn `true`."]},tp:[{nm:"First"},{nm:"Second"}],$m:{comparing$arwonf:{$t:{pk:".",nm:"Boolean"},mt:"m",an:{doc:["The predicate function that compares an element of the\n[[first stream|firstIterable]] with the corresponding \nelement of the [[second stream|secondIterable]]."]},ps:[[{$t:{nm:"First"},mt:"prm",nm:"first"},{$t:{nm:"Second"},mt:"prm",nm:"second"}]],nm:"comparing"}},ps:[[{$t:{tp:[{mt:"tp",nm:"First"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"firstIterable"},{$t:{tp:[{mt:"tp",nm:"Second"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"secondIterable"},{$t:{pk:".",nm:"Boolean"},mt:"prm",an:{doc:["The predicate function that compares an element of the\n[[first stream|firstIterable]] with the corresponding \nelement of the [[second stream|secondIterable]]."]},$pt:"f",ps:[[{$t:{nm:"First"},mt:"prm",nm:"first"},{$t:{nm:"Second"},mt:"prm",nm:"second"}]],nm:"comparing"}]],nm:"corresponding"},abstract:{$t:{pk:".",nm:"AbstractAnnotation"},pa:513,mt:"m",an:{doc:["Annotation to mark a class as abstract. An `abstract` class\nmay have `formal` members, but may not be directly \ninstantiated. An enumerated class must be `abstract`."]},nm:"abstract"},zip:{$t:{tp:[{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Head"}]},{mt:"tp",nm:"Head"},{mt:"tp",nm:"Tail"}],pk:".",nm:"Tuple"},{comp:"u",mt:"tp",l:[{nm:"HeadAbsent"},{nm:"TailAbsent"}]}],pk:".",nm:"Iterable"},pa:1,mt:"m",an:{doc:["Given a stream of values, and a stream of [[tuples|Tuple]], \nproduce a new stream of tuples formed by prepending the \nvalues in the [[first stream|heads]] to the tuples in the \n[[second stream|tails]]. The length of the resulting stream \nis the length of the shorter of the two given streams.\n\nThus:\n\n    zip(heads, tails)[i] == [heads[i], *tails[i]]\n\nfor every `0<=i<smallest(heads.size,tails.size)`."]},tp:[{nm:"Element"},{nm:"Head"},{sts:[{tp:[{mt:"tp",nm:"Element"}],pk:".",nm:"Sequential"}],nm:"Tail"},{sts:[{pk:".",nm:"Null"}],nm:"HeadAbsent"},{sts:[{pk:".",nm:"Null"}],nm:"TailAbsent"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Head"},{mt:"tp",nm:"HeadAbsent"}],pk:".",nm:"Iterable"},mt:"prm",nm:"heads"},{$t:{tp:[{mt:"tp",nm:"Tail"},{mt:"tp",nm:"TailAbsent"}],pk:".",nm:"Iterable"},mt:"prm",nm:"tails"}]],nm:"zip"},zipEntries:{$t:{tp:[{mt:"tp",tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"Item"}],pk:".",nm:"Entry"},{comp:"u",mt:"tp",l:[{nm:"KeyAbsent"},{nm:"ItemAbsent"}]}],pk:".",nm:"Iterable"},pa:1,mt:"m",an:{doc:["Given two streams, form a new stream consisting of all \n[[entries|Entry]] where, for any given index in the \nresulting stream, the [[key|Entry.key]] of the entry is the \nelement occurring at the same index in the \n[[first stream|keys]], and the [[item|Entry.item]] is the \nelement occurring at the same index in the \n[[second stream|items]]. The length of the resulting stream \nis the length of the shorter of the two given streams.\n\nThus:\n\n    zipEntries(keys, items)[i] == keys[i] -> items[i]\n\nfor every `0<=i<smallest(keys.size,items.size)`."]},tp:[{sts:[{pk:".",nm:"Object"}],nm:"Key"},{nm:"Item"},{sts:[{pk:".",nm:"Null"}],nm:"KeyAbsent"},{sts:[{pk:".",nm:"Null"}],nm:"ItemAbsent"}],ps:[[{$t:{tp:[{mt:"tp",nm:"Key"},{mt:"tp",nm:"KeyAbsent"}],pk:".",nm:"Iterable"},mt:"prm",nm:"keys"},{$t:{tp:[{mt:"tp",nm:"Item"},{mt:"tp",nm:"ItemAbsent"}],pk:".",nm:"Iterable"},mt:"prm",nm:"items"}]],nm:"zipEntries"},print:{$t:{pk:".",nm:"Anything"},pa:1,mt:"m",an:{see:["process.writeLine"],doc:["Print a line to the standard output of the virtual machine \nprocess, printing the given value's `string`, or `<null>` \nif the value is `null`.\n\nThis function is a shortcut for:\n\n    process.writeLine(line?.string else \"<null>\")\n\nand is intended mainly for debugging purposes."],by:["Gavin"]},ps:[[{$t:{pk:".",nm:"Anything"},mt:"prm",nm:"val"}]],nm:"print"},unzipPairs:{$t:{tp:[{comp:"u",mt:"tp",l:[{tp:[{mt:"tp",nm:"First"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},{comp:"u",l:[{tp:[{mt:"tp",nm:"Second"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",tp:[{mt:"tp",nm:"First"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{tp:[{mt:"tp",nm:"Second"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},{pk:".",nm:"Nothing"}]},{mt:"tp",tp:[{mt:"tp",nm:"Second"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}],pk:".",nm:"Tuple"},pa:1,mt:"m",an:{doc:["Given a stream of pairs, return two streams. The\nfirst stream produces the first elements of the\ngiven pairs, and the second stream produces the\nsecond elements of the given pairs.\n\nThus:\n\n    pairs[i] == [unzipPairs(pairs)[0][i], \n                 unzipPairs(pairs)[1][i]]"]},tp:[{nm:"First"},{nm:"Second"},{sts:[{pk:".",nm:"Null"}],nm:"Absent"}],ps:[[{$t:{tp:[{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"First"},{comp:"u",l:[{nm:"Second"},{pk:".",nm:"Nothing"}]}]},{mt:"tp",nm:"First"},{mt:"tp",tp:[{comp:"u",mt:"tp",l:[{nm:"Second"},{pk:".",nm:"Nothing"}]},{mt:"tp",nm:"Second"},{mt:"tp",pk:".",nm:"Empty"}],pk:".",nm:"Tuple"}],pk:".",nm:"Tuple"},{mt:"tp",nm:"Absent"}],pk:".",nm:"Iterable"},mt:"prm",nm:"pairs"}]],nm:"unzipPairs"},ChainedIterator:{super:{pk:".",nm:"Basic"},mt:"c",an:{see:["Iterable.chain"],doc:["An [[Iterator]] that returns the elements of two\n[[Iterable]]s, as if they were chained together."],by:["Enrique Zamudio"]},sts:[{tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],pk:".",nm:"Iterator"}],tp:[{dv:"out",nm:"Element"},{dv:"out",nm:"Other"}],$m:{next:{$t:{comp:"u",l:[{nm:"Element"},{nm:"Other"},{pk:".",nm:"Finished"}]},pa:3,mt:"m",nm:"next"}},$at:{more$5ang2r:{$t:{pk:".",nm:"Boolean"},pa:1027,mt:"a",nm:"more"},string:{$t:{pk:".",nm:"String"},pa:3,mt:"g",nm:"string"},second$9dpb6y:{$t:{tp:[{mt:"tp",nm:"Other"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"a",nm:"second"},first$4h62ti:{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"a",nm:"first"},iter$2p4fla:{$t:{tp:[{comp:"u",mt:"tp",l:[{nm:"Element"},{nm:"Other"}]}],pk:".",nm:"Iterator"},pa:1027,mt:"a",nm:"iter"}},ps:[{$t:{tp:[{mt:"tp",nm:"Element"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"first"},{$t:{tp:[{mt:"tp",nm:"Other"},{mt:"tp",pk:".",nm:"Null"}],pk:".",nm:"Iterable"},mt:"prm",nm:"second"}],nm:"ChainedIterator"},parseFloatExponent:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},mt:"m",ps:[[{$t:{pk:".",nm:"String"},mt:"prm",nm:"string"}]],nm:"parseFloatExponent"},parseIntegerExponent:{$t:{comp:"u",l:[{pk:".",nm:"Null"},{pk:".",nm:"Integer"}]},mt:"m",ps:[[{$t:{pk:".",nm:"Character"},mt:"prm",nm:"char"}]],nm:"parseIntegerExponent"}},"$mod-bin":"8.0"};
//This is quite a special case, since Nothing is not in the model, we need to insert it there
ex$.$CCMM$['ceylon.language']["Nothing"]={mt:"c",an:{"shared":[]},nm:"Nothing"};
});
}(typeof define==='function' && define.amd ? define : function (factory) {
if (typeof exports!=='undefined') { factory(require, exports, module);
} else { throw 'no module loader'; }
}));
